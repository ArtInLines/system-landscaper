/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./built/Geom/Coordinate.js":
/*!**********************************!*\
  !*** ./built/Geom/Coordinate.js ***!
  \**********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nconst randint = (__webpack_require__(/*! ../Utils/random */ \"./built/Utils/random.js\").randint);\nclass Coordinate {\n  /**\r\n   * Coordinates store x and y values.\r\n   * @param {number} x x value. Defaults to 0.\r\n   * @param {number} y y value. Defaults t 0.\r\n   */\n  constructor(x, y) {\n    this.point = [x, y];\n  }\n  get x() {\n    return this.point[0];\n  }\n  set x(value) {\n    this.point[0] = value;\n  }\n  get y() {\n    return this.point[1];\n  }\n  set y(value) {\n    this.point[1] = value;\n  }\n  /**\r\n   * This is a pure convenience function.\r\n   * @param {function} callback Callback function, that receives the current x/y value and an index (0 or 1) indicating whether it's x or y. It should return a new x/y value. It is called once for x and once for y.\r\n   * @returns {Coordinate} Returns this to allow for chaining\r\n   */\n  map(callback) {\n    this.point = this.point.map((v, i) => callback(v, i));\n    return this;\n  }\n  /**\r\n   * Update both values at once. This is a pure convenience function.\r\n   * @param {number} x new x value\r\n   * @param {nmber} y new y value. Defaults to the new x value.\r\n   * @returns {Coordinate} Returns this to allow for chaining\r\n   */\n  update(x) {\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  /**\r\n   * Instance a Rectangle from this Coordinate.\r\n   * @param {number} x Additional x-value. If `pos` isn't changed, this value is the width of the rectangle. Otherwise, if `tr` or `br` is chosen, this value determines the x-offset of the rectangle. Defaults to 0.\r\n   * @param {number} y Additional y-value. If `pos` isn't changed, this value is the height of the rectangle. Otherwise, if `bl` or `br` is chosen, this value determines the y-offset of the rectangle. Defaults to 0.\r\n   * @param {'c'|'tl'|'tr'|'bl'|'br'} pos Determines the position of this coordinate in the new rectangle. `c` stands for \"center\", `tl`, `tr`, `bl`, `br` stand for \"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\", respectively. Defaults to `tl`.\r\n   * @returns {Rectangle}\r\n   */\n  rect() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'tl';\n    const Rectangle = __webpack_require__(/*! ./Rectangle */ \"./built/Geom/Rectangle.js\");\n    switch (pos) {\n      case 'tl':\n        return new Rectangle(this.x, this.y, x, y);\n      case 'tr':\n        return new Rectangle(x, this.y, this.x, y);\n      case 'bl':\n        return new Rectangle(this.x, y, x, this.y);\n      case 'br':\n        return new Rectangle(x, y, this.x, this.y);\n      case 'c':\n        return new Rectangle(this.x - x / 2, this.y - y / 2, x, y);\n    }\n  }\n  /**\r\n   * Copy the Coordinate to a new instance.\r\n   * @returns {Coordinate}\r\n   */\n  copy() {\n    return new Coordinate(this.point[0], this.point[1]);\n  }\n  static rand(maxX, maxY, exclude) {\n    const xVal = randint(maxX);\n    const yVal = randint(maxY);\n    if (exclude) {\n      while (exclude.has(xVal) && exclude.has(yVal)) {\n        xVal = randint(0, maxX);\n        yVal = randint(0, maxY);\n      }\n    }\n    return new Coordinate(xVal, yVal);\n  }\n}\nmodule.exports = Coordinate;\n\n//# sourceURL=webpack://vivagraphjs/./built/Geom/Coordinate.js?");

/***/ }),

/***/ "./built/Geom/Rectangle.js":
/*!*********************************!*\
  !*** ./built/Geom/Rectangle.js ***!
  \*********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nconst Coordinate = __webpack_require__(/*! ./Coordinate */ \"./built/Geom/Coordinate.js\");\nconst intersect = __webpack_require__(/*! gintersect */ \"./node_modules/gintersect/index.js\");\nclass Rectangle {\n  constructor(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n  get left() {\n    return this.x;\n  }\n  set left(x) {\n    this.x = x;\n  }\n  get right() {\n    return this.x + this.width;\n  }\n  set right(x) {\n    this.width = x - this.x;\n  }\n  get top() {\n    return this.y;\n  }\n  set top(y) {\n    this.y = y;\n  }\n  get bottom() {\n    return this.y + this.height;\n  }\n  set bottom(y) {\n    this.height = y - this.y;\n  }\n  get center() {\n    return new Coordinate(this.centerX, this.centerY);\n  }\n  /**\t@param {Coordinate} coord */\n  set center(coord) {\n    this.centerX = coord.x;\n    this.centerY = coord.y;\n  }\n  get centerX() {\n    return this.x + this.width / 2;\n  }\n  set centerX(newX) {\n    let currentX = this.centerX;\n    let diff = newX - currentX;\n    this.x += diff;\n  }\n  get centerY() {\n    return this.y + this.height / 2;\n  }\n  set centerY(newY) {\n    let currentY = this.centerY;\n    let diff = newY - currentY;\n    this.y += diff;\n  }\n  get topLeft() {\n    return new Coordinate(this.x, this.y);\n  }\n  /**\t@param {Coordinate} coord */\n  set topLeft(coord) {\n    this.top = coord.y;\n    this.left = coord.x;\n  }\n  get topRight() {\n    return new Coordinate(this.x + this.width, this.y);\n  }\n  /**\t@param {Coordinate} coord */\n  set topRight(coord) {\n    this.top = coord.y;\n    this.right = coord.x;\n  }\n  get bottomLeft() {\n    return new Coordinate(this.x, this.y + this.height);\n  }\n  /**\t@param {Coordinate} coord */\n  set bottomLeft(coord) {\n    this.bottom = coord.y;\n    this.left = coord.x;\n  }\n  get bottomRight() {\n    return new Coordinate(this.x + this.width, this.y + this.height);\n  }\n  /**\t@param {Coordinate} coord */\n  set bottomRight(coord) {\n    this.bottom = coord.y;\n    this.right = coord.x;\n  }\n  get topCenter() {\n    return new Coordinate(this.x + this.width / 2, this.y);\n  }\n  /**\t@param {Coordinate} coord */\n  set topCenter(coord) {\n    this.y = coord.y;\n    this.centerX = coord.x;\n  }\n  get bottomCenter() {\n    return new Coordinate(this.x + this.width / 2, this.y + this.height);\n  }\n  /**\t@param {Coordinate} coord */\n  set bottomCenter(coord) {\n    this.y = coord.y - this.height;\n    this.centerX = coord.x;\n  }\n  get leftCenter() {\n    return new Coordinate(this.x, this.y + this.height / 2);\n  }\n  /**\t@param {Coordinate} coord */\n  set leftCenter(coord) {\n    this.x = coord.x;\n    this.centerY = coord.y;\n  }\n  get rightCenter() {\n    return new Coordinate(this.x + this.width, this.y + this.height / 2);\n  }\n  /**\t@param {Coordinate} coord */\n  set rightCenter(coord) {\n    this.x = coord.x - this.width;\n    this.centerY = coord.y;\n  }\n  intersect(p1, p2) {\n    return intersect(this.left, this.top, this.left, this.bottom, p1.x, p1.y, p2.x, p2.y) || intersect(this.left, this.bottom, this.right, this.bottom, p1.x, p1.y, p2.x, p2.y) || intersect(this.right, this.bottom, this.right, this.top, p1.x, p1.y, p2.x, p2.y) || intersect(this.right, this.top, this.left, this.top, p1.x, p1.y, p2.x, p2.y);\n  }\n  isPointInside(p) {\n    let radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return this.left <= p.x + radius && this.right >= p.x - radius && this.top <= p.y + radius && this.bottom >= p.y - radius;\n  }\n  resize(factor) {\n    this.width *= factor;\n    this.height *= factor;\n  }\n}\nmodule.exports = Rectangle;\n\n//# sourceURL=webpack://vivagraphjs/./built/Geom/Rectangle.js?");

/***/ }),

/***/ "./built/Graphs/Edge.js":
/*!******************************!*\
  !*** ./built/Graphs/Edge.js ***!
  \******************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventManager = __webpack_require__(/*! ../Utils/EventManager.js */ \"./built/Utils/EventManager.js\");\nconst nextID = __webpack_require__(/*! ../Utils/id.js */ \"./built/Utils/id.js\");\nconst SystemNode = __webpack_require__(/*! ./SystemNode.js */ \"./built/Graphs/SystemNode.js\");\nclass Edge extends EventManager {\n  /**\r\n   * Create a new Edge to connect to Nodes. This class offers certain events to listen to changes:\r\n   \r\n   - `sourceChanged`: When the source of this edge changes. Args: `(newSourceID, edge)`\r\n   - `targetChanged`: When the target of this edge changes. Args: `(newTargetID, edge)`\r\n   - `dataChanged`: When the data of this edge changes. Args: `(updatedData, edge)`\r\n   - `update`: When any of the above events occurs. Args: `(...args of the event - this edge is always the second argument)`\r\n   * @param {SystemNode} source ID of the source node\r\n   * @param {SystemNode} target ID of the target node\r\n   * @param {any} data Data associated with this edge. Defaults to an empty object.\r\n   */\n  constructor(source, target) {\n    var _this;\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    _this = this;\n    this.id = nextID();\n    this.source = source;\n    this.target = target;\n    this.data = data || {};\n    this.on('sourceChanged', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _this.emit('update', ...args);\n    });\n    this.on('targetChanged', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _this.emit('update', ...args);\n    });\n    this.on('dataChanged', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _this.emit('update', ...args);\n    });\n  }\n  get fromId() {\n    return this.source.id;\n  }\n  get toId() {\n    return this.target.id;\n  }\n  setSource(source) {\n    this.source = source;\n    this.emit('sourceChanged', source, this);\n  }\n  setTarget(target) {\n    this.target = target;\n    this.emit('targetChanged', target, this);\n  }\n  setData(data) {\n    this.data = data;\n    this.emit('dataChanged', this.data, this);\n  }\n  updateData(data) {\n    this.data = {\n      ...this.data,\n      ...data\n    };\n    this.emit('dataChanged', this.data, this);\n  }\n  copy() {\n    return new Edge(this.source, this.target, {\n      ...this.data\n    });\n  }\n}\nmodule.exports = Edge;\n\n//# sourceURL=webpack://vivagraphjs/./built/Graphs/Edge.js?");

/***/ }),

/***/ "./built/Graphs/NodeGroup.js":
/*!***********************************!*\
  !*** ./built/Graphs/NodeGroup.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nconst SystemNode = __webpack_require__(/*! ./SystemNode */ \"./built/Graphs/SystemNode.js\");\nconst newID = __webpack_require__(/*! ../Utils/id */ \"./built/Utils/id.js\");\n/**\r\n * @typedef {Object} GroupData\r\n */\n/** @type {GroupData} */\nconst defaultData = {};\nclass NodeGroup {\n  /**\r\n   * Create a Group of Nodes. A group can contain further groups as well as direct children.\r\n   * @param {String} name Name of the group\r\n   * @param {GroupData} data Data associated with the group\r\n   * @param {SystemNode[]} nodes Direct Children-Nodes of this group\r\n   */\n  constructor() {\n    let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : newID();\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let nodes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    /** @type {number} */\n    this.id = id;\n    /** @type {String} */\n    this.name = name !== null && name !== void 0 ? name : '';\n    /** @type {GroupData} */\n    this.data = {\n      ...defaultData,\n      ...data\n    };\n    /** @type {SystemNode[]} */\n    this.nodes = nodes !== null && nodes !== void 0 ? nodes : [];\n    /** @type {NodeGroup[]} */\n    this.groups = [];\n    /** @type {?NodeGroup} */\n    this.parentGroup = null;\n  }\n  findSubGroup(cb) {\n    let found = this.groups.find(cb);\n    if (found) return found;\n    for (let group of this.groups) {\n      found = group.findSubGroup(cb);\n      if (found) return found;\n    }\n    return null;\n  }\n  addNodes() {\n    this.nodes.push(...arguments);\n    return this;\n  }\n  addGroups() {\n    for (var _len = arguments.length, groups = new Array(_len), _key = 0; _key < _len; _key++) {\n      groups[_key] = arguments[_key];\n    }\n    this.groups.push(...groups);\n    groups.forEach(group => group.parentGroup = this);\n    return this;\n  }\n  removeNode(node) {\n    let idx = this.nodes.indexOf(node);\n    if (idx !== -1) {\n      return this.nodes.splice(idx, 1)[0];\n    }\n    for (let group of this.groups) {\n      let removed = group.removeNode(node);\n      if (removed) return removed;\n    }\n    return null;\n  }\n  removeSubGroup(id) {\n    let idx = this.groups.findIndex(group => group.id === id);\n    if (idx !== -1) {\n      return this.groups.splice(idx, 1)[0];\n    }\n    for (let group of this.groups) {\n      let removed = group.removeSubGroup(id);\n      if (removed) return removed;\n    }\n    return null;\n  }\n}\nmodule.exports = NodeGroup;\n\n//# sourceURL=webpack://vivagraphjs/./built/Graphs/NodeGroup.js?");

/***/ }),

/***/ "./built/Graphs/SystemLandscape.js":
/*!*****************************************!*\
  !*** ./built/Graphs/SystemLandscape.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nconst newID = __webpack_require__(/*! ../Utils/id */ \"./built/Utils/id.js\");\nconst Trie = __webpack_require__(/*! ../Utils/Trie */ \"./built/Utils/Trie.js\");\nconst EventManager = __webpack_require__(/*! ../Utils/EventManager */ \"./built/Utils/EventManager.js\");\nconst Change = __webpack_require__(/*! ../Utils/Change */ \"./built/Utils/Change.js\");\nconst SystemTree = __webpack_require__(/*! ./SystemTree */ \"./built/Graphs/SystemTree.js\");\nconst SystemNode = __webpack_require__(/*! ./SystemNode */ \"./built/Graphs/SystemNode.js\");\nconst Edge = __webpack_require__(/*! ./Edge */ \"./built/Graphs/Edge.js\");\n// Expected API:\n// \t\t- addNode(node: NodeId, data?: NodeData) => Node<NodeData>\n// \t\t- addLink(from: NodeId, to: NodeId, data?: LinkData) => Link<LinkData>\n// - removeNode(node: NodeId) => boolean\n// - removeLink(link: LinkId) => boolean\n// \t\t- getNode(node: NodeId) => Node<NodeData> | undefined\n// \t\t- getLink(fromNodeId: NodeId, toNodeId: NodeId) => Link<LinkData> | undefined // TODO: null instead of undefined returned\n// \t\t- hasLink(fromNodeId: NodeId, toNodeId: NodeId) => Link<LinkData> | undefined // TODO: Returns Boolean\n// \t\t- getNodesCount() => number\n// \t\t- getNodeCount() = getNodesCount()\n// \t\t- getLinksCount() => number\n// \t\t- getLinkCount() = getLinksCount()\n// \t\t- getLinks(nodeId: NodeId) => Set<Link<LinkData>> | null // TODO: Different name\n// - forEachNode(callback: (node: Node<NodeData>) => void) => void\n// - forEachLink(callback: (link: Link<LinkData>) => void) => void\n// - forEachLinkedNode(nodeId: NodeId, callback: (node: Node<NodeData>, link: Link<LinkData>) => void) => void, oriented: boolean) => void\n// - beginUpdate() => void\n// - endUpdate() => void\n// - clear() => void\n// export default function createGraph<NodeData = any, LinkData = any>(options?: { multigraph: boolean }): Graph<NodeData, LinkData> & EventedType\n// TODO: Add Events for Renderer to listen to\nclass SystemLandscape extends EventManager {\n  constructor() {\n    super();\n    /** @type {number} */\n    this.id = newID();\n    /** @type {SystemTree[]} */\n    this.systemTrees = [];\n    /** @type {Trie} */\n    this.systemsByName = new Trie();\n    /** @type {Map<Number, SystemNode>} */\n    this.systemsByID = new Map();\n    /** @type {Edge[]} */\n    this.edges = [];\n    /** @type {Object<Object<Change[]>>} */\n    this.changes = {\n      remove: {\n        systems: [],\n        edges: [],\n        trees: []\n      },\n      add: {\n        systems: [],\n        edges: [],\n        trees: []\n      },\n      update: {\n        systems: [],\n        edges: [],\n        trees: []\n      }\n    };\n  }\n  // Checks\n  hasSystem(id) {\n    return this.systemsByID.has(id);\n  }\n  hasEdgeId(id) {\n    return this.getEdgeId(id) !== null;\n  }\n  hasEdge() {\n    let from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return this.getEdge(from, to) !== null;\n  }\n  isVerticalEdge(edge) {\n    var _edge$source, _edge$target;\n    // Edges are vertical iff they connect a parent-node with a child-node\n    return ((_edge$source = edge.source) === null || _edge$source === void 0 ? void 0 : _edge$source.parent) === edge.target || ((_edge$target = edge.target) === null || _edge$target === void 0 ? void 0 : _edge$target.parent) === edge.source;\n  }\n  sameNode(a, b) {\n    if (!(a instanceof SystemNode)) a = this.getSystem(a);\n    if (!(b instanceof SystemNode)) b = this.getSystem(b);\n    return a.id === b.id;\n  }\n  // Getting Data\n  /**\r\n   * Get the system uniquely identified by its ID or name.\r\n   * @param {Number|String|SystemNode} id The unique ID or name of the system. If the system itself is inputted, it is simply returned.\r\n   * @returns {?SystemNode}\r\n   */\n  getSystem(id) {\n    if (id instanceof SystemNode) return id;\n    if (typeof id === 'string') return this.getSystemByName(id);\n    if (this.hasSystem(id)) return this.systemsByID.get(id);else return null;\n  }\n  getNode(id) {\n    return this.getSystem(id);\n  }\n  getSystemTree(id) {\n    return this.systemTrees.find(tree => tree.id === id);\n  }\n  getSystems() {\n    let startLayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let endLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startLayer;\n    let flatten = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let res = this.systemTrees.map(tree => tree.getSystems(startLayer, endLayer));\n    if (flatten) return res.flat(1);else return res;\n  }\n  getSystemsByName(name) {\n    return this.systemsByName.findPrefix(name);\n  }\n  getSystemByName(name) {\n    return this.systemsByName.find(name);\n  }\n  getEdgesOfSystem(systemID) {\n    let horizontal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let vertical = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let includeLinksOfChildren = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let links = new Set();\n    if (!this.hasSystem(systemID)) return links;\n    if (horizontal) {\n      this.edges.forEach(edge => {\n        if (edge.source === systemID || edge.target === systemID) links.add(edge.id);\n      });\n    }\n    if (vertical) {\n      this.getSystem(systemID).getVerticalLinks().forEach(edge => links.add(edge.id));\n    }\n    if (includeLinksOfChildren) {\n      this.getSystem(systemID).getChildren().forEach(child => {\n        this.getEdgesOfSystem(child.id, horizontal, vertical, false).forEach(edge => links.add(edge.id));\n      });\n    }\n    return links;\n  }\n  getEdgeId(id) {\n    var _this$edges$find;\n    if (id instanceof Edge) return id;\n    return (_this$edges$find = this.edges.find(edge => edge.id === id)) !== null && _this$edges$find !== void 0 ? _this$edges$find : null;\n  }\n  getLinkId(id) {\n    return this.getEdgeId(id);\n  }\n  getEdge(from, to) {\n    return this.edges.find(edge => {\n      if (!this.sameNode(edge.source, from)) return false;\n      if (!this.sameNode(edge.target, to)) return false;\n      return true;\n    });\n  }\n  getLink(from, to) {\n    return this.getEdge(from, to);\n  }\n  getHorizontalEdges() {\n    return this.edges.filter(edge => !this.isVerticalEdge(edge));\n  }\n  getVerticalEdges() {\n    return this.edges.filter(edge => this.isVerticalEdge(edge));\n  }\n  getMaxHeight() {\n    let maxHeight = 0;\n    this.systemTrees.forEach(tree => {\n      let h = tree.height;\n      if (h > maxHeight) maxHeight = h;\n    });\n    return maxHeight;\n  }\n  getSystemsCount() {\n    return this.systemsByID.size;\n  }\n  getNodesCount() {\n    return this.getSystemsCount();\n  }\n  getNodeCount() {\n    return this.getSystemsCount();\n  }\n  getSystemTreesCount() {\n    return this.systemTrees.length;\n  }\n  getTreesCount() {\n    return this.getSystemTreesCount();\n  }\n  getEdgesCount() {\n    return this.edges.length;\n  }\n  getLinksCount() {\n    return this.getEdgesCount();\n  }\n  getLinkCount() {\n    return this.getEdgesCount();\n  }\n  // Event Handling\n  /**\r\n   *\r\n   * @param {'add'|'remove'|'update'} type\r\n   * @param {any} el\r\n   * @param {?String|String[]} keys\r\n   */\n  addChange(type, el) {\n    let keys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let change = new Change(type, el, keys);\n    let o = this.changes[type];\n    if (el instanceof SystemNode) {\n      o.systems.push(change);\n    } else if (el instanceof Edge) {\n      o.edges.push(change);\n    } else if (el instanceof SystemTree) {\n      o.trees.push(change);\n    }\n    return change;\n  }\n  emitChanges() {\n    let changes = [];\n    for (let type of ['remove', 'add', 'update']) {\n      for (let el of ['systems', 'edges', 'trees']) {\n        changes.push(...this.changes[type][el]);\n        this.changes[type][el] = [];\n      }\n    }\n    this.emit('changes', changes);\n  }\n  onVerticalEdgeAdded(edge, parent, child) {\n    this._addEdge(edge);\n  }\n  onVerticalEdgeRemoved(edge, parent, child) {\n    this.edges.splice(this.edges.indexOf(edge), 1);\n    this.addChange('remove', edge);\n  }\n  onSystemTreeChanged(systemTree, node) {\n    // TODO\n    if (systemTree.isEmpty()) {\n      this.systemTrees.splice(this.systemTrees.indexOf(systemTree), 1);\n      this.addChange('remove', systemTree);\n    }\n    // else {\n    // \tthis.addChange('update', systemTree, systemTree.data);\n    // }\n  }\n\n  addEventListenersToSystem(system) {\n    var _this = this;\n    system.on('edgeAdded', function () {\n      return _this.onVerticalEdgeAdded(...arguments);\n    });\n    system.on('edgeRemoved', function () {\n      return _this.onVerticalEdgeRemoved(...arguments);\n    });\n    system.on('systemTreeChanged', function () {\n      return _this.onSystemTreeChanged(...arguments);\n    });\n  }\n  addEventListenersToSystemTree(tree) {\n    // TODO\n  }\n  // Adding Data\n  addSystem() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (name === null) name = String(system.id);\n    if (typeof parent === 'string') parent = this.getSystemByName(parent);\n    let i = '';\n    while (this.systemsByName.has(name + i)) i++;\n    name += i;\n    let system = new SystemNode(name, parent, data);\n    this.systemsByName.insert(name, system);\n    this.systemsByID.set(system.id, system);\n    if (!system.systemTree) {\n      let tree = new SystemTree(system);\n      this.systemTrees.push(tree);\n      this.addEventListenersToSystemTree(tree);\n      this.addChange('add', tree);\n    }\n    this.addEventListenersToSystem(system);\n    this.addChange('add', system);\n    this.emitChanges();\n    return system;\n  }\n  _addEdge(edge) {\n    // Check if an edge connecting the two systems already exists\n    let e = this.edges.find(e => e.source === edge.source && e.target === edge.target);\n    if (e) return e;\n    this.edges.push(edge);\n    // this.emit('edgeAdded', edge, this.isVerticalEdge(edge));\n    this.addChange('add', edge);\n    return edge;\n  }\n  addEdge(edge) {\n    let res = this._addEdge(edge);\n    this.emitChanges();\n    return res;\n  }\n  /**\r\n   * Create a new edge to link two systems/systemTrees. If the systems are not in the landscape, they will be added. If an edge between the two systems already exists, it will be returned.\r\n   * @param {?SystemNode|SystemTree} from SystemNode or SystemTree from which the edge comes from\r\n   * @param {?SystemNode|SystemTree} to SystemNode or SystemTree to which the edge goes to\r\n   * @param {any} data Data associated with the edge\r\n   */\n  _linkSystems(from, to) {\n    var _from, _to;\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let edge = this.getEdge(from, to);\n    if (edge) {\n      edge.changeData(data);\n      return edge;\n    }\n    from = this.getSystem(from);\n    to = this.getSystem(to);\n    if (!this.hasSystem((_from = from) === null || _from === void 0 ? void 0 : _from.id)) from = this.addSystem();\n    if (!this.hasSystem((_to = to) === null || _to === void 0 ? void 0 : _to.id)) to = this.addSystem();\n    edge = new Edge(from, to, data);\n    this._addEdge(edge);\n    return edge;\n  }\n  /**\r\n   * Create a new edge to link two systems/systemTrees. If the systems are not in the landscape, they will be added. If an edge between the two systems already exists, it will be returned.\r\n   * @param {?SystemNode|SystemTree} from SystemNode or SystemTree from which the edge comes from\r\n   * @param {?SystemNode|SystemTree} to SystemNode or SystemTree to which the edge goes to\r\n   * @param {any} data Data associated with the edge\r\n   */\n  linkSystems(from, to) {\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let res = this._linkSystems(from, to, data);\n    this.emitChanges();\n    return res;\n  }\n  linkSystemsUndirected(system1, system2, data) {\n    this._linkSystems(system1, system2, data);\n    this._linkSystems(system2, system1, data);\n    this.emitChanges();\n    // TODO: Anything else to do?\n  }\n  // Removing Data\n  _removeSystemTree(id) {\n    let idx = this.systemTrees.findIndex(st => st.id === id);\n    if (idx < 0) return;\n    let sysTree = this.systemTrees[idx];\n    this._removeSystem(sysTree.root);\n    this.systemTrees.splice(idx, 1);\n    this.emitChanges();\n    return sysTree;\n  }\n  removeSystem(id) {\n    let res = null;\n    let sys = this.getSystem(id);\n    if (sys.systemTree.root === sys) res = this._removeSystemTree(sys.systemTree.id);else res = this._removeSystem(sys);\n    this.emitChanges();\n    return res;\n  }\n  _removeSystem(sys) {\n    sys.systemTree.removeSystem(sys.id);\n    this.systemsByID.delete(sys.id);\n    this.systemsByName.delete(sys.name);\n    this.addChange('remove', sys);\n    let sysEdges = this.getEdgesOfSystem(sys.id, true, true, true);\n    sysEdges.forEach(edge => this._removeEdge(edge));\n    return sys;\n  }\n  _removeEdge(id) {\n    let keepBidirectional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let edge = this.getEdgeId(id);\n    if (!edge) return false;\n    let idx = this.edges.findIndex(e => e.id === edge.id);\n    if (idx === -1) return false;\n    if (keepBidirectional) {\n      let edge2 = this.getEdge(edge.target, edge.source);\n      if (edge2) {\n        this._removeEdge(edge2, false);\n      }\n    }\n    let isVertical = this.isVerticalEdge(edge);\n    if (isVertical) {\n      this.getSystem(edge.source).removeChild(edge.target.id);\n    }\n    this.edges.splice(idx, 1);\n    this.addChange('remove', edge);\n    return true;\n  }\n  removeEdge(id) {\n    let keepBidirectional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let res = this._removeEdge(id, keepBidirectional);\n    this.emitChanges();\n    return res;\n  }\n  // Updating Data\n  updateSystemName(id, newName) {\n    let sys = this.getSystem(id);\n    this.systemsByName.delete(sys.name);\n    this.systemsByName.insert(newName, sys);\n    sys.name = newName;\n    this.addChange('update', sys, 'name');\n    this.emitChanges();\n  }\n  updateSystem(id, data) {\n    let sys = this.getSystem(id);\n    if (data !== null && data !== void 0 && data.name) {\n      this.updateSystemName(sys, data.name);\n      delete data.name;\n    }\n    sys.data = {\n      ...sys.data,\n      ...data\n    };\n    this.addChange('update', sys, 'data');\n    this.emitChanges();\n    return sys;\n  }\n  updateEdge(id, data) {\n    let edge = this.getEdgeId(id);\n    if (!edge) return null;\n    edge.data = {\n      ...edge.data,\n      ...data\n    };\n    this.addChange('update', edge, 'data');\n    this.emitChanges();\n    return edge;\n  }\n  // Moving Data\n  moveSystem(id) {\n    let newParentId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let system = this.getSystem(id);\n    this.addChange('remove', system);\n    if (!system) return false;\n    // Edge from old parent should be removed automatically via event listeners\n    let newParent = newParentId === null ? null : this.getSystem(newParentId);\n    if (newParent) {\n      newParent.addChild(system);\n      // New Edge from new Parent should be added automatically via event listeners\n    } else {\n      // If there's no new parent, the system should have its own systemTree created\n      let tree = new SystemTree(system);\n      this.systemTrees.push(tree);\n    }\n    this.addChange('add', system);\n    this.emitChanges();\n  }\n  moveEdgeId(id) {\n    let newSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let newTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let keepBidirectional = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let edge = this.getEdgeId(id);\n    let res = this._moveEdge(edge, newSource, newTarget, keepBidirectional);\n    this.emitChanges();\n    return res;\n  }\n  _moveEdge(edge) {\n    let newSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let newTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let keepBidirectional = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (!edge) return false;\n    this.addChange('remove', edge);\n    if (keepBidirectional) {\n      let otherEdge = this.getEdge(edge.target, edge.source);\n      if (otherEdge) {\n        this._moveEdge(otherEdge, newTarget, newSource, false);\n      }\n    }\n    let newSourceNode = newSource === null ? edge.source : this.getSystem(newSource);\n    let newTargetNode = newTarget === null ? edge.target : this.getSystem(newTarget);\n    let wasVertical = this.isVerticalEdge(edge);\n    if (wasVertical) {\n      var _edge$source2;\n      (_edge$source2 = edge.source) === null || _edge$source2 === void 0 ? void 0 : _edge$source2.removeChild(edge.target.id);\n    }\n    edge.source = newSourceNode;\n    edge.target = newTargetNode;\n    let isVertical = this.isVerticalEdge(edge);\n    if (isVertical) {\n      var _edge$source3;\n      (_edge$source3 = edge.source) === null || _edge$source3 === void 0 ? void 0 : _edge$source3.addChild(edge.target.id);\n    }\n    this.addChange('add', edge);\n    return true;\n  }\n  moveEdge(edge) {\n    let newSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let newTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let keepBidirectional = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let res = this._moveEdge(edge, newSource, newTarget, keepBidirectional);\n    this.emitChanges();\n    return res;\n  }\n  // Looping\n  forEachSystem(callback) {\n    return this.forEachNode(callback);\n  }\n  forEachNode(callback) {\n    this.systemsByID.forEach(node => callback(node));\n  }\n  /**\r\n   * @callback edgeCallback\r\n   * @param {Edge} edge\r\n   */\n  /**\r\n   * Calls the callback for each edge in the graph.\r\n   * @param {edgeCallback} callback\r\n   */\n  forEachEdge(callback) {\n    this.edges.forEach(edge => callback(edge));\n  }\n  /**\r\n   * Calls the callback for each edge in the graph.\r\n   * @param {edgeCallback} callback\r\n   */\n  forEachLink(callback) {\n    return this.forEachEdge(callback);\n  }\n  /**\r\n   * Calls the callback for each horizontal edge in the graph\r\n   * @param {edgeCallback} callback\r\n   */\n  forEachHorizontalEdge(callback) {\n    this.edges.forEach(edge => {\n      if (!this.isVerticalEdge(edge)) {\n        callback(edge);\n      }\n    });\n  }\n  /**\r\n   * Calls the callback for each vertical edge in the graph\r\n   * @param {edgeCallback} callback\r\n   */\n  forEachVerticalEdge(callback) {\n    this.edges.forEach(edge => {\n      if (this.isVerticalEdge(edge)) {\n        callback(edge);\n      }\n    });\n  }\n  // Positioning\n  positionSystem(id, x, y) {\n    // TODO\n  }\n  positionSystemTree(id, x, y) {\n    // TODO\n  }\n  automaticLayout(layout) {\n    // TODO\n  }\n  positionEdge(params) {\n    // TODO\n  }\n  // Saving / Loading\n  save(format) {\n    let location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  } // TODO\n\n  load(location) {\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  } // TODO\n\n  saveView(name) {\n    // TODO\n  }\n  deleteView(name) {\n    // TODO\n  }\n  goBack() {\n    let steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  } // TODO\n\n  goForward() {\n    let steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  } // TODO\n}\n\nmodule.exports = SystemLandscape;\n\n//# sourceURL=webpack://vivagraphjs/./built/Graphs/SystemLandscape.js?");

/***/ }),

/***/ "./built/Graphs/SystemNode.js":
/*!************************************!*\
  !*** ./built/Graphs/SystemNode.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nconst Tree = __webpack_require__(/*! ../Utils/Tree */ \"./built/Utils/Tree.js\");\nconst Edge = __webpack_require__(/*! ./Edge */ \"./built/Graphs/Edge.js\");\nclass SystemNode extends Tree {\n  /**\r\n   * Create a new SystemNode. SystemNodes represent single systems in a tree-like hierachy of systems. To connect several systems (or systemTrees) together, you need to use the SystemLandscape class.\r\n   * @param {?SystemNode} parent The parent of this tree-node\r\n   * @param {any} data Data associated with this node\r\n   */\n  constructor() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(null, data);\n    this.name = name;\n    this.systemTree = parent instanceof SystemNode ? parent.systemTree : null;\n    this.edgesToChildren = [];\n    /** @type {?SystemNode} (For documentation only, remove this and use typescript type-annotations instead in the future) */\n    this.parent = null;\n    this.changeParent(parent);\n  }\n  // Getting Data\n  getEdge(toId) {\n    return this.edgesToChildren.find(edge => edge.target === toId);\n  }\n  getVerticalLinks() {\n    let includeLinkFromParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let res = [];\n    if (includeLinkFromParent && this.parent) res.push(this.parent.getEdge(this.id));\n    res.push(...this.edgesToChildren);\n    return res;\n  }\n  // Updating Data\n  changeSystemTree(systemTree) {\n    this.systemTree = systemTree;\n    this.emit('systemTreeChanged', systemTree, this);\n    this.children.forEach(child => child.changeSystemTree(systemTree));\n  }\n  // Adding Data\n  addChild(child) {\n    super.addChild(child);\n    child.changeSystemTree(this.systemTree);\n    const edge = new Edge(this, child);\n    this.edgesToChildren.push(edge);\n    this.emit('edgeAdded', edge, this, child);\n    return child;\n  }\n  // Removing Data\n  removeChild(id) {\n    let c = super.removeChild(id);\n    if (c) {\n      if (c.systemTree) c.systemTree = null;\n      let idx = this.edgesToChildren.findIndex(edge => edge.target !== id);\n      this.emit('edgeRemoved', this.edgesToChildren[idx], this, c);\n      this.edgesToChildren.splice(idx, 1);\n    }\n    return c;\n  }\n  remove() {\n    super.remove();\n    this.systemTree = null;\n    return this;\n  }\n}\nmodule.exports = SystemNode;\n\n//# sourceURL=webpack://vivagraphjs/./built/Graphs/SystemNode.js?");

/***/ }),

/***/ "./built/Graphs/SystemTree.js":
/*!************************************!*\
  !*** ./built/Graphs/SystemTree.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventManager = __webpack_require__(/*! ../Utils/EventManager */ \"./built/Utils/EventManager.js\");\nconst newID = __webpack_require__(/*! ../Utils/id */ \"./built/Utils/id.js\");\nconst SystemNode = __webpack_require__(/*! ./SystemNode */ \"./built/Graphs/SystemNode.js\");\n// require('./System) can't be called at the top:\n// https://stackoverflow.com/questions/29023320/resolving-circular-dependency-in-nodejs-model\n// Solution: require('./System') inside each function that needs access to it.\n// Another solution would be to not use class syntax but function prototypes\n// That would work since Classes are technically just syntactic sugar\n// Problem with that is the difficult use of \"this\":\n// https://stackoverflow.com/a/20279485/13764271\nclass SystemTree extends EventManager {\n  /**\r\n   * Create a new SystemTree object. SystemTrees store the tree-like structure of systems and allows easy interaction with them. This class also adds events to listen to changes in the tree.\r\n   * @param {?SystemNode} root Root node of the systemTree.\r\n   * @param {any} data Data to store with the systemTree.\r\n   */\n  constructor() {\n    let root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.id = newID();\n    this.data = data || {};\n    this.root = root;\n    if (this.root instanceof SystemNode) this.root.changeSystemTree(this);\n  }\n  get height() {\n    var _this$root$height, _this$root;\n    return (_this$root$height = (_this$root = this.root) === null || _this$root === void 0 ? void 0 : _this$root.height) !== null && _this$root$height !== void 0 ? _this$root$height : 0;\n  }\n  // Checks\n  isEmpty() {\n    return !this.root && Object.keys(this.data).length === 0;\n  }\n  // Getting Data\n  getSystems() {\n    var _this$root$getChildre, _this$root2;\n    let startLayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let endLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startLayer;\n    return (_this$root$getChildre = (_this$root2 = this.root) === null || _this$root2 === void 0 ? void 0 : _this$root2.getChildren(startLayer, endLayer)) !== null && _this$root$getChildre !== void 0 ? _this$root$getChildre : [];\n  }\n  getSystem(id) {\n    var _this$root$getByID, _this$root3;\n    return (_this$root$getByID = (_this$root3 = this.root) === null || _this$root3 === void 0 ? void 0 : _this$root3.getByID(id)) !== null && _this$root$getByID !== void 0 ? _this$root$getByID : null;\n  }\n  getEdge(toId) {\n    var _this$root$getEdge, _this$root4;\n    return (_this$root$getEdge = (_this$root4 = this.root) === null || _this$root4 === void 0 ? void 0 : _this$root4.getEdge(toId)) !== null && _this$root$getEdge !== void 0 ? _this$root$getEdge : null;\n  }\n  getEdgesFrom(fromId) {\n    var _this$getVerticalLink;\n    return (_this$getVerticalLink = this.getVerticalLinks(fromId, false)) !== null && _this$getVerticalLink !== void 0 ? _this$getVerticalLink : [];\n  }\n  getVerticalLinks() {\n    var _node$getVerticalLink;\n    let nodeId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let includeLinkFromParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let node = nodeId ? this.getSystem(nodeId) : this.root;\n    return (_node$getVerticalLink = node === null || node === void 0 ? void 0 : node.getVerticalLinks(includeLinkFromParent)) !== null && _node$getVerticalLink !== void 0 ? _node$getVerticalLink : [];\n  }\n  // Adding Data\n  addChild(system) {\n    this.addSystem(system);\n  }\n  addSystem(system) {\n    let parentId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  } // TODO\n  // Updating Data\n  /**\r\n   * Change the Parent of a system in this tree.\r\n   * @param {Number} systemId ID of the system to change the parent of\r\n   * @param {?SystemTree} newParent The new parent of this system. If set to null, the system will have no parent.\r\n   * @returns {Boolean} Indicates whether the system was found and the parent could thus be changed.\r\n   */\n  changeParent(systemId) {\n    let newParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let system = this.getSystem(systemId);\n    if (!system) return false;\n    system === null || system === void 0 ? void 0 : system.changeParent(newParent);\n    return true;\n  }\n  // Removing Data\n  removeChild(id) {\n    return this.removeSystem(id);\n  }\n  removeSystem(systemId) {\n    let system = this.getSystem(systemId);\n    if (!system) return false;\n    system.remove(system.id);\n    return true;\n  }\n}\nmodule.exports = SystemTree;\n\n//# sourceURL=webpack://vivagraphjs/./built/Graphs/SystemTree.js?");

/***/ }),

/***/ "./built/Input/dragndrop.js":
/*!**********************************!*\
  !*** ./built/Input/dragndrop.js ***!
  \**********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\n/**\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n */\nmodule.exports = dragndrop;\nlet documentEvents = __webpack_require__(/*! ../Utils/documentEvents.js */ \"./built/Utils/documentEvents.js\");\nlet browserInfo = __webpack_require__(/*! ../Utils/browserInfo.js */ \"./built/Utils/browserInfo.js\");\nlet findElementPosition = __webpack_require__(/*! ./findElementPosition.js */ \"./built/Input/findElementPosition.js\");\n// TODO: Move to input namespace\n// TODO: Methods should be extracted into the prototype. This class\n// does not need to consume so much memory for every tracked element\nfunction dragndrop(element) {\n  let start,\n    drag,\n    end,\n    scroll,\n    prevSelectStart,\n    prevDragStart,\n    startX = 0,\n    startY = 0,\n    dragObject,\n    touchInProgress = false,\n    pinchZoomLength = 0,\n    getMousePos = function (e) {\n      let posx = 0,\n        posy = 0;\n      e = e || window.event;\n      if (e.pageX || e.pageY) {\n        posx = e.pageX;\n        posy = e.pageY;\n      } else if (e.clientX || e.clientY) {\n        posx = e.clientX + window.document.body.scrollLeft + window.document.documentElement.scrollLeft;\n        posy = e.clientY + window.document.body.scrollTop + window.document.documentElement.scrollTop;\n      }\n      return [posx, posy];\n    },\n    move = function (e, clientX, clientY) {\n      if (drag) {\n        drag(e, {\n          x: clientX - startX,\n          y: clientY - startY\n        });\n      }\n      startX = clientX;\n      startY = clientY;\n    },\n    stopPropagation = function (e) {\n      if (e.stopPropagation) {\n        e.stopPropagation();\n      } else {\n        e.cancelBubble = true;\n      }\n    },\n    preventDefault = function (e) {\n      if (e.preventDefault) e.preventDefault();\n    },\n    handleDisabledEvent = function (e) {\n      stopPropagation(e);\n      return false;\n    },\n    handleMouseMove = function (e) {\n      e = e || window.event;\n      move(e, e.clientX, e.clientY);\n    },\n    handleMouseDown = function (e) {\n      e = e || window.event;\n      if (touchInProgress) {\n        // modern browsers will fire mousedown for touch events too\n        // we do not want this, since touch is handled separately.\n        stopPropagation(e);\n        return false;\n      }\n      // for IE, left click == 1\n      // for Firefox, left click == 0\n      let isLeftButton = e.button === 1 && window.event !== null || e.button === 0;\n      if (isLeftButton) {\n        startX = e.clientX;\n        startY = e.clientY;\n        // TODO: bump zIndex?\n        dragObject = e.target || e.srcElement;\n        if (start) {\n          start(e, {\n            x: startX,\n            y: startY\n          });\n        }\n        documentEvents.on('mousemove', handleMouseMove);\n        documentEvents.on('mouseup', handleMouseUp);\n        stopPropagation(e);\n        // TODO: What if event already there? Not bullet proof:\n        prevSelectStart = window.document.onselectstart;\n        prevDragStart = window.document.ondragstart;\n        window.document.onselectstart = handleDisabledEvent;\n        dragObject.ondragstart = handleDisabledEvent;\n        // prevent text selection (except IE)\n        return false;\n      }\n    },\n    handleMouseUp = function (e) {\n      e = e || window.event;\n      documentEvents.off('mousemove', handleMouseMove);\n      documentEvents.off('mouseup', handleMouseUp);\n      window.document.onselectstart = prevSelectStart;\n      dragObject.ondragstart = prevDragStart;\n      dragObject = null;\n      if (end) {\n        end(e);\n      }\n    },\n    handleMouseWheel = function (e) {\n      if (typeof scroll !== 'function') {\n        return;\n      }\n      e = e || window.event;\n      if (e.preventDefault) e.preventDefault();\n      e.returnValue = false;\n      let delta = -e.deltaY,\n        mousePos = getMousePos(e),\n        elementOffset = findElementPosition(element),\n        relMousePos = {\n          x: mousePos[0] - elementOffset[0],\n          y: mousePos[1] - elementOffset[1]\n        };\n      scroll(e, delta, relMousePos);\n    },\n    updateScrollEvents = function (scrollCallback) {\n      if (!scroll && scrollCallback) {\n        // client is interested in scrolling. Start listening to events:\n        element.addEventListener('wheel', handleMouseWheel, false);\n      } else if (scroll && !scrollCallback) {\n        element.removeEventListener('wheel', handleMouseWheel, false);\n      }\n      scroll = scrollCallback;\n    },\n    getPinchZoomLength = function (finger1, finger2) {\n      return (finger1.clientX - finger2.clientX) * (finger1.clientX - finger2.clientX) + (finger1.clientY - finger2.clientY) * (finger1.clientY - finger2.clientY);\n    },\n    handleTouchMove = function (e) {\n      if (e.touches.length === 1) {\n        stopPropagation(e);\n        let touch = e.touches[0];\n        move(e, touch.clientX, touch.clientY);\n      } else if (e.touches.length === 2) {\n        // it's a zoom:\n        let currentPinchLength = getPinchZoomLength(e.touches[0], e.touches[1]);\n        let delta = 0;\n        if (currentPinchLength < pinchZoomLength) {\n          delta = -1;\n        } else if (currentPinchLength > pinchZoomLength) {\n          delta = 1;\n        }\n        scroll(e, delta, {\n          x: e.touches[0].clientX,\n          y: e.touches[0].clientY\n        });\n        pinchZoomLength = currentPinchLength;\n        stopPropagation(e);\n        preventDefault(e);\n      }\n    },\n    handleTouchEnd = function (e) {\n      touchInProgress = false;\n      documentEvents.off('touchmove', handleTouchMove);\n      documentEvents.off('touchend', handleTouchEnd);\n      documentEvents.off('touchcancel', handleTouchEnd);\n      dragObject = null;\n      if (end) {\n        end(e);\n      }\n    },\n    handleSignleFingerTouch = function (e, touch) {\n      stopPropagation(e);\n      preventDefault(e);\n      startX = touch.clientX;\n      startY = touch.clientY;\n      dragObject = e.target || e.srcElement;\n      if (start) {\n        start(e, {\n          x: startX,\n          y: startY\n        });\n      }\n      // TODO: can I enter into the state when touch is in progress\n      // but it's still a single finger touch?\n      if (!touchInProgress) {\n        touchInProgress = true;\n        documentEvents.on('touchmove', handleTouchMove);\n        documentEvents.on('touchend', handleTouchEnd);\n        documentEvents.on('touchcancel', handleTouchEnd);\n      }\n    },\n    handleTouchStart = function (e) {\n      if (e.touches.length === 1) {\n        return handleSignleFingerTouch(e, e.touches[0]);\n      } else if (e.touches.length === 2) {\n        // handleTouchMove() will care about pinch zoom.\n        stopPropagation(e);\n        preventDefault(e);\n        pinchZoomLength = getPinchZoomLength(e.touches[0], e.touches[1]);\n      }\n      // don't care about the rest.\n    };\n\n  element.addEventListener('mousedown', handleMouseDown);\n  element.addEventListener('touchstart', handleTouchStart);\n  return {\n    onStart: function (callback) {\n      start = callback;\n      return this;\n    },\n    onDrag: function (callback) {\n      drag = callback;\n      return this;\n    },\n    onStop: function (callback) {\n      end = callback;\n      return this;\n    },\n    /**\r\n     * Occurs when mouse wheel event happens. callback = function(e, scrollDelta, scrollPoint);\r\n     */\n    onScroll: function (callback) {\n      updateScrollEvents(callback);\n      return this;\n    },\n    release: function () {\n      // TODO: could be unsafe. We might wanna release dragObject, etc.\n      element.removeEventListener('mousedown', handleMouseDown);\n      element.removeEventListener('touchstart', handleTouchStart);\n      documentEvents.off('mousemove', handleMouseMove);\n      documentEvents.off('mouseup', handleMouseUp);\n      documentEvents.off('touchmove', handleTouchMove);\n      documentEvents.off('touchend', handleTouchEnd);\n      documentEvents.off('touchcancel', handleTouchEnd);\n      updateScrollEvents(null);\n    }\n  };\n}\n\n//# sourceURL=webpack://vivagraphjs/./built/Input/dragndrop.js?");

/***/ }),

/***/ "./built/Input/findElementPosition.js":
/*!********************************************!*\
  !*** ./built/Input/findElementPosition.js ***!
  \********************************************/
/***/ (function(module) {

"use strict";
eval("\n\n/**\r\n * Finds the absolute position of an element on a page\r\n */\nmodule.exports = findElementPosition;\nfunction findElementPosition(obj) {\n  let curleft = 0,\n    curtop = 0;\n  if (obj.offsetParent) {\n    do {\n      curleft += obj.offsetLeft;\n      curtop += obj.offsetTop;\n    } while ((obj = obj.offsetParent) !== null);\n  }\n  return [curleft, curtop];\n}\n\n//# sourceURL=webpack://vivagraphjs/./built/Input/findElementPosition.js?");

/***/ }),

/***/ "./built/Layout/Layout.js":
/*!********************************!*\
  !*** ./built/Layout/Layout.js ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nconst Coordinate = __webpack_require__(/*! ../Geom/Coordinate */ \"./built/Geom/Coordinate.js\");\nconst Rectangle = __webpack_require__(/*! ../Geom/Rectangle */ \"./built/Geom/Rectangle.js\");\nclass Layout {\n  constructor(nodeWidth, nodeHeight) {\n    // TODO: Implement Layouts as classes\n    // with the base class positioning nodes randomly\n    // and with extended Layouts being able to use\n    // many of the base functions defined here\n    this.nodeWidth = nodeWidth;\n    this.nodeHeight = nodeHeight;\n  }\n  /**\r\n   * Check whether the node is positioned within the confines set by the rect.\r\n   * @param {Coordinate} coord Coordinate of the node's center\r\n   * @param {Number} nodeWidth Width of the Node\r\n   * @param {Number} nodeHeight Height of the Node\r\n   * @param {Rectangle} rect Sets the maximum values that are possible for the nodes\r\n   * @returns {boolean}\r\n   */\n  isNodePosInMaxSize(coord, nodeWidth, nodeHeight, rect) {\n    let w = nodeWidth / 2;\n    let h = nodeHeight / 2;\n    return coord.x + w <= rect.right && coord.y + h <= rect.bottom && coord.x - w >= rect.left && coord.y - h >= rect.top;\n  }\n  /**\r\n   * Check whether the node is overlapping with any other already positioned node\r\n   * @param {Coordinate} coord Coordinate of the node's center\r\n   * @param {Number} nodeWidth Width of the Node\r\n   * @param {Number} nodeHeight Height of the Node\r\n   * @param {Map<Number, Coordinate>} currentNodePositions Mapping from NodeIds to the node' current positions\r\n   * @returns {boolean}\r\n   */\n  areNodesOverlapping(coord, nodeWidth, nodeHeight, currentNodePositions) {\n    for (let nodeId of currentNodePositions.keys()) {\n      let nodePos = currentNodePositions.get(nodeId);\n      if (Math.abs(coord.x - nodePos.x) < nodeWidth && Math.abs(coord.y - nodePos.y) < nodeHeight) return true;\n    }\n    return false;\n  }\n  /**\r\n   * Gives each node a position based on all other visible nodes.\r\n   * @param {Iterable<SystemNode>} nodes Iterable of all visible nodes\r\n   * @param {NodeGroup} grouping Grouping of all visible nodes\r\n   * @param {Map<Number, Coordinate>} currentNodePositions Mapping from Node-Ids to their current positions\r\n   * @param {Rectangle} rect The rectangle in which all nodes are to be positioned\r\n   * @param {Number} nodeWidth Width of the Node\r\n   * @param {Number} nodeHeight Height of the Node\r\n   * @returns {Map<Number, Coordinate>} Mapping from Node-Ids to their new positions\r\n   */\n  layout(nodes, grouping, currentNodePositions, rect, nodeWidth, nodeHeight) {\n    if (!Array.isArray(nodes) && !(nodes instanceof Set)) nodes = [nodes];\n    let nodePositions = new Map();\n    currentNodePositions.forEach((nodePos, nodeId) => {\n      if (this.isNodePosInMaxSize(nodePos, nodeWidth, nodeHeight, rect)) {\n        nodePositions.set(nodeId, nodePos);\n      }\n    });\n    let w = nodeWidth / 2;\n    let h = nodeHeight / 2;\n    for (const node of nodes) {\n      var _node$id;\n      const id = (_node$id = node === null || node === void 0 ? void 0 : node.id) !== null && _node$id !== void 0 ? _node$id : node;\n      if (nodePositions.has(id)) continue;\n      let val = null;\n      do {\n        // this.isNodePosInMaxSize() doesn't have to be checked\n        // bcause the x,y coordinates are calculated in a way,\n        // that they can't be outside the maxRect\n        let x = Math.floor(Math.random() * (rect.width - nodeWidth)) + rect.left + w;\n        let y = Math.floor(Math.random() * (rect.height - nodeHeight)) + rect.top + h;\n        val = new Coordinate(x, y);\n      } while (this.areNodesOverlapping(val, nodeWidth, nodeHeight, nodePositions));\n      nodePositions.set(id, val);\n    }\n    return nodePositions;\n  }\n}\nmodule.exports = Layout;\n\n//# sourceURL=webpack://vivagraphjs/./built/Layout/Layout.js?");

/***/ }),

/***/ "./built/Layout/randLayout.js":
/*!************************************!*\
  !*** ./built/Layout/randLayout.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nconst Coordinate = __webpack_require__(/*! ../Geom/Coordinate.js */ \"./built/Geom/Coordinate.js\");\nconst SystemNode = __webpack_require__(/*! ../Graphs/SystemNode.js */ \"./built/Graphs/SystemNode.js\");\nconst NodeGroup = __webpack_require__(/*! ../Graphs/NodeGroup.js */ \"./built/Graphs/NodeGroup.js\");\n/**\r\n * Gives each node a position based on all other visible nodes.\r\n * @param {Iterable<SystemNode>} nodes Iterable of all visible nodes\r\n * @param {NodeGroup} grouping Grouping of all visible nodes\r\n * @param {Map<Number, Coordinate>} currentNodePositions Mapping from Node-Ids to their current positions\r\n * @param {Coordinate} maxSize Sets the maximum values that are possible for the nodes\r\n */\nfunction randLayout(nodes, grouping, currentNodePositions, maxSize) {\n  let nodePositions = new Map();\n  for (const node of nodes) {\n    var _node$id;\n    const id = (_node$id = node === null || node === void 0 ? void 0 : node.id) !== null && _node$id !== void 0 ? _node$id : node;\n    let val = null;\n    if (currentNodePositions.has(id)) val = currentNodePositions.get(id);else val = Coordinate.rand(maxSize.x, maxSize.y, currentNodePositions);\n    nodePositions.set(id, val);\n  }\n  return nodePositions;\n}\n/**\r\n * Gives a single node a position based on all other visible nodes.\r\n * @param {SystemNode} node Node to be positioned\r\n * @param {NodeGroup} grouping Grouping of all visible nodes\r\n * @param {Map<Number, Coordinate>} currentNodePositions Mapping from Node-Ids to their current positions\r\n * @param {Coordinate} maxSize Sets the maximum values that are possible for the nodes\r\n */\nfunction randSingleLayout(node, grouping, currentNodePositions, maxSize) {\n  return Coordinate.rand(maxSize.x, maxSize.y, currentNodePositions);\n}\nmodule.exports = {\n  randLayout,\n  randSingleLayout\n};\n\n//# sourceURL=webpack://vivagraphjs/./built/Layout/randLayout.js?");

/***/ }),

/***/ "./built/Utils/Change.js":
/*!*******************************!*\
  !*** ./built/Utils/Change.js ***!
  \*******************************/
/***/ (function(module) {

"use strict";
eval("\n\nclass Change {\n  /**\r\n   *\r\n   * @param {'add'|'remove'|'update'} type\r\n   * @param {any} el\r\n   * @param {?String|Sring[]} keys\r\n   */\n  constructor(type, el) {\n    let keys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    this.type = type;\n    this.el = el;\n    this.keys = keys;\n  }\n  getData() {\n    let data = el;\n    if (Array.isArray(keys)) {\n      keys.forEach(key => {\n        data = data[key];\n      });\n    } else if (typeof keys === 'string') {\n      data = data[keys];\n    }\n    return data;\n  }\n}\nmodule.exports = Change;\n\n//# sourceURL=webpack://vivagraphjs/./built/Utils/Change.js?");

/***/ }),

/***/ "./built/Utils/EventManager.js":
/*!*************************************!*\
  !*** ./built/Utils/EventManager.js ***!
  \*************************************/
/***/ (function(module) {

"use strict";
eval("\n\nclass EventManager {\n  constructor() {\n    this.events = {};\n  }\n  on(event, callback) {\n    if (!this.events[event]) this.events[event] = [];\n    if (typeof callback === 'function') this.events[event].push(callback);\n    return this;\n  }\n  once(event, callback) {\n    const self = this;\n    const onceCallback = function () {\n      callback(...arguments);\n      self.off(event, onceCallback);\n    };\n    return this.on(event, onceCallback);\n  }\n  off() {\n    let event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (event === null) this.events = {};else if (this.events[event]) {\n      if (callback === null) delete this.events[event];else this.events[event] = this.events[event].filter(cb => cb !== callback);\n    }\n    return this;\n  }\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    if (!this.events[event]) {\n      return;\n    }\n    this.events[event].forEach(cb => cb(...args));\n    return this;\n  }\n}\nmodule.exports = EventManager;\n\n//# sourceURL=webpack://vivagraphjs/./built/Utils/EventManager.js?");

/***/ }),

/***/ "./built/Utils/Tree.js":
/*!*****************************!*\
  !*** ./built/Utils/Tree.js ***!
  \*****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nconst newID = __webpack_require__(/*! ../Utils/id */ \"./built/Utils/id.js\");\nconst EventManager = __webpack_require__(/*! ./EventManager */ \"./built/Utils/EventManager.js\");\nclass Tree extends EventManager {\n  /**\r\n   * Create a new Tree object. All nodes in the Tree are instances of this Tree class.\r\n   * @param {?Tree} parent The parent of this tree-node\r\n   * @param {any} data Data associated with this node\r\n   */\n  constructor() {\n    let parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    /** @type {Number} */\n    this.id = newID();\n    /** @type {any} */\n    this.data = data || {};\n    /** @type {?Tree} */\n    this.parent = parent;\n    /** @type {Tree[]} */\n    this.children = [];\n  }\n  /**\r\n   * Returns how many levels deep this node is in the tree.\r\n   * @returns {Number}\r\n   */\n  get depth() {\n    let depth = 0;\n    let parent = this.parent;\n    while (parent !== null) {\n      depth++;\n      parent = parent.parent;\n    }\n    return depth;\n  }\n  /**\tSynonym for this.depth */\n  get layer() {\n    return this.depth;\n  }\n  /**\r\n   * Returns how many levels the tree goes deeper from here\r\n   * @returns {Number}\r\n   */\n  get height() {\n    if (this.isLeaf()) return 0;\n    let h = Math.max(...this.children.map(child => child.height)) + 1;\n    return h;\n  }\n  /**\r\n   * Get the root-node of this tree.\r\n   * @returns {Tree}\r\n   */\n  get root() {\n    if (this.parent === null) return this;\n    let parent = this.parent;\n    while (parent.parent !== null) {\n      parent = parent.parent;\n    }\n    return parent;\n  }\n  /**\r\n   * Check if this Tree-Node is empty - i.e. has no children and no data associated with it.\r\n   * @returns {Boolean}\r\n   */\n  isEmpty() {\n    return this.children.length === 0 && Object.keys(this.data).length === 0;\n  }\n  /**\r\n   * Check if this Tree-Node is a leaf - i.e. has no children.\r\n   * @returns {Boolean}\r\n   */\n  isLeaf() {\n    return this.children.length === 0;\n  }\n  /**\r\n   * Check if this Tree-Node is the root of its tree - i.e. it has no parent.\r\n   * @returns {Boolean}\r\n   */\n  isRoot() {\n    return this.parent === null;\n  }\n  /**\r\n   * Check if the node has any siblings - i.e. it's not the only child of its parent.\r\n   * @returns {Boolean}\r\n   */\n  hasSiblings() {\n    if (this.parent === null) return false;\n    return this.parent.children.length > 1;\n  }\n  /**\r\n   * Check if the node has any siblings to its left\r\n   * @returns {Boolean}\r\n   */\n  hasLeftSibling() {\n    if (this.parent === null) return false;\n    // Only the left-most child has no left sibling\n    return this.parent.children[0] !== this;\n  }\n  /**\r\n   * Check if the node has any siblings to its right\r\n   * @returns {Boolean}\r\n   */\n  hasRightSibling() {\n    if (this.parent === null) return false;\n    // Only the right-most child has no right sibling\n    return this.parent.children[this.parent.children.length - 1] !== this;\n  }\n  /**\r\n   * Get all nodes in the tree, that are in startLayer, endLayer or any layer in between. The layers are counted from this node onward. That is done to implement this method recursively, as users will mainly call it from the root only anyways.\r\n   \r\n   If startLayer is 0, this node is included in the result as well.\r\n   \r\n   Defaults to get all nodes in the tree, starting from layer 0 and going to layer Infinity (that is until the tree ended).\r\n   * @param {Number} startLayer The first layer to get nodes from\r\n   * @param {Number} endLayer The last layer to get nodes from\r\n   * @returns {Tree[]} List of Nodes in the specified range of layers.\r\n   */\n  getChildren() {\n    let startLayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let endLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n    if (startLayer === 0 && endLayer === 0) {\n      return [this];\n    } else if (startLayer === 0) {\n      let nodes = [this];\n      this.children.forEach(child => nodes.push(...child.getChildren(0, endLayer - 1)));\n      return nodes;\n    } else {\n      let nodes = [];\n      this.children.forEach(child => nodes.push(...child.getChildren(startLayer - 1, endLayer - 1)));\n      return nodes;\n    }\n  }\n  /**\r\n   * Get the Node with the specified id. If it doesn't exist in this Tree, `null` is returned instead.\r\n   * @param {Number} id The ID of the node to get\r\n   * @returns {?Tree}\r\n   */\n  getByID(id) {\n    if (this.id === id) return this;\n    for (let child of this.children) {\n      let res = child.getByID(id);\n      if (res !== null) return res;\n    }\n    return null;\n  }\n  /**\r\n   * Add a child-node to this node.\r\n   * @param {Tree} child The child to add to this tree\r\n   * @returns {Tree} The child that was added\r\n   */\n  addChild(child) {\n    var _child$parent;\n    child === null || child === void 0 ? void 0 : (_child$parent = child.parent) === null || _child$parent === void 0 ? void 0 : _child$parent.removeChild(child.id);\n    child.parent = this;\n    this.children.push(child);\n    return child;\n  }\n  /**\r\n   * Move a child-node to a new index in the children-array. This is specifically useful when children-order matters, like with certain tree-drawing algorithms.\r\n   * @param {Tree | Number} child The child to move or its ID.\r\n   * @param {Number} idx The new index that the child should be moved to.\r\n   * @returns\r\n   */\n  moveChildToIdx(child, idx) {\n    if (this.removeChild(child.id) === null) return false;\n    this.children.splice(idx, 0, child);\n    return true;\n  }\n  /**\r\n   * Change this node's parent.\r\n   * @param {?Tree} newParent The new parent of this node. If set to null, this system will have no parent.\r\n   */\n  changeParent() {\n    var _this$parent;\n    let newParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.removeChild(this.id);\n    newParent === null || newParent === void 0 ? void 0 : newParent.addChild(this);\n  }\n  /**\r\n   * Remove a child of this tree. To remove this node itself, set all references to it to `null` and let the garbage collector handle it. All children of the node will be removed as well, unless you save another reference to them before.\r\n   * @param {Number} id The ID of the node to remove\r\n   * @returns {?Tree} Returns the removed child or `null` if the child couldn't be found.\r\n   */\n  removeChild(id) {\n    let idx = this.children.findIndex(child => child.id === id);\n    if (idx === -1) {\n      for (let child of this.children) {\n        let res = child.removeChild(id);\n        if (res) return res;\n      }\n      return null;\n    } else {\n      let removedChild = this.children.splice(idx, 1)[0];\n      removedChild.parent = null;\n      this.emit('childRemoved', removedChild, this);\n      return removedChild;\n    }\n  }\n  removeAllChildren() {\n    for (let child of this.children) {\n      child.removeAllChildren();\n      this.removeChild(child.id);\n    }\n    return this;\n  }\n  remove() {\n    var _this$parent2;\n    this.removeAllChildren();\n    (_this$parent2 = this.parent) === null || _this$parent2 === void 0 ? void 0 : _this$parent2.removeChild(this.id);\n    return this;\n  }\n}\nmodule.exports = Tree;\n\n//# sourceURL=webpack://vivagraphjs/./built/Utils/Tree.js?");

/***/ }),

/***/ "./built/Utils/Trie.js":
/*!*****************************!*\
  !*** ./built/Utils/Trie.js ***!
  \*****************************/
/***/ (function(module) {

"use strict";
eval("\n\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nvar _allKeys = /*#__PURE__*/new WeakSet();\nvar _replacePrefix = /*#__PURE__*/new WeakSet();\nclass Trie {\n  constructor() {\n    _classPrivateMethodInitSpec(this, _replacePrefix);\n    _classPrivateMethodInitSpec(this, _allKeys);\n    /** @type {String[]} */\n    this.chars = [];\n    /** @type {Trie[]} */\n    this.tries = [];\n    /** @type {any} */\n    this.val = null;\n  }\n  /**\r\n   * Check if this Node is empty - i.e. has no children and no value and is therefore ready to be removed.\r\n   * @returns {boolean}\r\n   */\n  isEmpty() {\n    return this.chars.length === 0 && this.val === null;\n  }\n  /**\r\n   * Check whether the Trie contains a Node with the name `str`\r\n   * @param {String} str Name of the node\r\n   * @returns {boolean}\r\n   */\n  has(str) {\n    return this.find(str) !== null;\n  }\n  /**\r\n   * Find the value associated with the name `str`\r\n   * @param {String} str Name of the Node\r\n   * @returns {?any} If the Node doesn't exist, `null` is returned\r\n   */\n  find(str) {\n    if (str === '') return this.val;\n    let idx = this.chars.indexOf(str[0]);\n    if (idx === -1) return null;else return this.tries[idx].find(str.substring(1));\n  }\n  /**\r\n   * Insert a new value associated with some name\r\n   * @param {String} str Name of the Node\r\n   * @param {any} val Value to associate with the name `str`\r\n   * @returns {Trie} Returns this Trie to allow chained calls\r\n   */\n  insert(str, val) {\n    if (str === '') {\n      this.val = val;\n      return this;\n    }\n    let idx = this.chars.indexOf(str[0]);\n    if (idx === -1) {\n      this.chars.push(str[0]);\n      this.tries.push(new Trie());\n      idx = this.chars.length - 1;\n    }\n    this.tries[idx].insert(str.substring(1), val);\n    return this;\n  }\n  /**\r\n   * Remove the Node associated with `str`\r\n   * @param {String} str Name of the Node\r\n   * @returns {boolean} Indicates whether the Node was successfully removed. Should only be `false` if the Node didn't exist.\r\n   */\n  delete(str) {\n    if (str === '') {\n      this.val = null;\n      return;\n    }\n    let idx = this.chars.indexOf(str[0]);\n    if (idx === -1) return;\n    this.tries[idx].delete(str.substring(1));\n    if (this.tries[idx].isEmpty()) {\n      this.chars.splice(idx, 1);\n      this.tries.splice(idx, 1);\n    }\n  }\n  // For String Completion\n  /**\r\n   * Auxiliary function for #replacePrefix()\r\n   * @param {String} str\r\n   * @param {String} prefix\r\n   * @returns {String[]}\r\n   */\n\n  /**\r\n   * Find all keys in this Trie that start with `str`\r\n   * @param {String} str Prefix to search for\r\n   * @returns {String[]} Returns all valid names in the Trie that start with `str`\r\n   */\n  findPrefix(str) {\n    return _classPrivateMethodGet(this, _replacePrefix, _replacePrefix2).call(this, str, str);\n  }\n}\nfunction _allKeys2(str) {\n  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  let res = [];\n  if (this.val !== null) res.push(prefix);\n  this.chars.forEach((c, i) => {\n    var _this$tries$i;\n    res.push(..._classPrivateMethodGet(_this$tries$i = this.tries[i], _allKeys, _allKeys2).call(_this$tries$i, str, prefix + c));\n  });\n  return res;\n}\nfunction _replacePrefix2(str) {\n  var _this$tries$idx;\n  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  if (str === '') return _classPrivateMethodGet(this, _allKeys, _allKeys2).call(this, prefix);\n  let idx = this.chars.indexOf(str[0]);\n  if (idx === -1) return [];else return _classPrivateMethodGet(_this$tries$idx = this.tries[idx], _replacePrefix, _replacePrefix2).call(_this$tries$idx, str.substring(1), prefix);\n}\nmodule.exports = Trie;\n\n//# sourceURL=webpack://vivagraphjs/./built/Utils/Trie.js?");

/***/ }),

/***/ "./built/Utils/browserInfo.js":
/*!************************************!*\
  !*** ./built/Utils/browserInfo.js ***!
  \************************************/
/***/ (function(module) {

"use strict";
eval("\n\nmodule.exports = browserInfo();\nfunction browserInfo() {\n  if (typeof window === 'undefined' || !window.hasOwnProperty('navigator')) {\n    return {\n      browser: '',\n      version: '0'\n    };\n  }\n  let ua = window.navigator.userAgent.toLowerCase(),\n    // Useragent RegExp\n    rwebkit = /(webkit)[ \\/]([\\w.]+)/,\n    ropera = /(opera)(?:.*version)?[ \\/]([\\w.]+)/,\n    rmsie = /(msie) ([\\w.]+)/,\n    rmozilla = /(mozilla)(?:.*? rv:([\\w.]+))?/,\n    match = rwebkit.exec(ua) || ropera.exec(ua) || rmsie.exec(ua) || ua.indexOf('compatible') < 0 && rmozilla.exec(ua) || [];\n  return {\n    browser: match[1] || '',\n    version: match[2] || '0'\n  };\n}\n\n//# sourceURL=webpack://vivagraphjs/./built/Utils/browserInfo.js?");

/***/ }),

/***/ "./built/Utils/documentEvents.js":
/*!***************************************!*\
  !*** ./built/Utils/documentEvents.js ***!
  \***************************************/
/***/ (function(module) {

"use strict";
eval("\n\nmodule.exports = createDocumentEvents();\nfunction createDocumentEvents() {\n  if (typeof document === undefined) {\n    return {\n      on: () => {},\n      off: () => {}\n    };\n  }\n  return {\n    on: on,\n    off: off\n  };\n}\nfunction on(eventName, handler) {\n  document.addEventListener(eventName, handler);\n}\nfunction off(eventName, handler) {\n  document.removeEventListener(eventName, handler);\n}\n\n//# sourceURL=webpack://vivagraphjs/./built/Utils/documentEvents.js?");

/***/ }),

/***/ "./built/Utils/id.js":
/*!***************************!*\
  !*** ./built/Utils/id.js ***!
  \***************************/
/***/ (function(module) {

"use strict";
eval("\n\nglobalIDCounter = 0;\nmodule.exports = function newID() {\n  return ++globalIDCounter;\n};\n\n//# sourceURL=webpack://vivagraphjs/./built/Utils/id.js?");

/***/ }),

/***/ "./built/Utils/random.js":
/*!*******************************!*\
  !*** ./built/Utils/random.js ***!
  \*******************************/
/***/ (function(module) {

"use strict";
eval("\n\n/**\r\n * Get a pseudo-random integer in the interval [start, end] (end is inclusive).\r\n * @param {number} end\r\n * @param {number} start Defaults to 0.\r\n * @returns {number}\r\n */\nfunction randint(end) {\n  let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return Math.floor(Math.random() * (end + 1)) + start;\n}\nmodule.exports = {\n  randint\n};\n\n//# sourceURL=webpack://vivagraphjs/./built/Utils/random.js?");

/***/ }),

/***/ "./built/Utils/svgHelper.js":
/*!**********************************!*\
  !*** ./built/Utils/svgHelper.js ***!
  \**********************************/
/***/ (function(module) {

"use strict";
eval("\n\nconst svgns = 'http://www.w3.org/2000/svg';\nconst xlinkns = 'http://www.w3.org/1999/xlink';\n/**\r\n * Create a new SVG-Element. Optionally set attributes of the element immediately too.\r\n * @param {String} tagName Desired type of svg-element\r\n * @param {?Object<String, String>} attrs Object mapping attribute names to values. If `null`, no attributes are set. Defaults to `null`.\r\n * @returns {SVGElement}\r\n */\nfunction createEl(tagName) {\n  let attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let el = document.createElementNS(svgns, tagName);\n  if (attrs) setAttrs(el, attrs);\n  return el;\n}\nmodule.exports.createEl = createEl;\n/**\r\n * Append a child element to another element.\r\n * @param {SVGElement} el Parent Element\r\n * @param {SVGElement | String} child Child Element. If a String is given, a new Element with the specified tagName is created.\r\n * @returns {SVGElement} The appended child\r\n */\nfunction append(el, child) {\n  if (typeof child === 'string') child = createEl(child);\n  el.appendChild(child);\n  return child;\n}\nmodule.exports.append = append;\n/**\r\n * Set an SVG-Element's link attribute.\r\n * @param {SVGElement} el Element that gets linked from\r\n * @param {String} target Target URL\r\n * @returns {SVGElement}\r\n */\nfunction setLink(el, target) {\n  el.setAttributeNS(xlinkns, 'xlink:href', target);\n  return el;\n}\nmodule.exports.setLink = setLink;\n/**\r\n * Get the link-address currently targeted by `el`. Returns `null`, if `el` has no link attribute.\r\n * @param {SVGElement} el\r\n * @returns {?String}\r\n */\nfunction getLink(el) {\n  return el.getAttributeNS(xlinkns, 'xlink:href');\n}\nmodule.exports.getLink = getLink;\n/**\r\n * Set an attribute with a not further specified namespace.\r\n * @param {SVGElement} el\r\n * @param {String} name Attribute Name\r\n * @param {String} val Attribute Value\r\n * @returns {SVGElement}\r\n */\nfunction setAttr(el, name) {\n  let val = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (val !== null) el.setAttributeNS(null, name, val);else el.removeAttributeNS(null, name);\n  return el;\n}\nmodule.exports.setAttr = setAttr;\n/**\r\n * Set several attributes at once. This calls setAttr() for each attribute.\r\n * @param {SVGElement} el\r\n * @param {Object<String, String>} attrs Object mapping attribute names to values\r\n * @returns {SVGElement} The modified element\r\n */\nfunction setAttrs(el, attrs) {\n  for (let name in attrs) {\n    setAttr(el, name, attrs[name]);\n  }\n  return el;\n}\nmodule.exports.setAttrs = setAttrs;\n/**\r\n * Get the value associated with the specified attribute. Returns `null` if `el` has no attribute with the name `name`.\r\n * @param {SVGElement} el\r\n * @param {String} name Attribute Name\r\n * @returns {?String}\r\n */\nfunction getAttr(el, name) {\n  return el.getAttributeNS(null, name);\n}\nmodule.exports.getAttr = getAttr;\n/**\r\n * Create an Arrow Marker for a specified node-size. A marker should only be defined once in a <defs> child element of the root <svg> element.\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {string} id ID of the marker. This is used to refer to the marker again later. Defaults to `Arrow`.\r\n * @returns {SVGMarkerElement}\r\n */\nfunction createArrowMarker(size) {\n  let id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Arrow';\n  let marker = createEl('marker');\n  setAttr(marker, 'id', id);\n  setAttr(marker, 'viewBox', \"0 0 \".concat(size, \" \").concat(size));\n  setAttr(marker, 'refX', \"\".concat(size));\n  setAttr(marker, 'refY', \"\".concat(size / 2));\n  setAttr(marker, 'markerUnits', 'strokeWidth');\n  setAttr(marker, 'markerWidth', \"\".concat(size));\n  setAttr(marker, 'markerHeight', \"\".concat(size / 2));\n  setAttr(marker, 'fill', '#333');\n  setAttr(marker, 'orient', 'auto');\n  let path = append(marker, 'path');\n  setAttr(path, 'd', \"M 0 0 L \".concat(size, \" \").concat(size / 2, \" L 0 \").concat(size, \" z\"));\n  return marker;\n}\nmodule.exports.createArrowMarker = createArrowMarker;\n\n//# sourceURL=webpack://vivagraphjs/./built/Utils/svgHelper.js?");

/***/ }),

/***/ "./built/Utils/timer.js":
/*!******************************!*\
  !*** ./built/Utils/timer.js ***!
  \******************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\n/**\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n */\nmodule.exports = createTimer();\nfunction createTimer() {\n  let lastTime = 0,\n    vendors = ['ms', 'moz', 'webkit', 'o'],\n    i,\n    scope;\n  if (typeof window !== 'undefined') {\n    scope = window;\n  } else if (typeof __webpack_require__.g !== 'undefined') {\n    scope = __webpack_require__.g;\n  } else {\n    scope = {\n      setTimeout: noop,\n      clearTimeout: noop\n    };\n  }\n  for (i = 0; i < vendors.length && !scope.requestAnimationFrame; ++i) {\n    let vendorPrefix = vendors[i];\n    scope.requestAnimationFrame = scope[vendorPrefix + 'RequestAnimationFrame'];\n    scope.cancelAnimationFrame = scope[vendorPrefix + 'CancelAnimationFrame'] || scope[vendorPrefix + 'CancelRequestAnimationFrame'];\n  }\n  if (!scope.requestAnimationFrame) {\n    scope.requestAnimationFrame = rafPolyfill;\n  }\n  if (!scope.cancelAnimationFrame) {\n    scope.cancelAnimationFrame = cancelRafPolyfill;\n  }\n  return timer;\n  /**\r\n   * Timer that fires callback with given interval (in ms) until\r\n   * callback returns true;\r\n   */\n  function timer(callback) {\n    let intervalId;\n    startTimer(); // start it right away.\n    return {\n      /**\r\n       * Stops execution of the callback\r\n       */\n      stop: stopTimer,\n      restart: restart\n    };\n    function startTimer() {\n      intervalId = scope.requestAnimationFrame(startTimer);\n      if (!callback()) {\n        stopTimer();\n      }\n    }\n    function stopTimer() {\n      scope.cancelAnimationFrame(intervalId);\n      intervalId = 0;\n    }\n    function restart() {\n      if (!intervalId) {\n        startTimer();\n      }\n    }\n  }\n  function rafPolyfill(callback) {\n    let currTime = new Date().getTime();\n    let timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    let id = scope.setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  }\n  function cancelRafPolyfill(id) {\n    scope.clearTimeout(id);\n  }\n}\nfunction noop() {}\n\n//# sourceURL=webpack://vivagraphjs/./built/Utils/timer.js?");

/***/ }),

/***/ "./built/Views/SingleLayerTreeMapView.js":
/*!***********************************************!*\
  !*** ./built/Views/SingleLayerTreeMapView.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nconst SingleLayerView = __webpack_require__(/*! ./SingleLayerView */ \"./built/Views/SingleLayerView.js\");\nclass SingleLayerTreeMapView extends SingleLayerView {\n  _isEdgeVisible() {\n    return false;\n  }\n}\nmodule.exports = SingleLayerTreeMapView;\n\n//# sourceURL=webpack://vivagraphjs/./built/Views/SingleLayerTreeMapView.js?");

/***/ }),

/***/ "./built/Views/SingleLayerView.js":
/*!****************************************!*\
  !*** ./built/Views/SingleLayerView.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nconst View = __webpack_require__(/*! ./View */ \"./built/Views/View.js\");\nconst Edge = __webpack_require__(/*! ../Graphs/Edge */ \"./built/Graphs/Edge.js\");\nclass SingleLayerView extends View {\n  /**\r\n   * This view only shows nodes that are at the same layer/depth as specified by `layer`.\r\n   * @param {number} layer\r\n   * @param {viewSettings} settings\r\n   */\n  constructor(layer) {\n    let settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(settings);\n    this.layer = layer;\n  }\n  _isNodeVisible(node) {\n    return node.depth === this.layer;\n  }\n  getVisibleNodes(cached) {\n    if (!cached) {\n      let nodes = [];\n      this.graph.systemTrees.forEach(tree => {\n        nodes.push(...tree.getSystems(this.layer));\n      });\n      this.visibleNodes = nodes;\n    }\n    return this.visibleNodes;\n  }\n  _isEdgeVisible(edge) {\n    return this._isNodeVisible(edge.source) && this._isNodeVisible(edge.target);\n  }\n}\nmodule.exports = SingleLayerView;\n\n//# sourceURL=webpack://vivagraphjs/./built/Views/SingleLayerView.js?");

/***/ }),

/***/ "./built/Views/View.js":
/*!*****************************!*\
  !*** ./built/Views/View.js ***!
  \*****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nconst SystemLandscape = __webpack_require__(/*! ../Graphs/SystemLandscape */ \"./built/Graphs/SystemLandscape.js\");\nconst SystemNode = __webpack_require__(/*! ../Graphs/SystemNode */ \"./built/Graphs/SystemNode.js\");\nconst SystemTree = __webpack_require__(/*! ../Graphs/SystemTree */ \"./built/Graphs/SystemTree.js\");\nconst EventManager = __webpack_require__(/*! ../Utils/EventManager */ \"./built/Utils/EventManager.js\");\nconst NodeGroup = __webpack_require__(/*! ../Graphs/NodeGroup */ \"./built/Graphs/NodeGroup.js\");\nconst Edge = __webpack_require__(/*! ../Graphs/Edge */ \"./built/Graphs/Edge.js\");\nconst Change = __webpack_require__(/*! ../Utils/Change */ \"./built/Utils/Change.js\");\n// Expected API:\n// - init(SystemLandscaper)\n// - getVisibleNodes()\n//\t\tReturn Set/Array of all nodes that are visible\n/**\r\n * @typedef {Object} viewSettings\r\n * @property {boolean} alloweUpwardEdgeInheritance Let A be a parent node with B as its child node. If A is visible and B isn't, then this setting determines whether edges connecting B will be shown as connecting A. Defaults to true.\r\n */\n/** @type {viewSettings} */\nconst defaultSettings = {\n  alloweUpwardEdgeInheritance: true\n};\nclass View extends EventManager {\n  /**\r\n   * Base-View Class. Probably you want to use a subclass of this.\r\n   *\r\n   * Emitted Events:\r\n   * - \"[type]-add\"\r\n   * - \"[type]-remove\"\r\n   * - \"[type]-update\"\r\n   *\r\n   * where \"type\" is one of:\r\n   * - node\r\n   * - edge\r\n   * - group\r\n   */\n  constructor() {\n    let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    settings = {\n      ...defaultSettings,\n      ...settings\n    };\n    /** @type {?SystemLandscape} */\n    this.graph = null;\n    /** @type {SystemNode[]} */\n    this.visibleNodes = [];\n    /** @type {Edge[]} */\n    this.visibleEdges = [];\n    /** @type {NodeGroup} */\n    this.grouping = new NodeGroup();\n    /** @type {boolean} */\n    this.alloweUpwardEdgeInheritance = settings.alloweUpwardEdgeInheritance;\n  }\n  init(graph) {\n    this.graph = graph;\n    this.graph.on('changes', this._onGraphChange.bind(this));\n    // Populate visible nodes/edges for cache:\n    this.getVisibleNodes(false);\n    this.getVisibleEdges(false);\n    return this;\n  }\n  /**\r\n   * @param {Change[]} changes\r\n   */\n  _onGraphChange(changes) {\n    for (let change of changes) {\n      let type = change.type;\n      let el = change.el;\n      switch (type) {\n        case 'add':\n          if (el instanceof SystemNode) this._onNodeAdded(el);else if (el instanceof Edge) this._onEdgeAdded(el);else if (el instanceof SystemTree) this._onSystemTreeAdded(el);\n          break;\n        case 'remove':\n          if (el instanceof SystemNode) this._onNodeRemoved(el);else if (el instanceof Edge) this._onEdgeRemoved(el);else if (el instanceof SystemTree) this._onSystemTreeRemoved(el);\n          break;\n        case 'update':\n          if (el instanceof SystemNode) this._onNodeUpdated(el);else if (el instanceof Edge) this._onEdgeUpdated(el);else if (el instanceof SystemTree) this._onSystemTreeUpdated(el);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  _onNodeAdded(node) {\n    if (this._isNodeVisible(node)) {\n      this.visibleNodes.push(node);\n      this._addNodeToGroups(node);\n      this.emit('node-add', node);\n    }\n  }\n  _onNodeUpdated(node) {\n    if (this.visibleNodes.indexOf(node) !== -1) {\n      this.emit('node-update', node);\n    }\n  }\n  _onNodeRemoved(node) {\n    let idx = this.visibleNodes.indexOf(node);\n    if (idx !== -1) {\n      this.visibleNodes.splice(idx, 1);\n      this.grouping.removeNode(node);\n      this.emit('node-remove', node);\n    }\n  }\n  _onEdgeAdded(edge) {\n    if (this._isEdgeVisible(edge)) {\n      this.visibleEdges.push(edge);\n      this.emit('edge-add', edge);\n    } else if (this.alloweUpwardEdgeInheritance && edge.source.systemTree !== edge.target.systemTree) {\n      let source = this._getFirstVisibleAncestor(edge.source);\n      let target = this._getFirstVisibleAncestor(edge.target);\n      if (source && target) {\n        let modifiedEdge = new Edge(source, target, {\n          ...edge.data\n        });\n        this.visibleEdges.push(modifiedEdge);\n        this.emit('edge-add', modifiedEdge);\n      }\n    }\n  }\n  _onEdgeUpdated(edge) {\n    if (this.visibleEdges.indexOf(edge) !== -1) {\n      this.emit('edge-update', edge);\n    }\n  }\n  _onEdgeRemoved(edge) {\n    let idx = this.visibleEdges.indexOf(edge);\n    if (idx !== -1) {\n      this.visibleEdges.splice(idx, 1);\n      this.emit('edge-remove', edge);\n    }\n  }\n  _onSystemTreeAdded(systemTree) {\n    let g = new NodeGroup(systemTree.id, systemTree.name);\n    this.grouping.addGroups(g);\n    this.emit('group-add', g);\n  }\n  _onSystemTreeUpdated(systemTree) {\n    let g = this.grouping.findSubGroup(group => group.id === systemTree.id);\n    if (g) {\n      g.name = systemTree.name;\n      this.emit('group-update', g);\n    }\n  }\n  _onSystemTreeRemoved(systemTree) {\n    let g = this.grouping.removeSubGroup(systemTree.id);\n    this.emit('group-remove', g);\n  }\n  /**\r\n   * Check whether the specified node is visible or not. This function should be overwritten by children classes.\r\n   * @param {SystemNode} node\r\n   * @returns {boolean}\r\n   */\n  _isNodeVisible(node) {\n    return true; // For the base class, all nodes are visible\n  }\n\n  _isNodeOrAncestorVisible(node) {\n    if (this.visibleNodes.includes(node)) return true;else if (node !== null && node !== void 0 && node.parent) return this._isNodeOrAncestorVisible(node.parent);else return false;\n  }\n  /**\r\n   * Get a list of all Nodes that are visible in this view.\r\n   * @params {boolean} cached Wether to use the cached list or not. If not, the cache gets updated. Default: true\r\n   * @returns {SystemNode[]}\r\n   */\n  getVisibleNodes() {\n    let cached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!cached) this.visibleNodes = this.graph.getSystems(0, Infinity, true).filter(this._isNodeVisible.bind(this));\n    return this.visibleNodes;\n  }\n  /**\r\n   *\r\n   * @param {SystemNode} node\r\n   */\n  _addNodeToGroups(node) {\n    if (node.systemTree !== null) {\n      let group = this.grouping.findSubGroup(group => {\n        var _node$systemTree;\n        return group.id === ((_node$systemTree = node.systemTree) === null || _node$systemTree === void 0 ? void 0 : _node$systemTree.id);\n      });\n      if (group) group.addNodes(node);else {\n        this.grouping.addGroups(new NodeGroup(node.systemTree.id, node.systemTree.name, {}, [node]));\n        this._onSystemTreeAdded(node.systemTree);\n      }\n    } else {\n      this.grouping.addNodes(node);\n    }\n  }\n  /**\r\n   * Check whether the specified node is visible or not. This function should be overwritten by children classes.\r\n   * @param {Edge} edge\r\n   * @returns {boolean}\r\n   */\n  _isEdgeVisible(edge) {\n    return true;\n  }\n  /**\r\n   * Goes up the system tree until a node is visible. That node is returned. If no parent-node is visible, then null is returned.\r\n   * @param {SystemNode} node\r\n   * @returns {?SystemNode}\r\n   */\n  _getFirstVisibleAncestor(node) {\n    if (this.visibleNodes.includes(node)) return node;\n    while ((_node = node) !== null && _node !== void 0 && _node.parent) {\n      var _node;\n      node = node.parent;\n      if (this.visibleNodes.includes(node)) return node;\n    }\n    return null;\n  }\n  /**\r\n   * Get a list of all Edges that should be visible as edges/arrows in this view.\r\n   * @params {boolean} cached Wether to use the cached list or not. If not, the cache gets updated. Default: true\r\n   * @returns {Edge[]}\r\n   */\n  getVisibleEdges() {\n    let cached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!cached) this.visibleEdges = this.graph.edges.filter(this._isEdgeVisible.bind(this));\n    return this.visibleEdges;\n  }\n}\nmodule.exports = View;\n\n//# sourceURL=webpack://vivagraphjs/./built/Views/View.js?");

/***/ }),

/***/ "./built/renderer.js":
/*!***************************!*\
  !*** ./built/renderer.js ***!
  \***************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventManager = __webpack_require__(/*! ./Utils/EventManager */ \"./built/Utils/EventManager.js\");\nconst Coordinate = __webpack_require__(/*! ./Geom/Coordinate */ \"./built/Geom/Coordinate.js\");\nconst svg = __webpack_require__(/*! ./Utils/svgHelper */ \"./built/Utils/svgHelper.js\");\nconst {\n  randLayout,\n  randSingleLayout\n} = __webpack_require__(/*! ./Layout/randLayout */ \"./built/Layout/randLayout.js\");\nconst SingleLayerView = __webpack_require__(/*! ./Views/SingleLayerView */ \"./built/Views/SingleLayerView.js\");\nconst dragndrop = __webpack_require__(/*! ./Input/dragndrop */ \"./built/Input/dragndrop.js\");\nconst timer = __webpack_require__(/*! ./Utils/timer */ \"./built/Utils/timer.js\");\n/**\r\n * @typedef {object} timerRes\r\n * @property {function} stop\r\n * @property {function} restart\r\n */\n/**\r\n * @typedef {function} timer\r\n * @param {?function} callback\r\n * @returns {timerRes}\r\n */\n// For JSDocs:\nconst SystemLandscape = __webpack_require__(/*! ./Graphs/SystemLandscape */ \"./built/Graphs/SystemLandscape.js\");\nconst SystemTree = __webpack_require__(/*! ./Graphs/SystemTree */ \"./built/Graphs/SystemTree.js\");\nconst SystemNode = __webpack_require__(/*! ./Graphs/SystemNode */ \"./built/Graphs/SystemNode.js\");\nconst Edge = __webpack_require__(/*! ./Graphs/Edge */ \"./built/Graphs/Edge.js\");\nconst View = __webpack_require__(/*! ./Views/View */ \"./built/Views/View.js\");\nconst Rectangle = __webpack_require__(/*! ./Geom/Rectangle */ \"./built/Geom/Rectangle.js\");\nconst Layout = __webpack_require__(/*! ./Layout/Layout */ \"./built/Layout/Layout.js\");\n// Wanted API:\n// - run(layout?)\n//\t\tInitialize Renderer & start rendering loop\n//\t\tlayout determines the initial layout-function to be called to give the nodes their initial position\n// - pause()\n// - resume()\n// - changeView(view)\n//\t\tChanges the View to a specified `view`\n//\t\tThe view specifies which nodes are visible\n//\t\tThe view also specifies how vertical links between nodes should be visualized\n//\t\tThe View determines how nodes / edges are drawn\n//\t\tFurther customizations might be added by the view (later)\n// - runLayout(layout)\n//\t\tCalls a layout function\n//\t\tThe function should return a mapping from nodeIds to new (x,y)-coordinates for them\n// - zoomIn()\n// - zoomOut()\n// - selectNodes(nodeId)\n// - moveNode(nodeId, x, y)\n// - moveEdge() / shapeEdge() / something like that to create curves\n// - moveCamera(x, y)\n// - centerCamera(id)\n//\t\tcenters camera on specified node / systemTree / graph\n//\t\tif undefined, centers on graph\n// - drawNode(node, x, y)\n// UI-Handling:\n// - on node clicked\n// - on edge clicked\n//\t\tIf trees are drawn with groupings around the nodes, listen to those spaces being clicked too\n// - on node drag-and-dropped\n// For later\n// \t\tEdge moved or drawn differently\n// Events to allow listeners for:\n// - nodeSelected\n// - edgeSelected\n// - nodeMoved\n// Events the Renderer listens to (emitted by system-landscape):\n// - newNode\n// - newEdge\n// - updated / removed node or edge\n/**\r\n * @typedef {Object} rendererSettings\r\n * @property {number} frameInterval number of milliseconds to wait between rendering each frame. Defaults to 30.\r\n * @property {HTMLElement} container Container elemnent, in which the svg-container is added.\r\n * @property {?Coordinate} maxSize Maximum rectangle size. Defaults to the whole size of `container`.\r\n * @property {View} view View to use for rendering.\r\n * @property {Layout} Layout Function to use for finding the position of a single new node.\r\n */\n/** @type {rendererSettings} */\nconst defaultSettings = {\n  frameInterval: 30,\n  container: document.body,\n  maxSize: null,\n  view: new SingleLayerView(0),\n  Layout: new Layout()\n};\nclass Renderer extends EventManager {\n  /**\r\n   * @param {SystemLandscape} graph Graph to render\r\n   * @param {rendererSettings} settings Optional Settings that can be adjusted\r\n   */\n  constructor(graph) {\n    let settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    settings = {\n      ...defaultSettings,\n      ...settings\n    };\n    // TODO:\n    // this.nodeLength = 30; // How big should the nodes be drawn???\n    this.nodeHeight = 30;\n    this.nodeWidth = 80;\n    this.arrowSize = 20;\n    this.drawnNodes = new Map(); // Map<ID, SVG-Element>\n    this.drawnEdges = new Map(); // Map<ID, SVG-Element>\n    this.userInteraction = false;\n    this.Layout = settings.Layout;\n    this.selectedNodes = [];\n    this.selectedEdges = [];\n    this.just_selected = false;\n    /** @type {SystemLandscape} System-Landscape-Graph to render */\n    this.graph = graph;\n    /** @type {View} Current View */\n    this.view = settings.view.init(this.graph); // TODO: Set view\n    /** @type {Map<Number, Coordinate>} Maps NodeIds to their nodes' coordinates */\n    this.nodePositions = new Map();\n    /** @type {HTMLElement} */\n    this.container = settings.container;\n    /** @type {SVGSVGElement} The top svg-root element */\n    this.svgRoot = svg.createEl('svg');\n    /** @type {SVGGraphicsElement} The top container element, direct child of svgRoot */\n    this.svgContainer = svg.createEl('g');\n    /** TODO: Refactor dragndrop */\n    this.dragContainer = dragndrop(this.container);\n    /** @type {number} Factor indicating how far we are zoomed in/out of the system-map */\n    this.zoomFactor = 1;\n    /** @type {Coordinate} camera offset */\n    this.offset = new Coordinate(0, 0);\n    /** @type {Coordinate} Maximum Size for the svg-container to take up */\n    this.maxSize = this._setMaxSizeHelper(settings.maxSize);\n    /** @type {Rectangle} Rectangle defining the confines of the svg-container */\n    this.maxRect = new Rectangle(0, 0, this.maxSize.x, this.maxSize.y);\n    /** @type {number} How many ms to wait between rendering frames */\n    this.frameInterval = settings.frameInterval;\n    /** @type {boolean} Indicates whether the Render has been started to run */\n    this.isInitialized = false;\n  }\n  _init() {\n    // Add HTML-Elements to DOM\n    svg.setAttr(this.svgContainer, 'buffered-rendering', 'dynamic');\n    this.svgRoot.appendChild(this.svgContainer);\n    this.container.appendChild(this.svgRoot);\n    // Initialize SVG-Stuff\n    this._transform();\n    let defs = svg.append(this.svgRoot, 'defs'); // Create <defs> element for definitions\n    svg.append(defs, svg.createArrowMarker(this.arrowSize, 'Arrow'));\n    // Initialize Event-Listeners\n    window.addEventListener('resize', this._onResize.bind(this));\n    window.addEventListener('keydown', this._onKeyDown.bind(this));\n    this._setViewListeners();\n    // TODO: Let the following event-listeners be changeable by the user\n    this.dragContainer.onDrag((e, offset) => {\n      this._translateRel(offset);\n      this._render();\n    });\n    this.dragContainer.onScroll((e, scaleOffset, scrollPoint) => {\n      this._scale(scaleOffset < 0, scrollPoint);\n    });\n    this.container.addEventListener('click', () => {\n      if (!this.just_selected) {\n        this.deselectEdges();\n        this.deselectNodes();\n      }\n      this.just_selected = false;\n    });\n    // TODO: Listen to changes in the graph and update accordingly\n    this._resetVisible();\n  }\n  _resetVisible() {\n    this.svgContainer.innerHTML = '';\n    this.drawnNodes.clear();\n    this.drawnEdges.clear();\n    this.nodePositions.clear();\n    let nodes = this.getVisibleNodes();\n    nodes.forEach(node => {\n      this._addNode(node);\n    });\n    let edges = this.view.getVisibleEdges();\n    edges.forEach(edge => {\n      if (this.drawnNodes.has(edge.source.id) && this.drawnNodes.has(edge.target.id)) {\n        this._addEdge(edge);\n      }\n      // TODO\n    });\n  }\n  /**\r\n   * Get a Coordinate for the maxSize. If the input is set to null (default), then the maxSize will be calculated from the container-element's size. Otherwise, if the input is a Coordinate, object or Array, the coordinates will stay the same. This function always returns an instance of a Coordinate\r\n   * @returns {Coordinate}\r\n   */\n  _setMaxSizeHelper() {\n    var _obj$x, _obj$y;\n    let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (obj === null) return new Coordinate(this.container.clientWidth, this.container.clientHeight);\n    if (obj instanceof Coordinate) return obj;\n    let x = (_obj$x = obj === null || obj === void 0 ? void 0 : obj.x) !== null && _obj$x !== void 0 ? _obj$x : obj[0];\n    let y = (_obj$y = obj === null || obj === void 0 ? void 0 : obj.y) !== null && _obj$y !== void 0 ? _obj$y : obj[1];\n    return new Coordinate(x, y);\n  }\n  _onKeyDown(e) {\n    // If backspace is pressed, delete all selected nodes\n    if (e.key === 'Backspace') {\n      for (let nodeContainer of this.selectedNodes) {\n        let node = nodeContainer.node;\n        this.graph.removeSystem(node.id);\n      }\n      this.selectedNodes = [];\n    }\n  }\n  /**\r\n   * Get a list of all systemNodes, that are visible in the current view\r\n   * @returns {Array<SystemNode>}\r\n   */\n  getVisibleNodes() {\n    return this.view.getVisibleNodes();\n  }\n  run() {\n    if (!this.isInitialized) this._init();\n    this.nodePositions = this.Layout.layout(this.getVisibleNodes(), this.view.grouping, this.nodePositions, this.maxRect, this.nodeWidth, this.nodeHeight);\n    // timer(this._render.bind(this), this.frameInterval);\n    this._render();\n  }\n  /**\r\n   * Change the View to another\r\n   * @param {View} View New View\r\n   */\n  changeView(View) {\n    this._rmViewListeners();\n    this.view = View.init(this.graph);\n    this.zoomFactor = 1;\n    this.offset = new Coordinate(0, 0);\n    this._transform();\n    this._resetVisible();\n    this._setViewListeners();\n  }\n  _setViewListeners() {\n    this.view.on('node-add', node => {\n      this._addNode(node);\n    }).on('node-update', node => {\n      this._updateNode(node);\n    }).on('node-remove', node => {\n      this._rmNode(node);\n    }).on('edge-add', edge => {\n      this._addEdge(edge);\n    }).on('edge-update').on('edge-remove').on('group-add').on('group-update').on('group-remove');\n  }\n  _rmViewListeners() {\n    this.view.off(null);\n  }\n  runLayout(Layout) {\n    this.nodePositions = Layout.layout(this.getVisibleNodes(), this.view.grouping, this.nodePositions, this.maxRect, this.nodeWidth, this.nodeHeight);\n    this._render();\n  }\n  zoomIn() {\n    this._scale(false);\n  }\n  zoomOut() {\n    this._scale(true);\n  }\n  /**\r\n   * Apply a transformation matrix to this renderer's svg-container. This is used to zoom in/out and move around in the system-map.\r\n   * @param {number} a Defaults to `this.zoomFactor`\r\n   * @param {number} b Defaults to 0\r\n   * @param {number} c Defaults to 0\r\n   * @param {number} d Defaults to `this.zoomFactor`\r\n   * @param {number} e Defaults to `this.offset.x`\r\n   * @param {number} f Defaults to `this.offset.y`\r\n   */\n  _transform() {\n    let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.zoomFactor;\n    let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.zoomFactor;\n    let e = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.offset.x;\n    let f = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.offset.y;\n    let transform = \"matrix(\".concat(a, \", \").concat(b, \", \").concat(c, \", \").concat(d, \", \").concat(e, \", \").concat(f, \")\");\n    svg.setAttr(this.svgContainer, 'transform', transform);\n  }\n  _translateRel(offset) {\n    let p = this.svgRoot.createSVGPoint();\n    p.x = offset.x;\n    p.y = offset.y;\n    let t = this.svgContainer.getCTM();\n    let origin = this.svgRoot.createSVGPoint().matrixTransform(t.inverse());\n    p = p.matrixTransform(t.inverse());\n    p.x = (p.x - origin.x) * t.a;\n    p.y = (p.y - origin.y) * t.d;\n    t.e += p.x;\n    t.f += p.y;\n    this._transform(t.a, 0, 0, t.d, t.e, t.f);\n  }\n  _scale(out) {\n    let scrollPoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (!scrollPoint) scrollPoint = {\n      x: this.maxSize.x / 2,\n      y: this.maxSize.y / 2\n    };\n    // TODO: Let user change this formula via settings, to allow for slower/faster scaling\n    let scaleFactor = Math.pow(1 + 0.4, out ? -0.2 : 0.2);\n    let p = this.svgRoot.createSVGPoint();\n    p.x = scrollPoint.x;\n    p.y = scrollPoint.y;\n    // Translate to SVG coordinates\n    p = p.matrixTransform(this.svgContainer.getCTM().inverse());\n    // Compute new scale matrix in current mouse position\n    let k = this.svgRoot.createSVGMatrix().translate(p.x, p.y).scale(scaleFactor).translate(-p.x, -p.y);\n    let t = this.svgContainer.getCTM().multiply(k);\n    // Apply new scale matrix & update properties\n    this.zoomFactor = t.a;\n    // this.maxRect.width = this.maxSize.x / t.a;\n    // this.maxRect.height = this.maxSize.y / t.a;\n    // console.log({ zoomFactor: this.zoomFactor, maxRect: this.maxRect });\n    this.offset.update(t.e, t.f);\n    this._transform(t.a, 0, 0, t.d, t.e, t.f);\n  }\n  /**\r\n   * Select a Node\r\n   * @param {...SystemNode|String|Number} node Node to select. Can be the node itself, its id or its name.\r\n   */\n  selectNodes() {\n    this.deselectNodes();\n    for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {\n      nodes[_key] = arguments[_key];\n    }\n    for (let node of nodes) {\n      var _this$drawnNodes$get;\n      if (!(node instanceof SystemNode)) node = this.graph.getNode(node);\n      (_this$drawnNodes$get = this.drawnNodes.get(node.id)) === null || _this$drawnNodes$get === void 0 ? void 0 : _this$drawnNodes$get.select();\n      this.selectedNodes.push(node);\n    }\n    this.just_selected = true;\n    this.emit('selected-nodes', this.selectedNodes);\n  }\n  deselectNodes() {\n    for (let node of this.selectedNodes) this.drawnNodes.get(node.id).deselect();\n    this.selectedNodes = [];\n    this.emit('deselected-nodes');\n  }\n  selectEdges() {\n    this.deselectEdges();\n    for (var _len2 = arguments.length, edges = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      edges[_key2] = arguments[_key2];\n    }\n    for (let edge of edges) {\n      var _this$drawnEdges$get;\n      if (!(edge instanceof Edge)) edge = this.graph.getEdge(edge);\n      (_this$drawnEdges$get = this.drawnEdges.get(edge.id)) === null || _this$drawnEdges$get === void 0 ? void 0 : _this$drawnEdges$get.select();\n      this.selectedEdges.push(edge);\n    }\n    this.just_selected = true;\n    this.emit('selected-edges', this.selectedEdges);\n  }\n  deselectEdges() {\n    for (let edge of this.selectedEdges) this.drawnEdges.get(edge.id).deselect();\n    this.selectedEdges = [];\n    this.emit('deselected-edges');\n  }\n  moveNode(nodeId, offset) {\n    let oldPos = this.nodePositions.get(nodeId);\n    let newPos = oldPos.copy().map((v, i) => v + (i ? offset.y : offset.x) / this.zoomFactor);\n    this.nodePositions.set(nodeId, newPos);\n    this._render();\n  }\n  moveCamera(x, y) {}\n  centerCamera(id) {}\n  _buildLine(nodeId, point) {\n    let line = this._buildEdgeUI();\n    line.nodeId = nodeId;\n    this.svgContainer.appendChild(line);\n    return this._moveLineTo(line, point);\n  }\n  _moveLineBy(line, offset) {\n    let point = new Coordinate(line.to.x + offset.x, line.to.y + offset.y);\n    return this._moveLineTo(line, point);\n  }\n  _moveLineTo(line, point) {\n    let nodePos = this.nodePositions.get(line.nodeId);\n    let from = nodePos.rect(this.nodeWidth, this.nodeHeight, 'c').intersect(nodePos, point);\n    if (from === null) return line;\n    line.setPath(from.x, from.y, point.x, point.y);\n    line.to = point;\n    return line;\n  }\n  _buildNodeUI(node) {\n    var _node$data;\n    let nodeContainer = svg.createEl('g');\n    let rect = svg.createEl('rect', {\n      width: this.nodeWidth,\n      height: this.nodeHeight,\n      fill: (node === null || node === void 0 ? void 0 : (_node$data = node.data) === null || _node$data === void 0 ? void 0 : _node$data.color) || '#00a2e8'\n    });\n    let name = svg.createEl('text', {\n      y: \"\".concat(2 * this.nodeHeight / 3, \"px\")\n    });\n    name.textContent = node.name;\n    nodeContainer.select = () => {\n      svg.setAttrs(rect, {\n        stroke: 'black',\n        'stroke-width': '2'\n      });\n      nodeContainer.selected = true;\n    };\n    nodeContainer.deselect = () => {\n      svg.setAttrs(rect, {\n        stroke: 'none'\n      });\n      nodeContainer.selected = false;\n    };\n    nodeContainer.selected = false;\n    nodeContainer.drawnLine = null;\n    nodeContainer.node = node;\n    nodeContainer.appendChild(rect);\n    nodeContainer.appendChild(name);\n    return nodeContainer;\n  }\n  _addNode(node) {\n    const nodeContainer = this._buildNodeUI(node);\n    nodeContainer.addEventListener('dblclick', e => this.selectNodes(node));\n    nodeContainer.drag = dragndrop(nodeContainer);\n    nodeContainer.drag.onStart(() => {\n      this.userInteraction = true;\n    }).onDrag((e, offset) => {\n      this.userInteraction = true;\n      if (!nodeContainer.selected) {\n        this.moveNode(node.id, offset);\n        return;\n      }\n      if (!nodeContainer.drawnLine) nodeContainer.drawnLine = this._buildLine(node.id, e);else {\n        this._moveLineTo(nodeContainer.drawnLine, e);\n      }\n    }).onStop(() => {\n      const insideRectRadius = 10;\n      if (nodeContainer.drawnLine) {\n        let p = nodeContainer.drawnLine.to;\n        if (!(p instanceof Coordinate)) p = new Coordinate(p.x, p.y);\n        for (let id of this.nodePositions.keys()) {\n          if (id !== node.id) {\n            let nodePos = this.nodePositions.get(id);\n            let t = nodePos.rect(this.nodeWidth, this.nodeHeight, 'c').isPointInside(p, insideRectRadius);\n            if (t) {\n              let source = this.graph.getSystem(node.id);\n              let target = this.graph.getSystem(id);\n              let edge = new Edge(source, target);\n              this.graph.addEdge(edge);\n              break;\n            }\n          }\n        }\n        nodeContainer.drawnLine.remove();\n        nodeContainer.drawnLine = null;\n      }\n      this.userInteraction = false;\n    });\n    const coord = this.Layout.layout([node], this.view.grouping, this.nodePositions, this.maxRect, this.nodeWidth, this.nodeHeight).get(node.id);\n    this.nodePositions.set(node.id, coord);\n    this.drawnNodes.set(node.id, nodeContainer);\n    this.svgContainer.insertAdjacentElement('beforeend', nodeContainer);\n    this._render();\n  }\n  _rmNode(node) {\n    var _this$drawnNodes$get2;\n    (_this$drawnNodes$get2 = this.drawnNodes.get(node.id)) === null || _this$drawnNodes$get2 === void 0 ? void 0 : _this$drawnNodes$get2.remove();\n    this.drawnNodes.delete(node.id);\n    this.nodePositions.delete(node.id);\n    this._render();\n  }\n  _updateNode(node) {\n    var _this$drawnNodes$get3;\n    (_this$drawnNodes$get3 = this.drawnNodes.get(node.id)) === null || _this$drawnNodes$get3 === void 0 ? void 0 : _this$drawnNodes$get3.remove();\n    this._addNode(node);\n  }\n  _renderNodes() {\n    this.drawnNodes.forEach((nodeContainer, id) => {\n      let coord = this.nodePositions.get(id);\n      svg.setAttr(nodeContainer, 'transform', \"translate(\".concat(coord.x - this.nodeWidth / 2, \", \").concat(coord.y - this.nodeHeight / 2, \")\"));\n    });\n  }\n  _buildEdgeUI() {\n    let container = svg.createEl('g');\n    let arrow = svg.createEl('path', {\n      stroke: 'gray',\n      'stroke-width': '2',\n      'marker-end': 'url(#Arrow)'\n    });\n    container.selected = false;\n    container.select = () => {\n      svg.setAttrs(arrow, {\n        stroke: 'blue',\n        'stroke-width': '3'\n      });\n      container.selected = true;\n    };\n    container.deselect = () => {\n      svg.setAttrs(arrow, {\n        stroke: 'gray',\n        'stroke-width': '2'\n      });\n      container.selected = false;\n    };\n    container.setPath = (x1, y1, x2, y2) => {\n      svg.setAttr(arrow, 'd', \"M \".concat(x1, \" \").concat(y1, \" L \").concat(x2, \" \").concat(y2));\n    };\n    container.appendChild(arrow);\n    return container;\n  }\n  _addEdge(edge) {\n    let edgeUI = this._buildEdgeUI();\n    edgeUI.edge = edge;\n    edgeUI.addEventListener('dblclick', e => {\n      this.selectEdges(edge);\n    });\n    this.svgContainer.insertAdjacentElement('afterbegin', edgeUI);\n    this.drawnEdges.set(edge.id, edgeUI);\n    this._render();\n  }\n  _renderEdges() {\n    this.drawnEdges.forEach((edgeUI, id) => {\n      /** @type {Edge} */\n      let edge = edgeUI.edge;\n      let sourceCoord = this.nodePositions.get(edge.source.id);\n      let targetCoord = this.nodePositions.get(edge.target.id);\n      let from = sourceCoord.rect(this.nodeWidth, this.nodeHeight, 'c').intersect(sourceCoord, targetCoord);\n      let to = targetCoord.rect(this.nodeWidth, this.nodeHeight, 'c').intersect(targetCoord, sourceCoord);\n      edgeUI.setPath(from.x, from.y, to.x, to.y);\n    });\n  }\n  // TODO: render vertical edges in potentially different ways\n  _render() {\n    this._renderNodes();\n    this._renderEdges();\n    return this.userInteraction;\n  }\n  _onResize() {\n    // TODO: Maybe add: this.updateCenter();\n    this.maxSize = this._setMaxSizeHelper(null);\n    this.maxRect = this.maxSize.rect(0, 0, 'br');\n    this._render();\n  }\n}\nmodule.exports = Renderer;\n\n//# sourceURL=webpack://vivagraphjs/./built/renderer.js?");

/***/ }),

/***/ "./built/ui.js":
/*!*********************!*\
  !*** ./built/ui.js ***!
  \*********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nwindow.onload(e => {\n  const SystemLandscape = __webpack_require__(/*! ./Graphs/SystemLandscape.js */ \"./built/Graphs/SystemLandscape.js\");\n  const Renderer = __webpack_require__(/*! ./renderer.js */ \"./built/renderer.js\");\n  const View = __webpack_require__(/*! ./Views/View.js */ \"./built/Views/View.js\");\n  const SingleLayerView = __webpack_require__(/*! ./Views/SingleLayerView.js */ \"./built/Views/SingleLayerView.js\");\n  const SingleLayerTreeMapView = __webpack_require__(/*! ./Views/SingleLayerTreeMapView */ \"./built/Views/SingleLayerTreeMapView.js\");\n  const graphContainer = document.getElementById('graph-root');\n  const newNodeBtn = document.getElementById('btn-new');\n  const viewSelect = document.getElementById('select-view');\n  const sideBar = document.getElementById('sidebar');\n  let currentViewValue = viewSelect.value;\n  const sl = new SystemLandscape();\n  sl.addSystem('Server 1', {\n    type: 'hardware'\n  });\n  sl.addSystem('Server 2', {\n    type: 'hardware'\n  });\n  sl.addSystem('VM 1', {\n    type: 'vm'\n  }, 'Server 1');\n  sl.addSystem('VM 2', {\n    type: 'vm'\n  }, 'Server 1');\n  sl.addSystem('VM 3', {\n    type: 'vm'\n  }, 'Server 1');\n  sl.addSystem('VM 4', {\n    type: 'vm'\n  }, 'Server 2');\n  sl.addSystem('VM 5', {\n    type: 'vm'\n  }, 'Server 2');\n  sl.addSystem('DB 1', {\n    type: 'db'\n  }, 'VM 1');\n  sl.addSystem('DB 2', {\n    type: 'db'\n  }, 'VM 1');\n  sl.addSystem('Software 1', {\n    type: 'software'\n  }, 'VM 2');\n  sl.addSystem('Software 2', {\n    type: 'software'\n  }, 'VM 2');\n  sl.addSystem('Software 3', {\n    type: 'software'\n  }, 'VM 2');\n  sl.addSystem('Software 4', {\n    type: 'software'\n  }, 'VM 3');\n  sl.addSystem('Software 5', {\n    type: 'software'\n  }, 'VM 4');\n  sl.addSystem('Software 6', {\n    type: 'software'\n  }, 'VM 4');\n  sl.addSystem('Software 7', {\n    type: 'software'\n  }, 'VM 4');\n  sl.addSystem('DB 3', {\n    type: 'db'\n  }, 'VM 5');\n  sl.addSystem('Software', {\n    type: 'software'\n  }, 'VM 5');\n  sl.linkSystems('DB 1', 'Software 1');\n  newNodeBtn.addEventListener('click', _ => addNewNode());\n  viewSelect.addEventListener('click', _ => updateViewOptions());\n  viewSelect.addEventListener('change', _ => changeView());\n  function getDefaultNodeData() {\n    var _node$parent, _node$data, _node$data2, _node$data3, _node$data4;\n    let node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    return {\n      name: (node === null || node === void 0 ? void 0 : node.name) || '',\n      parent: (node === null || node === void 0 ? void 0 : (_node$parent = node.parent) === null || _node$parent === void 0 ? void 0 : _node$parent.name) || null,\n      wikiLink: (node === null || node === void 0 ? void 0 : (_node$data = node.data) === null || _node$data === void 0 ? void 0 : _node$data.wikiLink) || '',\n      description: (node === null || node === void 0 ? void 0 : (_node$data2 = node.data) === null || _node$data2 === void 0 ? void 0 : _node$data2.description) || '',\n      type: (node === null || node === void 0 ? void 0 : (_node$data3 = node.data) === null || _node$data3 === void 0 ? void 0 : _node$data3.type) || '',\n      color: (node === null || node === void 0 ? void 0 : (_node$data4 = node.data) === null || _node$data4 === void 0 ? void 0 : _node$data4.color) || ''\n    };\n  }\n  function getInputField() {\n    let label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Label';\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let placeholder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Placeholder';\n    let onChange = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => {};\n    const container = document.createElement('div');\n    container.className = 'input-container';\n    const labelEl = document.createElement('label');\n    labelEl.textContent = label;\n    labelEl.className = 'input-label';\n    const input = document.createElement('input');\n    input.type = 'text';\n    if (value) input.value = value;else input.placeholder = placeholder;\n    input.className = 'input-field';\n    input.addEventListener('change', e => onChange(input.value));\n    container.appendChild(labelEl);\n    container.appendChild(input);\n    return container;\n  }\n  function getSelectField(label, values, isSelected, onChange) {\n    const container = document.createElement('div');\n    container.className = 'select-container';\n    const labelEl = document.createElement('label');\n    labelEl.textContent = label;\n    labelEl.className = 'select-label';\n    const select = document.createElement('select');\n    select.className = 'select-field';\n    values.forEach(v => {\n      let text, value;\n      if (Array.isArray(v)) {\n        text = v[0];\n        value = v[1];\n      } else {\n        text = v;\n        value = v;\n      }\n      const option = document.createElement('option');\n      option.value = value;\n      option.textContent = text;\n      if (typeof isSelected === 'function' && isSelected(option)) option.selected = true;\n      select.appendChild(option);\n    });\n    select.addEventListener('change', e => onChange(select.value));\n    container.appendChild(labelEl);\n    container.appendChild(select);\n    return container;\n  }\n  function getDataListField(label) {\n    let val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let values = arguments.length > 2 ? arguments[2] : undefined;\n    let onChange = arguments.length > 3 ? arguments[3] : undefined;\n    let idCounter = (getDataListField === null || getDataListField === void 0 ? void 0 : getDataListField.idCounter) || 0;\n    const dataListId = \"\".concat(idCounter, \"-data-list\");\n    idCounter++;\n    getDataListField.idCounter = idCounter;\n    const container = document.createElement('div');\n    container.className = 'data-list-container';\n    const labelEl = document.createElement('label');\n    labelEl.textContent = label;\n    labelEl.className = 'data-list-label';\n    const inputEl = document.createElement('input');\n    inputEl.type = 'text';\n    if (val) inputEl.value = val;\n    inputEl.setAttribute('list', dataListId);\n    inputEl.className = 'data-list-input';\n    const dataList = document.createElement('datalist');\n    dataList.id = dataListId;\n    values.forEach(v => {\n      let text, value;\n      if (Array.isArray(v)) {\n        text = v[0];\n        value = v[1];\n      } else {\n        text = v;\n        value = v;\n      }\n      const option = document.createElement('option');\n      option.value = text;\n      option.textContent = text;\n      option.setAttribute('real-value', value);\n      dataList.appendChild(option);\n    });\n    inputEl.addEventListener('change', e => {\n      let option = dataList.querySelector(\"option[value=\\\"\".concat(inputEl.value, \"\\\"]\"));\n      if (option) {\n        onChange(option.getAttribute('real-value'));\n      } else {\n        onChange(null);\n      }\n    });\n    container.appendChild(labelEl);\n    container.appendChild(inputEl);\n    container.appendChild(dataList);\n    return container;\n  }\n  function getNodeEditorHTML() {\n    let submit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const data = getDefaultNodeData(node);\n    const nodeEditor = document.createElement('div');\n    nodeEditor.className = 'node-editor';\n    const nameField = getInputField('Name', data.name || null, 'Name des Systems', name => {\n      data.name = name;\n    });\n    nameField.classList.add('sub-container');\n    nodeEditor.appendChild(nameField);\n    let parentValues = sl.getSystems(0, Infinity, true).map(n => [n.name, n.name]);\n    const parentField = getDataListField('\"Vater\"-System', (data === null || data === void 0 ? void 0 : data.parent) || null, parentValues, parent => {\n      data.parent = parent;\n    });\n    parentField.classList.add('sub-container');\n    nodeEditor.appendChild(parentField);\n    const wikiLinkField = getInputField('Wiki Link', (data === null || data === void 0 ? void 0 : data.wikiLink) || null, 'Link zur Wiki-Seite des Systems', wikiLink => {\n      data.wikiLink = wikiLink;\n    });\n    wikiLinkField.classList.add('sub-container');\n    nodeEditor.appendChild(wikiLinkField);\n    const descriptionField = getInputField('Beschreibung', (data === null || data === void 0 ? void 0 : data.description) || null, 'Beschreibung des Systems', description => {\n      data.description = description;\n    });\n    descriptionField.classList.add('sub-container');\n    nodeEditor.appendChild(descriptionField);\n    const typeField = getSelectField('Typ', [['Typ des Systems', ''], ['Hardware', 'hardware'], ['Virtuelle Machine', 'vm'], ['Software System', 'software'], ['Datenbank', 'db']], opt => opt.value === data.type, type => {\n      data.type = type;\n    });\n    typeField.classList.add('sub-container');\n    nodeEditor.appendChild(typeField);\n    const colorField = getSelectField('Farbe', [['Farbe des Systems', ''], ['Rot', 'red'], ['Gelb', 'yellow'], ['Grün', 'green'], ['Blau', 'blue'], ['Violett', 'violet'], ['Weiß', 'white'], ['Schwarz', 'black']], opt => opt.value === data.color, color => {\n      data.color = color;\n    });\n    colorField.classList.add('sub-container');\n    nodeEditor.appendChild(colorField);\n    const btnContainer = document.createElement('div');\n    btnContainer.classList.add('sub-container', 'btn-container');\n    const cancelBtn = document.createElement('button');\n    cancelBtn.textContent = 'Abbrechen';\n    cancelBtn.className = 'btn-cancel';\n    cancelBtn.addEventListener('click', e => clearSideBar());\n    const submitBtn = document.createElement('button');\n    submitBtn.textContent = 'Bestätigen';\n    submitBtn.className = 'btn-submit';\n    submitBtn.addEventListener('click', e => submit(data, node));\n    btnContainer.appendChild(cancelBtn);\n    btnContainer.appendChild(submitBtn);\n    nodeEditor.appendChild(btnContainer);\n    return nodeEditor;\n  }\n  function addNewNode() {\n    clearSideBar();\n    sideBar.appendChild(getNodeEditorHTML(submitNewNode, null));\n  }\n  function updateNodeHTML(node) {\n    clearSideBar();\n    sideBar.appendChild(getNodeEditorHTML(updateNode, node));\n  }\n  function clearSideBar(data) {\n    sideBar.childNodes.forEach(c => c.remove());\n  }\n  function submitNewNode(data, node) {\n    let name = data.name || null;\n    delete data.name;\n    let parent = data.parent || null;\n    delete data.parent;\n    sl.addSystem(name, data, parent);\n    clearSideBar();\n  }\n  function updateNode(data, node) {\n    sl.updateSystem(node.id, data);\n    clearSideBar();\n  }\n  const views = {};\n  function addOption(selectEl, text, value, isSelected) {\n    const opt = document.createElement('option');\n    opt.text = text;\n    opt.value = value;\n    if (isSelected(opt)) opt.selected = true;\n    selectEl.appendChild(opt);\n    return opt;\n  }\n  function updateViewOptions() {\n    let selectedOptIds = Array.from(viewSelect.selectedOptions).map(o => o.value);\n    const isSelected = opt => selectedOptIds.includes(opt.value);\n    viewSelect.innerHTML = '';\n    const maxHeight = sl.getMaxHeight();\n    let i = 0;\n    do {\n      let opt = addOption(viewSelect, \"Layer \".concat(i), \"single-layer-\".concat(i), isSelected);\n      views[opt.value] = new SingleLayerView(i);\n      i++;\n    } while (i <= maxHeight);\n    i = 0;\n    do {\n      let opt = addOption(viewSelect, \"TreeMap Layer \".concat(i), \"treemap-layer-\".concat(i), isSelected);\n      views[opt.value] = new SingleLayerTreeMapView(i);\n      i++;\n    } while (i <= maxHeight);\n    let opt = addOption(viewSelect, \"Total View\", \"total-view\", isSelected);\n    views[opt.value] = new View();\n  }\n  updateViewOptions();\n  const renderer = new Renderer(sl, {\n    view: views[viewSelect.value],\n    container: graphContainer\n  });\n  function changeView() {\n    if (currentViewValue === viewSelect.value) return;\n    currentViewValue = viewSelect.value;\n    renderer.changeView(views[viewSelect.value]);\n  }\n  renderer.run();\n  renderer.on('selected-nodes', nodes => {\n    let n = nodes[0];\n    updateNodeHTML(n);\n  });\n  renderer.on('deselected-nodes', () => {\n    clearSideBar();\n  });\n  renderer.on('selected-edges', edges => {});\n});\n\n//# sourceURL=webpack://vivagraphjs/./built/ui.js?");

/***/ }),

/***/ "./node_modules/gintersect/index.js":
/*!******************************************!*\
  !*** ./node_modules/gintersect/index.js ***!
  \******************************************/
/***/ (function(module) {

eval("module.exports = intersect;\n\n/**\n * Original authors: Mukesh Prasad, Appeared in Graphics Gem II book\n * http://www.opensource.apple.com/source/graphviz/graphviz-498/graphviz/dynagraph/common/xlines.c\n * and adopted to javascript version by Andrei Kashcha.\n *\n * This function computes whether two line segments,\n * respectively joining the input points (x1,y1) -- (x2,y2)\n * and the input points (x3,y3) -- (x4,y4) intersect.\n * If the lines intersect, the output variables x, y are\n * set to coordinates of the point of intersection.\n *\n * @param {Number} x1 First line segment coordinates\n * @param {Number} y1 First line segment coordinates\n * @param {Number} x2 First line segment coordinates\n * @param {Number} x2 First line segment coordinates\n *\n * @param {Number} x3 Second line segment coordinates\n * @param {Number} y3 Second line segment coordinates\n * @param {Number} x4 Second line segment coordinates\n * @param {Number} x4 Second line segment coordinates\n *\n * @return {Object} x, y coordinates of intersection point or falsy value if no\n * intersection found..\n */\nfunction intersect(\n  x1, y1, x2, y2, // first line segment\n  x3, y3, x4, y4  // second line segment\n) {\n\n  var a1, a2, b1, b2, c1, c2, /* Coefficients of line eqns. */\n    r1, r2, r3, r4, /* 'Sign' values */\n    denom, offset, num, /* Intermediate values */\n    result = {\n      x: 0,\n      y: 0\n    };\n\n  /* Compute a1, b1, c1, where line joining points 1 and 2\n   * is \"a1 x  +  b1 y  +  c1  =  0\".\n   */\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2;\n\n  /* Compute r3 and r4.\n   */\n  r3 = a1 * x3 + b1 * y3 + c1;\n  r4 = a1 * x4 + b1 * y4 + c1;\n\n  /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\n   * same side of line 1, the line segments do not intersect.\n   */\n\n  if (r3 !== 0 && r4 !== 0 && ((r3 >= 0) === (r4 >= 4))) {\n    return null; //no intersection.\n  }\n\n  /* Compute a2, b2, c2 */\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4;\n\n  /* Compute r1 and r2 */\n\n  r1 = a2 * x1 + b2 * y1 + c2;\n  r2 = a2 * x2 + b2 * y2 + c2;\n\n  /* Check signs of r1 and r2.  If both point 1 and point 2 lie\n   * on same side of second line segment, the line segments do\n   * not intersect.\n   */\n  if (r1 !== 0 && r2 !== 0 && ((r1 >= 0) === (r2 >= 0))) {\n    return null; // no intersection;\n  }\n  /* Line segments intersect: compute intersection point.\n   */\n\n  denom = a1 * b2 - a2 * b1;\n  if (denom === 0) {\n    return null; // Actually collinear..\n  }\n\n  offset = denom < 0 ? -denom / 2 : denom / 2;\n  offset = 0.0;\n\n  /* The denom/2 is to get rounding instead of truncating.  It\n   * is added or subtracted to the numerator, depending upon the\n   * sign of the numerator.\n   */\n  num = b1 * c2 - b2 * c1;\n  result.x = (num < 0 ? num - offset : num + offset) / denom;\n\n  num = a2 * c1 - a1 * c2;\n  result.y = (num < 0 ? num - offset : num + offset) / denom;\n\n  return result;\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/gintersect/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./built/ui.js");
/******/ 	
/******/ })()
;