/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Geom/Coordinate.js":
/*!********************************!*\
  !*** ./src/Geom/Coordinate.js ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const randint = (__webpack_require__(/*! ../Utils/random */ \"./src/Utils/random.js\").randint);\n\nclass Coordinate {\n  /**\n   * Coordinates store x and y values.\n   * @param {number} x x value. Defaults to 0.\n   * @param {number} y y value. Defaults t 0.\n   */\n  constructor(x, y) {\n    this.point = [x, y];\n  }\n\n  get x() {\n    return this.point[0];\n  }\n\n  set x(value) {\n    this.point[0] = value;\n  }\n\n  get y() {\n    return this.point[1];\n  }\n\n  set y(value) {\n    this.point[1] = value;\n  }\n  /**\n   * This is a pure convenience function.\n   * @param {function} callback Callback function, that receives the current x/y value and an index (0 or 1) indicating whether it's x or y. It should return a new x/y value. It is called once for x and once for y.\n   * @returns {Coordinate} Returns this to allow for chaining\n   */\n\n\n  map(callback) {\n    this.point = this.point.map((v, i) => callback(v, i));\n    return this;\n  }\n  /**\n   * Update both values at once. This is a pure convenience function.\n   * @param {number} x new x value\n   * @param {nmber} y new y value. Defaults to the new x value.\n   * @returns {Coordinate} Returns this to allow for chaining\n   */\n\n\n  update(x) {\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  /**\n   * Instance a Rectangle from this Coordinate.\n   * @param {number} width Width of the area to be covered by the rectangle.\n   * @param {number} height Height of the area to be covered by the rectangle.\n   * @param {boolean} center Whether to center the rectangle on the current coordinate; otherwise this coordinate is the rectangle's top-left corner. Defaults to false.\n   * @returns {Rectangle}\n   */\n\n\n  rect(width, height) {\n    let center = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    const Rectangle = __webpack_require__(/*! ./Rectangle */ \"./src/Geom/Rectangle.js\");\n\n    if (center) {\n      return new Rectangle(this.x - width / 2, this.y - height / 2, width, height);\n    } else {\n      return new Rectangle(this.x, this.y, width, height);\n    }\n  }\n  /**\n   * Copy the Coordinate to a new instance.\n   * @returns {Coordinate}\n   */\n\n\n  copy() {\n    return new Coordinate(this.point[0], this.point[1]);\n  }\n\n  static rand(maxX, maxY, exclude) {\n    const xVal = randint(maxX);\n    const yVal = randint(maxY);\n\n    if (exclude) {\n      while (exclude.has(xVal) && exclude.has(yVal)) {\n        xVal = randint(0, maxX);\n        yVal = randint(0, maxY);\n      }\n    }\n\n    return new Coordinate(xVal, yVal);\n  }\n\n}\n\nmodule.exports = Coordinate;\n\n//# sourceURL=webpack://vivagraphjs/./src/Geom/Coordinate.js?");

/***/ }),

/***/ "./src/Geom/Rectangle.js":
/*!*******************************!*\
  !*** ./src/Geom/Rectangle.js ***!
  \*******************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const Coordinate = __webpack_require__(/*! ./Coordinate */ \"./src/Geom/Coordinate.js\");\n\nconst intersect = __webpack_require__(/*! gintersect */ \"./node_modules/gintersect/index.js\");\n\nclass Rectangle {\n  constructor(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  get left() {\n    return this.x;\n  }\n\n  get right() {\n    return this.x + this.width;\n  }\n\n  get top() {\n    return this.y;\n  }\n\n  get bottom() {\n    return this.y + this.height;\n  }\n\n  get center() {\n    return new Coordinate(this.x + this.width / 2, this.y + this.height / 2);\n  }\n\n  get centerX() {\n    return this.x + this.width / 2;\n  }\n\n  get centerY() {\n    return this.y + this.height / 2;\n  }\n\n  get topLeft() {\n    return new Coordinate(this.x, this.y);\n  }\n\n  get topRight() {\n    return new Coordinate(this.x + this.width, this.y);\n  }\n\n  get bottomLeft() {\n    return new Coordinate(this.x, this.y + this.height);\n  }\n\n  get bottomRight() {\n    return new Coordinate(this.x + this.width, this.y + this.height);\n  }\n\n  get topCenter() {\n    return new Coordinate(this.x + this.width / 2, this.y);\n  }\n\n  get bottomCenter() {\n    return new Coordinate(this.x + this.width / 2, this.y + this.height);\n  }\n\n  get leftCenter() {\n    return new Coordinate(this.x, this.y + this.height / 2);\n  }\n\n  get rightCenter() {\n    return new Coordinate(this.x + this.width, this.y + this.height / 2);\n  }\n\n  intersect(p1, p2) {\n    return intersect(this.left, this.top, this.left, this.bottom, p1.x, p1.y, p2.x, p2.y) || intersect(this.left, this.bottom, this.right, this.bottom, p1.x, p1.y, p2.x, p2.y) || intersect(this.right, this.bottom, this.right, this.top, p1.x, p1.y, p2.x, p2.y) || intersect(this.right, this.top, this.left, this.top, p1.x, p1.y, p2.x, p2.y);\n  }\n\n}\n\nmodule.exports = Rectangle;\n\n//# sourceURL=webpack://vivagraphjs/./src/Geom/Rectangle.js?");

/***/ }),

/***/ "./src/Graphs/Edge.js":
/*!****************************!*\
  !*** ./src/Graphs/Edge.js ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const EventManager = __webpack_require__(/*! ../Utils/EventManager.js */ \"./src/Utils/EventManager.js\");\n\nconst nextID = __webpack_require__(/*! ../Utils/id.js */ \"./src/Utils/id.js\");\n\nconst SystemNode = __webpack_require__(/*! ./SystemNode.js */ \"./src/Graphs/SystemNode.js\");\n\nclass Edge extends EventManager {\n  /**\n   * Create a new Edge to connect to Nodes. This class offers certain events to listen to changes:\n   \n   - `sourceChanged`: When the source of this edge changes. Args: `(newSourceID, edge)`\n   - `targetChanged`: When the target of this edge changes. Args: `(newTargetID, edge)`\n   - `dataChanged`: When the data of this edge changes. Args: `(updatedData, edge)`\n   - `update`: When any of the above events occurs. Args: `(...args of the event - this edge is always the second argument)`\n   * @param {SystemNode} source ID of the source node\n   * @param {SystemNode} target ID of the target node\n   * @param {any} data Data associated with this edge. Defaults to an empty object.\n   */\n  constructor(source, target) {\n    var _this;\n\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    _this = this;\n    this.id = nextID();\n    this.source = source;\n    this.target = target;\n    this.data = data || {};\n    this.on('sourceChanged', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _this.emit('update', ...args);\n    });\n    this.on('targetChanged', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return _this.emit('update', ...args);\n    });\n    this.on('dataChanged', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return _this.emit('update', ...args);\n    });\n  }\n\n  get fromId() {\n    return this.source.id;\n  }\n\n  get toId() {\n    return this.target.id;\n  }\n\n  setSource(source) {\n    this.source = source;\n    this.emit('sourceChanged', source, this);\n  }\n\n  setTarget(target) {\n    this.target = target;\n    this.emit('targetChanged', target, this);\n  }\n\n  setData(data) {\n    this.data = data;\n    this.emit('dataChanged', this.data, this);\n  }\n\n  updateData(data) {\n    this.data = { ...this.data,\n      ...data\n    };\n    this.emit('dataChanged', this.data, this);\n  }\n\n}\n\nmodule.exports = Edge;\n\n//# sourceURL=webpack://vivagraphjs/./src/Graphs/Edge.js?");

/***/ }),

/***/ "./src/Graphs/NodeGroup.js":
/*!*********************************!*\
  !*** ./src/Graphs/NodeGroup.js ***!
  \*********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const SystemNode = __webpack_require__(/*! ./SystemNode */ \"./src/Graphs/SystemNode.js\");\n\nconst newID = __webpack_require__(/*! ../Utils/id */ \"./src/Utils/id.js\");\n/**\n * @typedef {Object} GroupData\n */\n\n/** @type {GroupData} */\n\n\nconst defaultData = {};\n\nclass NodeGroup {\n  /**\n   * Create a Group of Nodes. A group can contain further groups as well as direct children.\n   * @param {String} name Name of the group\n   * @param {GroupData} data Data associated with the group\n   * @param {SystemNode[]} nodes Direct Children-Nodes of this group\n   */\n  constructor() {\n    let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : newID();\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let nodes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    /** @type {number} */\n    this.id = id;\n    /** @type {String} */\n\n    this.name = name !== null && name !== void 0 ? name : '';\n    /** @type {GroupData} */\n\n    this.data = { ...defaultData,\n      ...data\n    };\n    /** @type {SystemNode[]} */\n\n    this.nodes = nodes !== null && nodes !== void 0 ? nodes : [];\n    /** @type {NodeGroup[]} */\n\n    this.groups = [];\n    /** @type {?NodeGroup} */\n\n    this.parentGroup = null;\n  }\n\n  findSubGroup(cb) {\n    let found = this.groups.find(cb);\n    if (found) return found;\n\n    for (let group of this.groups) {\n      found = group.findSubGroup(cb);\n      if (found) return found;\n    }\n\n    return null;\n  }\n\n  addNodes() {\n    this.nodes.push(...arguments);\n    return this;\n  }\n\n  addGroups() {\n    for (var _len = arguments.length, groups = new Array(_len), _key = 0; _key < _len; _key++) {\n      groups[_key] = arguments[_key];\n    }\n\n    this.groups.push(...groups);\n    groups.forEach(group => group.parentGroup = this);\n    return this;\n  }\n\n  removeNode(node) {\n    let idx = this.nodes.indexOf(node);\n\n    if (idx !== -1) {\n      return this.nodes.splice(idx, 1)[0];\n    }\n\n    for (let group of this.groups) {\n      let removed = group.removeNode(node);\n      if (removed) return removed;\n    }\n\n    return null;\n  }\n\n  removeSubGroup(id) {\n    let idx = this.groups.findIndex(group => group.id === id);\n\n    if (idx !== -1) {\n      return this.groups.splice(idx, 1)[0];\n    }\n\n    for (let group of this.groups) {\n      let removed = group.removeSubGroup(id);\n      if (removed) return removed;\n    }\n\n    return null;\n  }\n\n}\n\nmodule.exports = NodeGroup;\n\n//# sourceURL=webpack://vivagraphjs/./src/Graphs/NodeGroup.js?");

/***/ }),

/***/ "./src/Graphs/SystemLandscape.js":
/*!***************************************!*\
  !*** ./src/Graphs/SystemLandscape.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const newID = __webpack_require__(/*! ../Utils/id */ \"./src/Utils/id.js\");\n\nconst Trie = __webpack_require__(/*! ../Utils/Trie */ \"./src/Utils/Trie.js\");\n\nconst EventManager = __webpack_require__(/*! ../Utils/EventManager */ \"./src/Utils/EventManager.js\");\n\nconst XSet = __webpack_require__(/*! ../Utils/ExtendedSet */ \"./src/Utils/ExtendedSet.js\");\n\nconst SystemTree = __webpack_require__(/*! ./SystemTree */ \"./src/Graphs/SystemTree.js\");\n\nconst SystemNode = __webpack_require__(/*! ./SystemNode */ \"./src/Graphs/SystemNode.js\");\n\nconst Edge = __webpack_require__(/*! ./Edge */ \"./src/Graphs/Edge.js\"); // Expected API:\n// \t\t- addNode(node: NodeId, data?: NodeData) => Node<NodeData>\n// \t\t- addLink(from: NodeId, to: NodeId, data?: LinkData) => Link<LinkData>\n// - removeNode(node: NodeId) => boolean\n// - removeLink(link: LinkId) => boolean\n// \t\t- getNode(node: NodeId) => Node<NodeData> | undefined\n// \t\t- getLink(fromNodeId: NodeId, toNodeId: NodeId) => Link<LinkData> | undefined // TODO: null instead of undefined returned\n// \t\t- hasLink(fromNodeId: NodeId, toNodeId: NodeId) => Link<LinkData> | undefined // TODO: Returns Boolean\n// \t\t- getNodesCount() => number\n// \t\t- getNodeCount() = getNodesCount()\n// \t\t- getLinksCount() => number\n// \t\t- getLinkCount() = getLinksCount()\n// \t\t- getLinks(nodeId: NodeId) => Set<Link<LinkData>> | null // TODO: Different name\n// - forEachNode(callback: (node: Node<NodeData>) => void) => void\n// - forEachLink(callback: (link: Link<LinkData>) => void) => void\n// - forEachLinkedNode(nodeId: NodeId, callback: (node: Node<NodeData>, link: Link<LinkData>) => void) => void, oriented: boolean) => void\n// - beginUpdate() => void\n// - endUpdate() => void\n// - clear() => void\n// export default function createGraph<NodeData = any, LinkData = any>(options?: { multigraph: boolean }): Graph<NodeData, LinkData> & EventedType\n// TODO: Add Events for Renderer to listen to\n\n\nclass SystemLandscape extends EventManager {\n  constructor() {\n    super();\n    /** @type {number} */\n\n    this.id = newID();\n    /** @type {SystemTree[]} */\n\n    this.systemTrees = [];\n    /** @type {Trie} */\n\n    this.systemsByName = new Trie();\n    /** @type {Map<Number, SystemNode>} */\n\n    this.systemsByID = new Map();\n    /** @type {Edge[]} */\n\n    this.edges = [];\n  } // Checks\n\n\n  hasSystem(id) {\n    return this.systemsByID.has(id);\n  }\n\n  hasEdgeId(id) {\n    return this.getEdgeId(id) !== null;\n  }\n\n  hasEdge() {\n    let from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return this.getEdge(from, to) !== null;\n  }\n\n  isVerticalEdge(edge) {\n    var _edge$source, _edge$target;\n\n    // Edges are vertical iff they connect a parent-node with a child-node\n    return ((_edge$source = edge.source) === null || _edge$source === void 0 ? void 0 : _edge$source.parent) === edge.target || ((_edge$target = edge.target) === null || _edge$target === void 0 ? void 0 : _edge$target.parent) === edge.source;\n  }\n\n  sameNode(a, b) {\n    if (!(a instanceof SystemNode)) a = this.getSystem(a);\n    if (!(b instanceof SystemNode)) b = this.getSystem(b);\n    return a.id === b.id;\n  } // Getting Data\n\n  /**\r\n   * Get the system uniquely identified by its ID or name.\r\n   * @param {Number|String|SystemNode} id The unique ID or name of the system. If the system itself is inputted, it is simply returned.\r\n   * @returns {?SystemNode}\r\n   */\n\n\n  getSystem(id) {\n    if (id instanceof SystemNode) return id;\n    if (typeof id === 'string') return this.getSystemByName(id);\n    if (this.hasSystem(id)) return this.systemsByID.get(id);else return null;\n  }\n\n  getNode(id) {\n    return this.getSystem(id);\n  }\n\n  getSystemTree(id) {\n    return this.systemTrees.find(tree => tree.id === id);\n  }\n\n  getSystems() {\n    let startLayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let endLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startLayer;\n    let flatten = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let res = this.systemTrees.map(tree => tree.getSystems(startLayer, endLayer));\n    if (flatten) return res.flat(1);else return res;\n  }\n\n  getSystemsByName(name) {\n    return this.systemsByName.findPrefix(name);\n  }\n\n  getSystemByName(name) {\n    return this.systemsByName.find(name);\n  }\n\n  getEdgesOfSystem(systemID) {\n    let horizontal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let vertical = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let includeLinksOfChildren = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let links = new Set();\n    if (!this.hasSystem(systemID)) return links;\n\n    if (horizontal) {\n      this.edges.forEach(edge => {\n        if (edge.source === systemID || edge.target === systemID) links.add(edge.id);\n      });\n    }\n\n    if (vertical) {\n      this.getSystem(systemID).getVerticalLinks().forEach(edge => links.add(edge.id));\n    }\n\n    if (includeLinksOfChildren) {\n      this.getSystem(systemID).getChildren().forEach(child => {\n        this.getEdgesOfSystem(child.id, horizontal, vertical, false).forEach(edge => links.add(edge.id));\n      });\n    }\n\n    return links;\n  }\n\n  getEdgeId(id) {\n    var _this$edges$find;\n\n    if (id instanceof Edge) return id;\n    return (_this$edges$find = this.edges.find(edge => edge.id === id)) !== null && _this$edges$find !== void 0 ? _this$edges$find : null;\n  }\n\n  getLinkId(id) {\n    return this.getEdgeId(id);\n  }\n\n  getEdge(from, to) {\n    return this.edges.find(edge => {\n      if (!this.sameNode(edge.source, from)) return false;\n      if (!this.sameNode(edge.target, to)) return false;\n      return true;\n    });\n  }\n\n  getLink(from, to) {\n    return this.getEdge(from, to);\n  }\n\n  getHorizontalEdges() {\n    return this.edges.filter(edge => !this.isVerticalEdge(edge));\n  }\n\n  getVerticalEdges() {\n    return this.edges.filter(edge => this.isVerticalEdge(edge));\n  }\n\n  getSystemsCount() {\n    return this.systemsByID.size;\n  }\n\n  getNodesCount() {\n    return this.getSystemsCount();\n  }\n\n  getNodeCount() {\n    return this.getSystemsCount();\n  }\n\n  getSystemTreesCount() {\n    return this.systemTrees.length;\n  }\n\n  getTreesCount() {\n    return this.getSystemTreesCount();\n  }\n\n  getEdgesCount() {\n    return this.edges.length;\n  }\n\n  getLinksCount() {\n    return this.getEdgesCount();\n  }\n\n  getLinkCount() {\n    return this.getEdgesCount();\n  } // Event Handling\n\n  /**\r\n   * This function exists currently purely to integrate with the renderer. Before optimizing this, the renderer would have to be changed as well.\r\n   * @param {SystemNode|SystemTree|Edge} element element that updated\r\n   * @param {'add'|'update'|'remove'} changeType type of change\r\n   */\n\n\n  emitChange(element, changeType) {\n    this.emit('change', element, changeType);\n  }\n\n  onVerticalEdgeAdded(edge, parent, child) {\n    this.addEdge(edge);\n  }\n\n  onVerticalEdgeRemoved(edge, parent, child) {\n    this.edges.splice(this.edges.indexOf(edge), 1);\n    this.emitChange(edge, 'remove');\n  }\n\n  onSystemTreeChanged(systemTree, node) {\n    // TODO\n    if (systemTree.isEmpty()) {\n      this.systemTrees.splice(this.systemTrees.indexOf(systemTree), 1);\n    }\n  }\n\n  addEventListenersToSystem(system) {\n    var _this = this;\n\n    system.on('edgeAdded', function () {\n      return _this.onVerticalEdgeAdded(...arguments);\n    });\n    system.on('edgeRemoved', function () {\n      return _this.onVerticalEdgeRemoved(...arguments);\n    });\n    system.on('systemTreeChanged', function () {\n      return _this.onSystemTreeChanged(...arguments);\n    });\n  }\n\n  addEventListenersToSystemTree(tree) {// TODO\n  } // Adding Data\n\n\n  addSystem() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (typeof parent === 'string') parent = this.getSystemByName(parent);\n    let system = new SystemNode(name, parent, data);\n    if (name === null) name = String(system.id);\n    this.systemsByName.insert(name, system);\n    this.systemsByID.set(system.id, system);\n\n    if (!system.systemTree) {\n      let tree = new SystemTree(system);\n      this.systemTrees.push(tree);\n      this.addEventListenersToSystemTree(tree);\n    }\n\n    this.addEventListenersToSystem(system);\n    this.emitChange(system, 'add');\n    return system;\n  }\n\n  addEdge(edge) {\n    this.edges.push(edge);\n    this.emit('edgeAdded', edge, this.isVerticalEdge(edge));\n    this.emitChange(edge, 'add');\n    return edge;\n  }\n  /**\r\n   * Create a new edge to link two systems/systemTrees. If the systems are not in the landscape, they will be added. If an edge between the two systems already exists, it will be returned.\r\n   * @param {?SystemNode|SystemTree} from SystemNode or SystemTree from which the edge comes from\r\n   * @param {?SystemNode|SystemTree} to SystemNode or SystemTree to which the edge goes to\r\n   * @param {any} data Data associated with the edge\r\n   */\n\n\n  linkSystems(from, to) {\n    var _from, _to;\n\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let edge = this.getEdge(from, to);\n\n    if (edge) {\n      edge.changeData(data);\n      return edge;\n    }\n\n    from = this.getSystem(from);\n    to = this.getSystem(to);\n    if (!this.hasSystem((_from = from) === null || _from === void 0 ? void 0 : _from.id)) from = this.addSystem();\n    if (!this.hasSystem((_to = to) === null || _to === void 0 ? void 0 : _to.id)) to = this.addSystem();\n    edge = new Edge(from, to, data);\n    this.addEdge(edge);\n    return edge;\n  }\n\n  linkSystemsUndirected(system1, system2, data) {\n    this.linkSystems(system1, system2, data);\n    this.linkSystems(system2, system1, data); // TODO: Anything else to do?\n  } // Removing Data\n\n\n  removeSystem(id) {\n    let sysEdges = this.getEdgesOfSystem(id, true, true, true);\n    let sys = this.getSystem(id);\n    this.systemsByID.delete(id);\n    this.systemsByName.delete(sys.name);\n    this.emit('systemRemoved', sys);\n    this.emitChange(sys, 'remove');\n    sysEdges.forEach(edge => this.removeEdge(edge));\n  }\n\n  removeEdge(id) {\n    let keepBidirectional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let edge = this.getEdgeId(id);\n    if (!edge) return false;\n    let idx = this.edges.findIndex(e => e.id === edge.id);\n    if (idx === -1) return false;\n\n    if (keepBidirectional) {\n      let edge2 = this.getEdge(edge.target, edge.source);\n\n      if (edge2) {\n        this.removeEdge(edge2, false);\n      }\n    }\n\n    let isVertical = this.isVerticalEdge(edge);\n\n    if (isVertical) {\n      this.getSystem(edge.source).removeChild(edge.target.id);\n    }\n\n    this.edges.splice(idx, 1);\n    this.emit('edgeRemoved', edge, isVertical);\n    this.emitChange(edge, 'remove');\n    return true;\n  } // Updating Data\n\n\n  updateSystemName(id, newName) {\n    let sys = this.getSystem(id);\n    this.systemsByName.delete(sys.name);\n    this.systemsByName.insert(newName, sys);\n    sys.name = newName;\n    this.emitChange(sys, 'update');\n  }\n\n  updateSystem(id, data) {\n    let sys = this.getSystem(id);\n\n    if (data !== null && data !== void 0 && data.name) {\n      this.updateSystemName(sys, data.name);\n      delete data.name;\n    }\n\n    sys.data = { ...sys.data,\n      ...data\n    };\n    this.emitChange(sys, 'update');\n    return sys;\n  }\n\n  updateEdge(id, data) {\n    let edge = this.getEdgeId(id);\n    if (!edge) return null;\n    edge.data = { ...edge.data,\n      ...data\n    };\n    this.emitChange(edge, 'update');\n    return edge;\n  } // Moving Data\n\n\n  moveSystem(id) {\n    let newParentId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let system = this.getSystem(id);\n    this.emitChange(system, 'remove');\n    if (!system) return false; // Edge from old parent should be removed automatically via event listeners\n\n    let newParent = newParentId === null ? null : this.getSystem(newParentId);\n\n    if (newParent) {\n      newParent.addChild(system); // New Edge from new Parent should be added automatically via event listeners\n    } else {\n      // If there's no new parent, the system should have its own systemTree created\n      let tree = new SystemTree(system);\n      this.systemTrees.push(tree);\n    }\n\n    this.emitChange(system, 'add');\n  }\n\n  moveEdgeId(id) {\n    let newSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let newTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let keepBidirectional = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let edge = this.getEdgeId(id);\n    return this.moveEdge(edge, newSource, newTarget, keepBidirectional);\n  }\n\n  moveEdge(edge) {\n    let newSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let newTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let keepBidirectional = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (!edge) return false;\n    this.emitChange(edge, 'remove');\n\n    if (keepBidirectional) {\n      let otherEdge = this.getEdge(edge.target, edge.source);\n\n      if (otherEdge) {\n        this.moveEdge(otherEdge, newTarget, newSource, false);\n      }\n    }\n\n    let newSourceNode = newSource === null ? edge.source : this.getSystem(newSource);\n    let newTargetNode = newTarget === null ? edge.target : this.getSystem(newTarget);\n    let wasVertical = this.isVerticalEdge(edge);\n\n    if (wasVertical) {\n      var _edge$source2;\n\n      (_edge$source2 = edge.source) === null || _edge$source2 === void 0 ? void 0 : _edge$source2.removeChild(edge.target.id);\n    }\n\n    edge.source = newSourceNode;\n    edge.target = newTargetNode;\n    let isVertical = this.isVerticalEdge(edge);\n\n    if (isVertical) {\n      var _edge$source3;\n\n      (_edge$source3 = edge.source) === null || _edge$source3 === void 0 ? void 0 : _edge$source3.addChild(edge.target.id);\n    }\n\n    this.emit('edgeMoved', edge, wasVertical, isVertical);\n    this.emitChange(edge, 'add');\n    return true;\n  } // Looping\n\n\n  forEachSystem(callback) {\n    return this.forEachNode(callback);\n  }\n\n  forEachNode(callback) {\n    this.systemsByID.forEach(node => callback(node));\n  }\n  /**\r\n   * @callback edgeCallback\r\n   * @param {Edge} edge\r\n   */\n\n  /**\r\n   * Calls the callback for each edge in the graph.\r\n   * @param {edgeCallback} callback\r\n   */\n\n\n  forEachEdge(callback) {\n    this.edges.forEach(edge => callback(edge));\n  }\n  /**\r\n   * Calls the callback for each edge in the graph.\r\n   * @param {edgeCallback} callback\r\n   */\n\n\n  forEachLink(callback) {\n    return this.forEachEdge(callback);\n  }\n  /**\r\n   * Calls the callback for each horizontal edge in the graph\r\n   * @param {edgeCallback} callback\r\n   */\n\n\n  forEachHorizontalEdge(callback) {\n    this.edges.forEach(edge => {\n      if (!this.isVerticalEdge(edge)) {\n        callback(edge);\n      }\n    });\n  }\n  /**\r\n   * Calls the callback for each vertical edge in the graph\r\n   * @param {edgeCallback} callback\r\n   */\n\n\n  forEachVerticalEdge(callback) {\n    this.edges.forEach(edge => {\n      if (this.isVerticalEdge(edge)) {\n        callback(edge);\n      }\n    });\n  } // Positioning\n\n\n  positionSystem(id, x, y) {// TODO\n  }\n\n  positionSystemTree(id, x, y) {// TODO\n  }\n\n  automaticLayout(layout) {// TODO\n  }\n\n  positionEdge(params) {// TODO\n  } // Saving / Loading\n\n\n  save(format) {// TODO\n\n    let location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  }\n\n  load(location) {// TODO\n\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  }\n\n  saveView(name) {// TODO\n  }\n\n  deleteView(name) {// TODO\n  }\n\n  goBack() {// TODO\n\n    let steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  }\n\n  goForward() {// TODO\n\n    let steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  }\n\n}\n\nmodule.exports = SystemLandscape;\n\n//# sourceURL=webpack://vivagraphjs/./src/Graphs/SystemLandscape.js?");

/***/ }),

/***/ "./src/Graphs/SystemNode.js":
/*!**********************************!*\
  !*** ./src/Graphs/SystemNode.js ***!
  \**********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const Tree = __webpack_require__(/*! ../Utils/Tree */ \"./src/Utils/Tree.js\");\n\nconst Edge = __webpack_require__(/*! ./Edge */ \"./src/Graphs/Edge.js\");\n\nclass SystemNode extends Tree {\n  /**\r\n   * Create a new SystemNode. SystemNodes represent single systems in a tree-like hierachy of systems. To connect several systems (or systemTrees) together, you need to use the SystemLandscape class.\r\n   * @param {?SystemNode} parent The parent of this tree-node\r\n   * @param {any} data Data associated with this node\r\n   */\n  constructor() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(null, data);\n    this.name = name;\n    this.systemTree = parent instanceof SystemNode ? parent.systemTree : null;\n    this.edgesToChildren = [];\n    /** @type {?SystemNode} (For documentation only, remove this and use typescript type-annotations instead in the future) */\n\n    this.parent;\n    this.changeParent(parent);\n  } // Getting Data\n\n\n  getEdge(toId) {\n    return this.edgesToChildren.find(edge => edge.target === toId);\n  }\n\n  getVerticalLinks() {\n    let includeLinkFromParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let res = [];\n    if (includeLinkFromParent && this.parent) res.push(this.parent.getEdge(this.id));\n    res.push(...this.edgesToChildren);\n    return res;\n  } // Updating Data\n\n\n  changeSystemTree(systemTree) {\n    this.systemTree = systemTree;\n    this.emit('systemTreeChanged', systemTree, this);\n    this.children.forEach(child => child.changeSystemTree(systemTree));\n  } // Adding Data\n\n\n  addChild(child) {\n    super.addChild(child);\n    child.changeSystemTree(this.systemTree);\n    const edge = new Edge(this, child);\n    this.edgesToChildren.push(edge);\n    this.emit('edgeAdded', edge, this, child);\n    return child;\n  } // Removing Data\n\n\n  removeChild(id) {\n    let c = super.removeChild(id);\n\n    if (c) {\n      let idx = this.edgesToChildren.findIndex(edge => edge.target !== id);\n      this.emit('edgeRemoved', this.edgesToChildren[idx], this, c);\n      this.edgesToChildren.splice(idx, 1);\n    }\n\n    return c;\n  }\n\n}\n\nmodule.exports = SystemNode;\n\n//# sourceURL=webpack://vivagraphjs/./src/Graphs/SystemNode.js?");

/***/ }),

/***/ "./src/Graphs/SystemTree.js":
/*!**********************************!*\
  !*** ./src/Graphs/SystemTree.js ***!
  \**********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const EventManager = __webpack_require__(/*! ../Utils/EventManager */ \"./src/Utils/EventManager.js\");\n\nconst newID = __webpack_require__(/*! ../Utils/id */ \"./src/Utils/id.js\");\n\nconst SystemNode = __webpack_require__(/*! ./SystemNode */ \"./src/Graphs/SystemNode.js\"); // require('./System) can't be called at the top:\n// https://stackoverflow.com/questions/29023320/resolving-circular-dependency-in-nodejs-model\n// Solution: require('./System') inside each function that needs access to it.\n// Another solution would be to not use class syntax but function prototypes\n// That would work since Classes are technically just syntactic sugar\n// Problem with that is the difficult use of \"this\":\n// https://stackoverflow.com/a/20279485/13764271\n\n\nclass SystemTree extends EventManager {\n  /**\r\n   * Create a new SystemTree object. SystemTrees store the tree-like structure of systems and allows easy interaction with them. This class also adds events to listen to changes in the tree.\r\n   * @param {?SystemNode} root Root node of the systemTree.\r\n   * @param {any} data Data to store with the systemTree.\r\n   */\n  constructor() {\n    let root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.id = newID();\n    this.data = data || {};\n    this.root = root;\n    if (this.root instanceof SystemNode) this.root.changeSystemTree(this);\n  } // Checks\n\n\n  isEmpty() {\n    return !this.root && Object.keys(this.data).length === 0;\n  } // Getting Data\n\n\n  getSystems() {\n    var _this$root$getChildre, _this$root;\n\n    let startLayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let endLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startLayer;\n    return (_this$root$getChildre = (_this$root = this.root) === null || _this$root === void 0 ? void 0 : _this$root.getChildren(startLayer, endLayer)) !== null && _this$root$getChildre !== void 0 ? _this$root$getChildre : [];\n  }\n\n  getSystem(id) {\n    var _this$root$getByID, _this$root2;\n\n    return (_this$root$getByID = (_this$root2 = this.root) === null || _this$root2 === void 0 ? void 0 : _this$root2.getByID(id)) !== null && _this$root$getByID !== void 0 ? _this$root$getByID : null;\n  }\n\n  getEdge(toId) {\n    var _this$root$getEdge, _this$root3;\n\n    return (_this$root$getEdge = (_this$root3 = this.root) === null || _this$root3 === void 0 ? void 0 : _this$root3.getEdge(toId)) !== null && _this$root$getEdge !== void 0 ? _this$root$getEdge : null;\n  }\n\n  getEdgesFrom(fromId) {\n    var _this$getVerticalLink;\n\n    return (_this$getVerticalLink = this.getVerticalLinks(fromId, false)) !== null && _this$getVerticalLink !== void 0 ? _this$getVerticalLink : [];\n  }\n\n  getVerticalLinks() {\n    var _node$getVerticalLink;\n\n    let nodeId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let includeLinkFromParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let node = nodeId ? this.getSystem(nodeId) : this.root;\n    return (_node$getVerticalLink = node === null || node === void 0 ? void 0 : node.getVerticalLinks(includeLinkFromParent)) !== null && _node$getVerticalLink !== void 0 ? _node$getVerticalLink : [];\n  } // Adding Data\n\n\n  addChild(system) {\n    this.addSystem(system);\n  }\n\n  addSystem(system) {// TODO\n\n    let parentId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  } // Updating Data\n\n  /**\r\n   * Change the Parent of a system in this tree.\r\n   * @param {Number} systemId ID of the system to change the parent of\r\n   * @param {?SystemTree} newParent The new parent of this system. If set to null, the system will have no parent.\r\n   * @returns {Boolean} Indicates whether the system was found and the parent could thus be changed.\r\n   */\n\n\n  changeParent(systemId) {\n    let newParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let system = this.getSystem(systemId);\n    if (!system) return false;\n    system === null || system === void 0 ? void 0 : system.changeParent(newParent);\n    return true;\n  } // Removing Data\n\n\n  removeChild(id) {\n    return this.removeSystem(id);\n  }\n\n  removeSystem(systemId) {\n    let system = this.getSystem(systemId);\n    if (!system) return false;\n    system.parent.removeChild(system.id);\n    return true;\n  }\n\n}\n\nmodule.exports = SystemTree;\n\n//# sourceURL=webpack://vivagraphjs/./src/Graphs/SystemTree.js?");

/***/ }),

/***/ "./src/Input/dragndrop.js":
/*!********************************!*\
  !*** ./src/Input/dragndrop.js ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n */\nmodule.exports = dragndrop;\n\nlet documentEvents = __webpack_require__(/*! ../Utils/documentEvents.js */ \"./src/Utils/documentEvents.js\");\n\nlet browserInfo = __webpack_require__(/*! ../Utils/browserInfo.js */ \"./src/Utils/browserInfo.js\");\n\nlet findElementPosition = __webpack_require__(/*! ./findElementPosition.js */ \"./src/Input/findElementPosition.js\"); // TODO: Move to input namespace\n// TODO: Methods should be extracted into the prototype. This class\n// does not need to consume so much memory for every tracked element\n\n\nfunction dragndrop(element) {\n  let start,\n      drag,\n      end,\n      scroll,\n      prevSelectStart,\n      prevDragStart,\n      startX = 0,\n      startY = 0,\n      dragObject,\n      touchInProgress = false,\n      pinchZoomLength = 0,\n      getMousePos = function (e) {\n    let posx = 0,\n        posy = 0;\n    e = e || window.event;\n\n    if (e.pageX || e.pageY) {\n      posx = e.pageX;\n      posy = e.pageY;\n    } else if (e.clientX || e.clientY) {\n      posx = e.clientX + window.document.body.scrollLeft + window.document.documentElement.scrollLeft;\n      posy = e.clientY + window.document.body.scrollTop + window.document.documentElement.scrollTop;\n    }\n\n    return [posx, posy];\n  },\n      move = function (e, clientX, clientY) {\n    if (drag) {\n      drag(e, {\n        x: clientX - startX,\n        y: clientY - startY\n      });\n    }\n\n    startX = clientX;\n    startY = clientY;\n  },\n      stopPropagation = function (e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else {\n      e.cancelBubble = true;\n    }\n  },\n      preventDefault = function (e) {\n    if (e.preventDefault) e.preventDefault();\n  },\n      handleDisabledEvent = function (e) {\n    stopPropagation(e);\n    return false;\n  },\n      handleMouseMove = function (e) {\n    e = e || window.event;\n    move(e, e.clientX, e.clientY);\n  },\n      handleMouseDown = function (e) {\n    e = e || window.event;\n\n    if (touchInProgress) {\n      // modern browsers will fire mousedown for touch events too\n      // we do not want this, since touch is handled separately.\n      stopPropagation(e);\n      return false;\n    } // for IE, left click == 1\n    // for Firefox, left click == 0\n\n\n    let isLeftButton = e.button === 1 && window.event !== null || e.button === 0;\n\n    if (isLeftButton) {\n      startX = e.clientX;\n      startY = e.clientY; // TODO: bump zIndex?\n\n      dragObject = e.target || e.srcElement;\n\n      if (start) {\n        start(e, {\n          x: startX,\n          y: startY\n        });\n      }\n\n      documentEvents.on('mousemove', handleMouseMove);\n      documentEvents.on('mouseup', handleMouseUp);\n      stopPropagation(e); // TODO: What if event already there? Not bullet proof:\n\n      prevSelectStart = window.document.onselectstart;\n      prevDragStart = window.document.ondragstart;\n      window.document.onselectstart = handleDisabledEvent;\n      dragObject.ondragstart = handleDisabledEvent; // prevent text selection (except IE)\n\n      return false;\n    }\n  },\n      handleMouseUp = function (e) {\n    e = e || window.event;\n    documentEvents.off('mousemove', handleMouseMove);\n    documentEvents.off('mouseup', handleMouseUp);\n    window.document.onselectstart = prevSelectStart;\n    dragObject.ondragstart = prevDragStart;\n    dragObject = null;\n\n    if (end) {\n      end(e);\n    }\n  },\n      handleMouseWheel = function (e) {\n    if (typeof scroll !== 'function') {\n      return;\n    }\n\n    e = e || window.event;\n    if (e.preventDefault) e.preventDefault();\n    e.returnValue = false;\n    let delta = -e.deltaY,\n        mousePos = getMousePos(e),\n        elementOffset = findElementPosition(element),\n        relMousePos = {\n      x: mousePos[0] - elementOffset[0],\n      y: mousePos[1] - elementOffset[1]\n    };\n    scroll(e, delta, relMousePos);\n  },\n      updateScrollEvents = function (scrollCallback) {\n    if (!scroll && scrollCallback) {\n      // client is interested in scrolling. Start listening to events:\n      element.addEventListener('wheel', handleMouseWheel, false);\n    } else if (scroll && !scrollCallback) {\n      element.removeEventListener('wheel', handleMouseWheel, false);\n    }\n\n    scroll = scrollCallback;\n  },\n      getPinchZoomLength = function (finger1, finger2) {\n    return (finger1.clientX - finger2.clientX) * (finger1.clientX - finger2.clientX) + (finger1.clientY - finger2.clientY) * (finger1.clientY - finger2.clientY);\n  },\n      handleTouchMove = function (e) {\n    if (e.touches.length === 1) {\n      stopPropagation(e);\n      let touch = e.touches[0];\n      move(e, touch.clientX, touch.clientY);\n    } else if (e.touches.length === 2) {\n      // it's a zoom:\n      let currentPinchLength = getPinchZoomLength(e.touches[0], e.touches[1]);\n      let delta = 0;\n\n      if (currentPinchLength < pinchZoomLength) {\n        delta = -1;\n      } else if (currentPinchLength > pinchZoomLength) {\n        delta = 1;\n      }\n\n      scroll(e, delta, {\n        x: e.touches[0].clientX,\n        y: e.touches[0].clientY\n      });\n      pinchZoomLength = currentPinchLength;\n      stopPropagation(e);\n      preventDefault(e);\n    }\n  },\n      handleTouchEnd = function (e) {\n    touchInProgress = false;\n    documentEvents.off('touchmove', handleTouchMove);\n    documentEvents.off('touchend', handleTouchEnd);\n    documentEvents.off('touchcancel', handleTouchEnd);\n    dragObject = null;\n\n    if (end) {\n      end(e);\n    }\n  },\n      handleSignleFingerTouch = function (e, touch) {\n    stopPropagation(e);\n    preventDefault(e);\n    startX = touch.clientX;\n    startY = touch.clientY;\n    dragObject = e.target || e.srcElement;\n\n    if (start) {\n      start(e, {\n        x: startX,\n        y: startY\n      });\n    } // TODO: can I enter into the state when touch is in progress\n    // but it's still a single finger touch?\n\n\n    if (!touchInProgress) {\n      touchInProgress = true;\n      documentEvents.on('touchmove', handleTouchMove);\n      documentEvents.on('touchend', handleTouchEnd);\n      documentEvents.on('touchcancel', handleTouchEnd);\n    }\n  },\n      handleTouchStart = function (e) {\n    if (e.touches.length === 1) {\n      return handleSignleFingerTouch(e, e.touches[0]);\n    } else if (e.touches.length === 2) {\n      // handleTouchMove() will care about pinch zoom.\n      stopPropagation(e);\n      preventDefault(e);\n      pinchZoomLength = getPinchZoomLength(e.touches[0], e.touches[1]);\n    } // don't care about the rest.\n\n  };\n\n  element.addEventListener('mousedown', handleMouseDown);\n  element.addEventListener('touchstart', handleTouchStart);\n  return {\n    onStart: function (callback) {\n      start = callback;\n      return this;\n    },\n    onDrag: function (callback) {\n      drag = callback;\n      return this;\n    },\n    onStop: function (callback) {\n      end = callback;\n      return this;\n    },\n\n    /**\r\n     * Occurs when mouse wheel event happens. callback = function(e, scrollDelta, scrollPoint);\r\n     */\n    onScroll: function (callback) {\n      updateScrollEvents(callback);\n      return this;\n    },\n    release: function () {\n      // TODO: could be unsafe. We might wanna release dragObject, etc.\n      element.removeEventListener('mousedown', handleMouseDown);\n      element.removeEventListener('touchstart', handleTouchStart);\n      documentEvents.off('mousemove', handleMouseMove);\n      documentEvents.off('mouseup', handleMouseUp);\n      documentEvents.off('touchmove', handleTouchMove);\n      documentEvents.off('touchend', handleTouchEnd);\n      documentEvents.off('touchcancel', handleTouchEnd);\n      updateScrollEvents(null);\n    }\n  };\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/Input/dragndrop.js?");

/***/ }),

/***/ "./src/Input/findElementPosition.js":
/*!******************************************!*\
  !*** ./src/Input/findElementPosition.js ***!
  \******************************************/
/***/ (function(module) {

eval("/**\r\n * Finds the absolute position of an element on a page\r\n */\nmodule.exports = findElementPosition;\n\nfunction findElementPosition(obj) {\n  let curleft = 0,\n      curtop = 0;\n\n  if (obj.offsetParent) {\n    do {\n      curleft += obj.offsetLeft;\n      curtop += obj.offsetTop;\n    } while ((obj = obj.offsetParent) !== null);\n  }\n\n  return [curleft, curtop];\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/Input/findElementPosition.js?");

/***/ }),

/***/ "./src/Layout/randLayout.js":
/*!**********************************!*\
  !*** ./src/Layout/randLayout.js ***!
  \**********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const Coordinate = __webpack_require__(/*! ../Geom/Coordinate.js */ \"./src/Geom/Coordinate.js\");\n\nconst SystemNode = __webpack_require__(/*! ../Graphs/SystemNode.js */ \"./src/Graphs/SystemNode.js\");\n\nconst NodeGroup = __webpack_require__(/*! ../Graphs/NodeGroup.js */ \"./src/Graphs/NodeGroup.js\");\n/**\n * Gives each node a position based on all other visible nodes.\n * @param {Iterable<SystemNode>} nodes Iterable of all visible nodes\n * @param {NodeGroup} grouping Grouping of all visible nodes\n * @param {Map<Number, Coordinate>} currentNodePositions Mapping from Node-Ids to their current positions\n * @param {Coordinate} maxSize Sets the maximum values that are possible for the nodes\n */\n\n\nfunction randLayout(nodes, grouping, currentNodePositions, maxSize) {\n  let nodePositions = new Map();\n\n  for (const node of nodes) {\n    var _node$id;\n\n    const id = (_node$id = node === null || node === void 0 ? void 0 : node.id) !== null && _node$id !== void 0 ? _node$id : node;\n    let val = null;\n    if (currentNodePositions.has(id)) val = currentNodePositions.get(id);else val = Coordinate.rand(maxSize.x, maxSize.y, currentNodePositions);\n    nodePositions.set(id, val);\n  }\n\n  return nodePositions;\n}\n/**\n * Gives a single node a position based on all other visible nodes.\n * @param {SystemNode} node Node to be positioned\n * @param {NodeGroup} grouping Grouping of all visible nodes\n * @param {Map<Number, Coordinate>} currentNodePositions Mapping from Node-Ids to their current positions\n * @param {Coordinate} maxSize Sets the maximum values that are possible for the nodes\n */\n\n\nfunction randSingleLayout(node, grouping, currentNodePositions, maxSize) {\n  return Coordinate.rand(maxSize.x, maxSize.y, currentNodePositions);\n}\n\nmodule.exports = {\n  randLayout,\n  randSingleLayout\n};\n\n//# sourceURL=webpack://vivagraphjs/./src/Layout/randLayout.js?");

/***/ }),

/***/ "./src/Renderer.js":
/*!*************************!*\
  !*** ./src/Renderer.js ***!
  \*************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const EventManager = __webpack_require__(/*! ./Utils/EventManager */ \"./src/Utils/EventManager.js\");\n\nconst Coordinate = __webpack_require__(/*! ./Geom/Coordinate */ \"./src/Geom/Coordinate.js\");\n\nconst svg = __webpack_require__(/*! ./Utils/svgHelper */ \"./src/Utils/svgHelper.js\");\n\nconst {\n  randLayout,\n  randSingleLayout\n} = __webpack_require__(/*! ./Layout/randLayout */ \"./src/Layout/randLayout.js\");\n\nconst SingleLayerView = __webpack_require__(/*! ./Views/SingleLayerView */ \"./src/Views/SingleLayerView.js\");\n\nconst dragndrop = __webpack_require__(/*! ./Input/dragndrop */ \"./src/Input/dragndrop.js\");\n\nconst timer = __webpack_require__(/*! ./Utils/timer */ \"./src/Utils/timer.js\");\n/**\n * @typedef {object} timerRes\n * @property {function} stop\n * @property {function} restart\n */\n\n/**\n * @typedef {function} timer\n * @param {?function} callback\n * @returns {timerRes}\n */\n// For JSDocs:\n\n\nconst SystemLandscape = __webpack_require__(/*! ./Graphs/SystemLandscape */ \"./src/Graphs/SystemLandscape.js\");\n\nconst SystemTree = __webpack_require__(/*! ./Graphs/SystemTree */ \"./src/Graphs/SystemTree.js\");\n\nconst SystemNode = __webpack_require__(/*! ./Graphs/SystemNode */ \"./src/Graphs/SystemNode.js\");\n\nconst Edge = __webpack_require__(/*! ./Graphs/Edge */ \"./src/Graphs/Edge.js\");\n\nconst View = __webpack_require__(/*! ./Views/View */ \"./src/Views/View.js\"); // Wanted API:\n// - run(layout?)\n//\t\tInitialize Renderer & start rendering loop\n//\t\tlayout determines the initial layout-function to be called to give the nodes their initial position\n// - pause()\n// - resume()\n// - changeView(view)\n//\t\tChanges the View to a specified `view`\n//\t\tThe view specifies which nodes are visible\n//\t\tThe view also specifies how vertical links between nodes should be visualized\n//\t\tThe View determines how nodes / edges are drawn\n//\t\tFurther customizations might be added by the view (later)\n// - runLayout(layout)\n//\t\tCalls a layout function\n//\t\tThe function should return a mapping from nodeIds to new (x,y)-coordinates for them\n// - zoomIn()\n// - zoomOut()\n// - selectNode(nodeId)\n// - moveNode(nodeId, x, y)\n// - moveEdge() / shapeEdge() / something like that to create curves\n// - moveCamera(x, y)\n// - centerCamera(id)\n//\t\tcenters camera on specified node / systemTree / graph\n//\t\tif undefined, centers on graph\n// - drawNode(node, x, y)\n// UI-Handling:\n// - on node clicked\n// - on edge clicked\n//\t\tIf trees are drawn with groupings around the nodes, listen to those spaces being clicked too\n// - on node drag-and-dropped\n// For later\n// \t\tEdge moved or drawn differently\n// Events to allow listeners for:\n// - nodeSelected\n// - edgeSelected\n// - nodeMoved\n// Events the Renderer listens to (emitted by system-landscape):\n// - newNode\n// - newEdge\n// - updated / removed node or edge\n\n/**\n * @typedef {Object} rendererSettings\n * @property {number} frameInterval number of milliseconds to wait between rendering each frame. Defaults to 30.\n * @property {HTMLElement} container Container elemnent, in which the svg-container is added.\n * @property {?Coordinate} maxSize Maximum rectangle size. Defaults to the whole size of `container`.\n * @property {View} view View to use for rendering.\n * @property {layout} newNodeLayout Function to use for finding the position of a single new node.\n */\n\n/** @type {rendererSettings} */\n\n\nconst defaultSettings = {\n  frameInterval: 30,\n  container: document.body,\n  maxSize: null,\n  view: new SingleLayerView(0),\n  newNodeLayout: randSingleLayout\n};\n\nclass Renderer extends EventManager {\n  /**\n   * @param {SystemLandscape} graph Graph to render\n   * @param {rendererSettings} settings Optional Settings that can be adjusted\n   */\n  constructor(graph) {\n    let settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    settings = { ...defaultSettings,\n      ...settings\n    }; // TODO:\n\n    this.nodeLength = 30; // How big should the nodes be drawn???\n\n    this.drawnNodes = new Map(); // Map<ID, SVG-Element>\n\n    this.drawnEdges = new Map(); // Map<ID, SVG-Element>\n\n    this.userInteraction = false;\n    this.newNodeLayout = settings.newNodeLayout;\n    /** @type {SystemLandscape} System-Landscape-Graph to render */\n\n    this.graph = graph;\n    /** @type {View} Current View */\n\n    this.view = settings.view.init(this.graph); // TODO: Set view\n\n    /** @type {Map<Number, Coordinate>} Maps NodeIds to their nodes' coordinates */\n\n    this.nodePositions = new Map();\n    /** @type {HTMLElement} */\n\n    this.container = settings.container;\n    /** @type {SVGSVGElement} The top svg-root element */\n\n    this.svgRoot = svg.createEl('svg');\n    /** @type {SVGGraphicsElement} The top container element, direct child of svgRoot */\n\n    this.svgContainer = svg.createEl('g');\n    /** TODO: Refactor dragndrop */\n\n    this.dragContainer = dragndrop(this.container);\n    /** @type {number} Factor indicating how far we are zoomed in/out of the system-map */\n\n    this.zoomFactor = 1;\n    /** @type {Coordinate} camera offset */\n\n    this.offset = new Coordinate(0, 0);\n    /** @type {Coordinate} Maximum Size for the svg-container to take up */\n\n    this.maxSize = this._setMaxSizeHelper(settings.maxSize);\n    /** @type {number} How many ms to wait between rendering frames */\n\n    this.frameInterval = settings.frameInterval;\n    /** @type {boolean} Indicates whether the Render has been started to run */\n\n    this.isInitialized = false;\n  }\n\n  _init() {\n    // Add HTML-Elements to DOM\n    svg.setAttr(this.svgContainer, 'buffered-rendering', 'dynamic');\n    this.svgRoot.appendChild(this.svgContainer);\n    this.container.appendChild(this.svgRoot); // Initialize SVG-Stuff\n\n    this._transform();\n\n    let defs = svg.append(this.svgRoot, 'defs'); // Create <defs> element for definitions\n\n    svg.append(defs, svg.createArrowMarker(this.nodeLength, 'Arrow')); // Initialize Event-Listeners\n\n    window.addEventListener('resize', this._onResize.bind(this));\n\n    this._setViewListeners(); // TODO: Let the following event-listeners be changeable by the user\n\n\n    this.dragContainer.onDrag((e, offset) => {\n      this._translateRel(offset);\n\n      this._render();\n    });\n    this.dragContainer.onScroll((e, scaleOffset, scrollPoint) => {\n      this._scale(scaleOffset < 0, scrollPoint);\n    }); // TODO: Listen to changes in the graph and update accordingly\n\n    this._resetVisible();\n  }\n\n  _resetVisible() {\n    this.drawnNodes.clear();\n    this.drawnEdges.clear();\n    this.nodePositions.clear();\n    let nodes = this.getVisibleNodes();\n    nodes.forEach(node => {\n      this._addNode(node);\n    });\n    let edges = this.view.getVisibleEdges();\n    edges.forEach(edge => {\n      if (this.drawnNodes.has(edge.source.id) && this.drawnNodes.has(edge.target.id)) this._addEdge(edge); // TODO\n    });\n  }\n  /**\n   * Only used in the constructor to set the maxSize\n   * @returns {Coordinate}\n   */\n\n\n  _setMaxSizeHelper(obj) {\n    var _obj$x, _obj$y;\n\n    if (obj === null) return new Coordinate(this.container.clientWidth, this.container.clientHeight);\n    if (obj instanceof Coordinate) return obj;\n    let x = (_obj$x = obj === null || obj === void 0 ? void 0 : obj.x) !== null && _obj$x !== void 0 ? _obj$x : obj[0];\n    let y = (_obj$y = obj === null || obj === void 0 ? void 0 : obj.y) !== null && _obj$y !== void 0 ? _obj$y : obj[1];\n    return new Coordinate(x, y);\n  }\n  /**\n   * Get a list of all systemNodes, that are visible in the current view\n   * @returns {Array<SystemNode>}\n   */\n\n\n  getVisibleNodes() {\n    return this.view.getVisibleNodes();\n  } // layout(nodes::Array/Set<SystemNode>, grouping::NodeGroup, currentNodePositions::Map<ID, (x,y)-Coordinate>, maxSize)\n  //\t\tReturns Map<ID, (x,y)-Coordinate>\n\n\n  run() {\n    let layout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : randLayout;\n    if (!this.isInitialized) this._init();\n\n    if (typeof layout === 'function') {\n      this.nodePositions = layout(this.getVisibleNodes(), this.view.grouping, this.nodePositions, this.maxSize);\n    }\n\n    this._render();\n  }\n  /**\n   * Change the View to another\n   * @param {View} View New View\n   */\n\n\n  changeView(View) {\n    this.view = View.init(this.graph);\n\n    this._resetVisible();\n\n    this._rmViewListeners();\n\n    this._setViewListeners(); // TODO: ???\n\n  }\n\n  _setViewListeners() {\n    this.view.on('node-add', node => {\n      this._addNode(node);\n    }).on('node-update').on('node-remove', node => {\n      this._rmNode(node);\n    }).on('edge-add', edge => {\n      this._addEdge(edge);\n    }).on('edge-update').on('edge-remove').on('group-add').on('group-update').on('group-remove');\n  }\n\n  _rmViewListeners() {\n    this.view.off(null);\n  }\n\n  runLayout(layout) {\n    this.nodePositions = layout(this.getVisibleNodes(), this.view.grouping, this.nodePositions, this.maxSize);\n\n    this._render();\n  }\n\n  zoomIn() {\n    this._scale(false);\n  }\n\n  zoomOut() {\n    this._scale(true);\n  }\n  /**\n   * Apply a transformation matrix to this renderer's svg-container. This is used to zoom in/out and move around in the system-map.\n   * @param {number} a Defaults to `this.zoomFactor`\n   * @param {number} b Defaults to 0\n   * @param {number} c Defaults to 0\n   * @param {number} d Defaults to `this.zoomFactor`\n   * @param {number} e Defaults to `this.offset.x`\n   * @param {number} f Defaults to `this.offset.y`\n   */\n\n\n  _transform() {\n    let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.zoomFactor;\n    let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.zoomFactor;\n    let e = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.offset.x;\n    let f = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.offset.y;\n    let transform = \"matrix(\".concat(a, \", \").concat(b, \", \").concat(c, \", \").concat(d, \", \").concat(e, \", \").concat(f, \")\");\n    svg.setAttr(this.svgContainer, 'transform', transform);\n  }\n\n  _translateRel(offset) {\n    let p = this.svgRoot.createSVGPoint();\n    p.x = offset.x;\n    p.y = offset.y;\n    let t = this.svgContainer.getCTM();\n    let origin = this.svgRoot.createSVGPoint().matrixTransform(t.inverse());\n    p = p.matrixTransform(t.inverse());\n    p.x = (p.x - origin.x) * t.a;\n    p.y = (p.y - origin.y) * t.d;\n    t.e += p.x;\n    t.f += p.y;\n\n    this._transform(t.a, 0, 0, t.d, t.e, t.f);\n  }\n\n  _scale(out) {\n    let scrollPoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (!scrollPoint) scrollPoint = {\n      x: this.maxSize.x / 2,\n      y: this.maxSize.y / 2\n    }; // TODO: Let user change this formula via settings, to allow for slower/faster scaling\n\n    let scaleFactor = Math.pow(1 + 0.4, out ? -0.2 : 0.2);\n    let p = this.svgRoot.createSVGPoint();\n    p.x = scrollPoint.x;\n    p.y = scrollPoint.y; // Translate to SVG coordinates\n\n    p = p.matrixTransform(this.svgContainer.getCTM().inverse()); // Compute new scale matrix in current mouse position\n\n    let k = this.svgRoot.createSVGMatrix().translate(p.x, p.y).scale(scaleFactor).translate(-p.x, -p.y);\n    let t = this.svgContainer.getCTM().multiply(k); // Apply new scale matrix & update properties\n\n    this.zoomFactor = t.a;\n    this.offset.update(t.e, t.f);\n\n    this._transform(t.a, 0, 0, t.d, t.e, t.f);\n  }\n\n  selectNode(nodeId) {}\n\n  moveNode(nodeId, offset) {\n    let oldPos = this.nodePositions.get(nodeId);\n    let newPos = oldPos.copy().map((v, i) => v + (i ? offset.y : offset.x) / this.zoomFactor);\n    this.nodePositions.set(nodeId, newPos);\n\n    this._render();\n  }\n\n  moveCamera(x, y) {}\n\n  centerCamera(id) {}\n\n  _buildNodeUI(node) {\n    let nodeContainer = svg.createEl('g');\n    let rect = svg.createEl('rect', {\n      width: this.nodeLength,\n      height: this.nodeLength,\n      fill: '#00a2e8'\n    }); // TODO: Let user customize fill-color\n\n    let name = svg.createEl('text', {\n      y: \"\".concat(2 * this.nodeLength / 3, \"px\")\n    });\n    name.textContent = node.name;\n    nodeContainer.node = node;\n    nodeContainer.appendChild(rect);\n    nodeContainer.appendChild(name);\n    return nodeContainer;\n  }\n\n  _addNode(node) {\n    const nodeContainer = this._buildNodeUI(node);\n\n    nodeContainer.drag = dragndrop(nodeContainer);\n    nodeContainer.drag.onStart(() => {\n      this.userInteraction = true;\n    }).onDrag((e, offset) => {\n      this.userInteraction = true;\n      this.moveNode(node.id, offset);\n    }).onStop(() => {\n      this.userInteraction = false;\n    });\n    const coord = this.newNodeLayout(node, this.view.grouping, this.nodePositions, this.maxSize);\n    this.nodePositions.set(node.id, coord);\n    this.drawnNodes.set(node.id, nodeContainer);\n    this.svgContainer.appendChild(nodeContainer);\n\n    this._render();\n  }\n\n  _rmNode(node) {\n    this.drawnNodes.delete(node.id);\n    this.nodePositions.delete(node.id);\n\n    this._render();\n  }\n\n  _renderNodes() {\n    this.drawnNodes.forEach((nodeContainer, id) => {\n      let coord = this.nodePositions.get(id);\n      svg.setAttr(nodeContainer, 'transform', \"translate(\".concat(coord.x - this.nodeLength / 2, \", \").concat(coord.y - this.nodeLength / 2, \")\"));\n    });\n  }\n\n  _addEdge(edge) {\n    let edgeUI = svg.createEl('path', {\n      stroke: 'gray',\n      'marker-end': 'url(#Arrow)'\n    });\n    edgeUI.edge = edge;\n    this.svgContainer.appendChild(edgeUI);\n    this.drawnEdges.set(edge.id, edgeUI);\n\n    this._render();\n  }\n\n  _renderEdges() {\n    this.drawnEdges.forEach((edgeUI, id) => {\n      /** @type {Edge} */\n      let edge = edgeUI.edge;\n      let sourceCoord = this.nodePositions.get(edge.source.id);\n      let targetCoord = this.nodePositions.get(edge.target.id);\n      let from = sourceCoord.rect(this.nodeLength, this.nodeLength, true).intersect(sourceCoord, targetCoord);\n      let to = targetCoord.rect(this.nodeLength, this.nodeLength, true).intersect(targetCoord, sourceCoord);\n      let d = \"M \".concat(from.x, \" \").concat(from.y, \" L \").concat(to.x, \" \").concat(to.y);\n      svg.setAttr(edgeUI, 'd', d);\n    });\n  } // TODO: render vertical edges in potentially different ways\n\n\n  _render() {\n    this._renderNodes();\n\n    this._renderEdges();\n\n    return this.userInteraction;\n  }\n\n  _onResize() {\n    // TODO: Maybe add: this.updateCenter();\n    this._render();\n  }\n\n}\n\nmodule.exports = Renderer;\n\n//# sourceURL=webpack://vivagraphjs/./src/Renderer.js?");

/***/ }),

/***/ "./src/Utils/EventManager.js":
/*!***********************************!*\
  !*** ./src/Utils/EventManager.js ***!
  \***********************************/
/***/ (function(module) {

eval("class EventManager {\n  constructor() {\n    this.events = {};\n  }\n\n  on(event, callback) {\n    if (!this.events[event]) this.events[event] = [];\n    if (typeof callback === 'function') this.events[event].push(callback);\n    return this;\n  }\n\n  once(event, callback) {\n    const self = this;\n\n    const onceCallback = function () {\n      callback(...arguments);\n      self.off(event, onceCallback);\n    };\n\n    return this.on(event, onceCallback);\n  }\n\n  off() {\n    let event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (event === null) this.events = {};else if (this.events[event]) {\n      if (callback === null) delete this.events[event];else this.events[event] = this.events[event].filter(cb => cb !== callback);\n    }\n    return this;\n  }\n\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (!this.events[event]) {\n      return;\n    }\n\n    this.events[event].forEach(cb => cb(...args));\n    return this;\n  }\n\n}\n\nmodule.exports = EventManager;\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/EventManager.js?");

/***/ }),

/***/ "./src/Utils/ExtendedSet.js":
/*!**********************************!*\
  !*** ./src/Utils/ExtendedSet.js ***!
  \**********************************/
/***/ (function(module) {

eval("class ExtendedSet extends Set {\n  constructor() {\n    super(...arguments);\n  }\n\n  push() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args.forEach(arg => this.add(arg));\n    return this;\n  }\n\n  find(cb) {\n    let i = 0;\n    let vals = this.values;\n\n    for (let i = 0; i < vals.length; i++) {\n      if (cb(v, i)) return v;\n    }\n\n    return null;\n  }\n\n  filter(cb) {\n    let asArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let arr = [];\n    let i = 0;\n    this.forEach(v => {\n      if (cb(v, i)) arr.push(v);\n      i++;\n    });\n    if (asArray) return arr;\n    return new ExtendedSet(arr);\n  }\n\n  map(cb) {\n    let asArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let arr = [];\n    let i = 0;\n    this.forEach(v => {\n      arr.push(cb(v, i));\n      i++;\n    });\n    if (asArray) return arr;\n    return new ExtendedSet(arr);\n  }\n\n  reduce(cb, initialValue) {\n    let asArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let arr = Array.from(this.values).reduce(cb, initialValue);\n    if (asArray) return arr;\n    return new ExtendedSet(arr);\n  }\n\n}\n\nmodule.exports = ExtendedSet;\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/ExtendedSet.js?");

/***/ }),

/***/ "./src/Utils/Tree.js":
/*!***************************!*\
  !*** ./src/Utils/Tree.js ***!
  \***************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const newID = __webpack_require__(/*! ../Utils/id */ \"./src/Utils/id.js\");\n\nconst EventManager = __webpack_require__(/*! ./EventManager */ \"./src/Utils/EventManager.js\");\n\nclass Tree extends EventManager {\n  /**\r\n   * Create a new Tree object. All nodes in the Tree are instances of this Tree class.\r\n   * @param {?Tree} parent The parent of this tree-node\r\n   * @param {any} data Data associated with this node\r\n   */\n  constructor() {\n    let parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    /** @type {Number} */\n\n    this.id = newID();\n    /** @type {any} */\n\n    this.data = data || {};\n    /** @type {?Tree} */\n\n    this.parent = parent;\n    /** @type {Tree[]} */\n\n    this.children = [];\n  }\n  /**\r\n   * Returns how many levels deep this node is in the tree.\r\n   * @returns {Number}\r\n   */\n\n\n  get depth() {\n    let depth = 0;\n    let parent = this.parent;\n\n    while (parent !== null) {\n      depth++;\n      parent = parent.parent;\n    }\n\n    return depth;\n  }\n  /**\tSynonym for this.depth */\n\n\n  get layer() {\n    return this.depth;\n  }\n  /**\r\n   * Returns how many levels the tree goes deeper from here\r\n   * @returns {Number}\r\n   */\n\n\n  get height() {\n    return Math.max(...this.children.map(child => child.height)) + 1;\n  }\n  /**\r\n   * Get the root-node of this tree.\r\n   * @returns {Tree}\r\n   */\n\n\n  get root() {\n    if (this.parent === null) return this;\n    let parent = this.parent;\n\n    while (parent.parent !== null) {\n      parent = parent.parent;\n    }\n\n    return parent;\n  }\n  /**\r\n   * Check if this Tree-Node is empty - i.e. has no children and no data associated with it.\r\n   * @returns {Boolean}\r\n   */\n\n\n  isEmpty() {\n    return this.children.length === 0 && Object.keys(this.data).length === 0;\n  }\n  /**\r\n   * Check if this Tree-Node is a leaf - i.e. has no children.\r\n   * @returns {Boolean}\r\n   */\n\n\n  isLeaf() {\n    return this.children.length === 0;\n  }\n  /**\r\n   * Check if this Tree-Node is the root of its tree - i.e. it has no parent.\r\n   * @returns {Boolean}\r\n   */\n\n\n  isRoot() {\n    return this.parent === null;\n  }\n  /**\r\n   * Check if the node has any siblings - i.e. it's not the only child of its parent.\r\n   * @returns {Boolean}\r\n   */\n\n\n  hasSiblings() {\n    if (this.parent === null) return false;\n    return this.parent.children.length > 1;\n  }\n  /**\r\n   * Check if the node has any siblings to its left\r\n   * @returns {Boolean}\r\n   */\n\n\n  hasLeftSibling() {\n    if (this.parent === null) return false; // Only the left-most child has no left sibling\n\n    return this.parent.children[0] !== this;\n  }\n  /**\r\n   * Check if the node has any siblings to its right\r\n   * @returns {Boolean}\r\n   */\n\n\n  hasRightSibling() {\n    if (this.parent === null) return false; // Only the right-most child has no right sibling\n\n    return this.parent.children[this.parent.children.length - 1] !== this;\n  }\n  /**\r\n   * Get all nodes in the tree, that are in startLayer, endLayer or any layer in between. The layers are counted from this node onward. That is done to implement this method recursively, as users will mainly call it from the root only anyways.\r\n   \r\n   If startLayer is 0, this node is included in the result as well.\r\n   \r\n   Defaults to get all nodes in the tree, starting from layer 0 and going to layer Infinity (that is until the tree ended).\r\n   * @param {Number} startLayer The first layer to get nodes from\r\n   * @param {Number} endLayer The last layer to get nodes from\r\n   * @returns {Tree[]} List of Nodes in the specified range of layers.\r\n   */\n\n\n  getChildren() {\n    let startLayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let endLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n\n    if (startLayer === 0 && endLayer === 0) {\n      return [this];\n    } else if (startLayer === 0) {\n      let nodes = [this];\n      this.children.forEach(child => nodes.push(...child.getChildren(0, endLayer - 1)));\n      return nodes;\n    } else {\n      let nodes = [];\n      this.children.forEach(child => nodes.push(...child.getChildren(startLayer - 1, endLayer - 1)));\n      return nodes;\n    }\n  }\n  /**\r\n   * Get the Node with the specified id. If it doesn't exist in this Tree, `null` is returned instead.\r\n   * @param {Number} id The ID of the node to get\r\n   * @returns {?Tree}\r\n   */\n\n\n  getByID(id) {\n    if (this.id === id) return this;\n\n    for (let child of this.children) {\n      let res = child.getByID(id);\n      if (res !== null) return res;\n    }\n\n    return null;\n  }\n  /**\r\n   * Add a child-node to this node.\r\n   * @param {Tree} child The child to add to this tree\r\n   * @returns {Tree} The child that was added\r\n   */\n\n\n  addChild(child) {\n    var _child$parent;\n\n    child === null || child === void 0 ? void 0 : (_child$parent = child.parent) === null || _child$parent === void 0 ? void 0 : _child$parent.removeChild(child.id);\n    child.parent = this;\n    this.children.push(child);\n    return child;\n  }\n  /**\r\n   * Move a child-node to a new index in the children-array. This is specifically useful when children-order matters, like with certain tree-drawing algorithms.\r\n   * @param {Tree | Number} child The child to move or its ID.\r\n   * @param {Number} idx The new index that the child should be moved to.\r\n   * @returns\r\n   */\n\n\n  moveChildToIdx(child, idx) {\n    if (this.removeChild(child.id) === null) return false;\n    this.children.splice(idx, 0, child);\n    return true;\n  }\n  /**\r\n   * Change this node's parent.\r\n   * @param {?Tree} newParent The new parent of this node. If set to null, this system will have no parent.\r\n   */\n\n\n  changeParent() {\n    var _this$parent;\n\n    let newParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.removeChild(this.id);\n    newParent === null || newParent === void 0 ? void 0 : newParent.addChild(this);\n  }\n  /**\r\n   * Remove a child of this tree. To remove this node itself, set all references to it to `null` and let the garbage collector handle it. All children of the node will be removed as well, unless you save another reference to them before.\r\n   * @param {Number} id The ID of the node to remove\r\n   * @returns {?Tree} Returns the removed child or `null` if the child couldn't be found.\r\n   */\n\n\n  removeChild(id) {\n    let idx = this.children.findIndex(child => child.id === id);\n\n    if (idx === -1) {\n      for (let child of this.children) {\n        let res = child.removeChild(id);\n        if (res) return res;\n      }\n\n      return null;\n    } else {\n      let removedChild = this.children.splice(idx, 1)[0];\n      this.emit('childRemoved', removedChild, this);\n      return removedChild;\n    }\n  }\n\n}\n\nmodule.exports = Tree;\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/Tree.js?");

/***/ }),

/***/ "./src/Utils/Trie.js":
/*!***************************!*\
  !*** ./src/Utils/Trie.js ***!
  \***************************/
/***/ (function(module) {

eval("function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\n\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\n\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\n\nvar _allKeys = /*#__PURE__*/new WeakSet();\n\nvar _replacePrefix = /*#__PURE__*/new WeakSet();\n\nclass Trie {\n  constructor() {\n    _classPrivateMethodInitSpec(this, _replacePrefix);\n\n    _classPrivateMethodInitSpec(this, _allKeys);\n\n    /** @type {String[]} */\n    this.chars = [];\n    /** @type {Trie[]} */\n\n    this.tries = [];\n    /** @type {any} */\n\n    this.val = null;\n  }\n  /**\r\n   * Check if this Node is empty - i.e. has no children and no value and is therefore ready to be removed.\r\n   * @returns {boolean}\r\n   */\n\n\n  isEmpty() {\n    return this.chars.length === 0 && this.val === null;\n  }\n  /**\r\n   * Find the value associated with the name `str`\r\n   * @param {String} str Name of the Node\r\n   * @returns {?any} If the Node doesn't exist, `null` is returned\r\n   */\n\n\n  find(str) {\n    if (str === '') return this.val;\n    let idx = this.chars.indexOf(str[0]);\n    if (idx === -1) return null;else return this.tries[idx].find(str.substring(1));\n  }\n  /**\r\n   * Insert a new value associated with some name\r\n   * @param {String} str Name of the Node\r\n   * @param {any} val Value to associate with the name `str`\r\n   * @returns {Trie} Returns this Trie to allow chained calls\r\n   */\n\n\n  insert(str, val) {\n    if (str === '') {\n      this.val = val;\n      return this;\n    }\n\n    let idx = this.chars.indexOf(str[0]);\n\n    if (idx === -1) {\n      this.chars.push(str[0]);\n      this.tries.push(new Trie());\n      idx = this.chars.length - 1;\n    }\n\n    this.tries[idx].insert(str.substring(1), val);\n    return this;\n  }\n  /**\r\n   * Remove the Node associated with `str`\r\n   * @param {String} str Name of the Node\r\n   * @returns {boolean} Indicates whether the Node was successfully removed. Should only be `false` if the Node didn't exist.\r\n   */\n\n\n  delete(str) {\n    if (str === '') {\n      this.val = null;\n      return;\n    }\n\n    let idx = this.chars.indexOf(str[0]);\n    if (idx === -1) return;\n    this.tries[idx].delete(str.substring(1));\n\n    if (this.tries[idx].isEmpty()) {\n      this.chars.splice(idx, 1);\n      this.tries.splice(idx, 1);\n    }\n  } // For String Completion\n\n  /**\r\n   * Auxiliary function for #replacePrefix()\r\n   * @param {String} str\r\n   * @param {String} prefix\r\n   * @returns {String[]}\r\n   */\n\n\n  /**\r\n   * Find all keys in this Trie that start with `str`\r\n   * @param {String} str Prefix to search for\r\n   * @returns {String[]} Returns all valid names in the Trie that start with `str`\r\n   */\n  findPrefix(str) {\n    return _classPrivateMethodGet(this, _replacePrefix, _replacePrefix2).call(this, str, str);\n  }\n\n}\n\nfunction _allKeys2(str) {\n  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  let res = [];\n  if (this.val !== null) res.push(prefix);\n  this.chars.forEach((c, i) => {\n    var _this$tries$i;\n\n    res.push(..._classPrivateMethodGet(_this$tries$i = this.tries[i], _allKeys, _allKeys2).call(_this$tries$i, str, prefix + c));\n  });\n  return res;\n}\n\nfunction _replacePrefix2(str) {\n  var _this$tries$idx;\n\n  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  if (str === '') return _classPrivateMethodGet(this, _allKeys, _allKeys2).call(this, prefix);\n  let idx = this.chars.indexOf(str[0]);\n  if (idx === -1) return [];else return _classPrivateMethodGet(_this$tries$idx = this.tries[idx], _replacePrefix, _replacePrefix2).call(_this$tries$idx, str.substring(1), prefix);\n}\n\nmodule.exports = Trie;\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/Trie.js?");

/***/ }),

/***/ "./src/Utils/browserInfo.js":
/*!**********************************!*\
  !*** ./src/Utils/browserInfo.js ***!
  \**********************************/
/***/ (function(module) {

eval("module.exports = browserInfo();\n\nfunction browserInfo() {\n  if (typeof window === 'undefined' || !window.hasOwnProperty('navigator')) {\n    return {\n      browser: '',\n      version: '0'\n    };\n  }\n\n  let ua = window.navigator.userAgent.toLowerCase(),\n      // Useragent RegExp\n  rwebkit = /(webkit)[ \\/]([\\w.]+)/,\n      ropera = /(opera)(?:.*version)?[ \\/]([\\w.]+)/,\n      rmsie = /(msie) ([\\w.]+)/,\n      rmozilla = /(mozilla)(?:.*? rv:([\\w.]+))?/,\n      match = rwebkit.exec(ua) || ropera.exec(ua) || rmsie.exec(ua) || ua.indexOf('compatible') < 0 && rmozilla.exec(ua) || [];\n  return {\n    browser: match[1] || '',\n    version: match[2] || '0'\n  };\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/browserInfo.js?");

/***/ }),

/***/ "./src/Utils/documentEvents.js":
/*!*************************************!*\
  !*** ./src/Utils/documentEvents.js ***!
  \*************************************/
/***/ (function(module) {

eval("module.exports = createDocumentEvents();\n\nfunction createDocumentEvents() {\n  if (typeof document === undefined) {\n    return {\n      on: () => {},\n      off: () => {}\n    };\n  }\n\n  return {\n    on: on,\n    off: off\n  };\n}\n\nfunction on(eventName, handler) {\n  document.addEventListener(eventName, handler);\n}\n\nfunction off(eventName, handler) {\n  document.removeEventListener(eventName, handler);\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/documentEvents.js?");

/***/ }),

/***/ "./src/Utils/id.js":
/*!*************************!*\
  !*** ./src/Utils/id.js ***!
  \*************************/
/***/ (function(module) {

eval("globalIDCounter = 0;\n\nmodule.exports = function newID() {\n  return ++globalIDCounter;\n};\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/id.js?");

/***/ }),

/***/ "./src/Utils/random.js":
/*!*****************************!*\
  !*** ./src/Utils/random.js ***!
  \*****************************/
/***/ (function(module) {

eval("/**\n * Get a pseudo-random integer in the interval [start, end] (end is inclusive).\n * @param {number} end\n * @param {number} start Defaults to 0.\n * @returns {number}\n */\nfunction randint(end) {\n  let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return Math.floor(Math.random() * (end + 1)) + start;\n}\n\nmodule.exports = {\n  randint\n};\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/random.js?");

/***/ }),

/***/ "./src/Utils/svgHelper.js":
/*!********************************!*\
  !*** ./src/Utils/svgHelper.js ***!
  \********************************/
/***/ (function(module) {

eval("const svgns = 'http://www.w3.org/2000/svg';\nconst xlinkns = 'http://www.w3.org/1999/xlink';\n/**\n * Create a new SVG-Element. Optionally set attributes of the element immediately too.\n * @param {String} tagName Desired type of svg-element\n * @param {?Object<String, String>} attrs Object mapping attribute names to values. If `null`, no attributes are set. Defaults to `null`.\n * @returns {SVGElement}\n */\n\nfunction createEl(tagName) {\n  let attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let el = document.createElementNS(svgns, tagName);\n  if (attrs) setAttrs(el, attrs);\n  return el;\n}\n\nmodule.exports.createEl = createEl;\n/**\n * Append a child element to another element.\n * @param {SVGElement} el Parent Element\n * @param {SVGElement | String} child Child Element. If a String is given, a new Element with the specified tagName is created.\n * @returns {SVGElement} The appended child\n */\n\nfunction append(el, child) {\n  if (typeof child === 'string') child = createEl(child);\n  el.appendChild(child);\n  return child;\n}\n\nmodule.exports.append = append;\n/**\n * Set an SVG-Element's link attribute.\n * @param {SVGElement} el Element that gets linked from\n * @param {String} target Target URL\n * @returns {SVGElement}\n */\n\nfunction setLink(el, target) {\n  el.setAttributeNS(xlinkns, 'xlink:href', target);\n  return el;\n}\n\nmodule.exports.setLink = setLink;\n/**\n * Get the link-address currently targeted by `el`. Returns `null`, if `el` has no link attribute.\n * @param {SVGElement} el\n * @returns {?String}\n */\n\nfunction getLink(el) {\n  return el.getAttributeNS(xlinkns, 'xlink:href');\n}\n\nmodule.exports.getLink = getLink;\n/**\n * Set an attribute with a not further specified namespace.\n * @param {SVGElement} el\n * @param {String} name Attribute Name\n * @param {String} val Attribute Value\n * @returns {SVGElement}\n */\n\nfunction setAttr(el, name) {\n  let val = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (val !== null) el.setAttributeNS(null, name, val);else el.removeAttributeNS(null, name);\n  return el;\n}\n\nmodule.exports.setAttr = setAttr;\n/**\n * Set several attributes at once. This calls setAttr() for each attribute.\n * @param {SVGElement} el\n * @param {Object<String, String>} attrs Object mapping attribute names to values\n * @returns {SVGElement} The modified element\n */\n\nfunction setAttrs(el, attrs) {\n  for (let name in attrs) {\n    setAttr(el, name, attrs[name]);\n  }\n\n  return el;\n}\n\nmodule.exports.setAttrs = setAttrs;\n/**\n * Get the value associated with the specified attribute. Returns `null` if `el` has no attribute with the name `name`.\n * @param {SVGElement} el\n * @param {String} name Attribute Name\n * @returns {?String}\n */\n\nfunction getAttr(el, name) {\n  return el.getAttributeNS(null, name);\n}\n\nmodule.exports.getAttr = getAttr;\n/**\n * Create an Arrow Marker for a specified node-size. A marker should only be defined once in a <defs> child element of the root <svg> element.\n * @param {number} sideLength Length of the sides of the nodes that the arrow will point at\n * @param {string} id ID of the marker. This is used to refer to the marker again later. Defaults to `Arrow`.\n * @returns {SVGMarkerElement}\n */\n\nfunction createArrowMarker(sideLength) {\n  let id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Arrow';\n  let marker = createEl('marker');\n  setAttr(marker, 'id', id);\n  setAttr(marker, 'viewBox', \"0 0 \".concat(sideLength, \" \").concat(sideLength));\n  setAttr(marker, 'refX', \"\".concat(sideLength));\n  setAttr(marker, 'refY', \"\".concat(sideLength / 2));\n  setAttr(marker, 'markerUnits', 'strokeWidth');\n  setAttr(marker, 'markerWidth', \"\".concat(sideLength));\n  setAttr(marker, 'markerHeight', \"\".concat(sideLength / 2));\n  setAttr(marker, 'fill', '#333');\n  setAttr(marker, 'orient', 'auto');\n  let path = append(marker, 'path');\n  setAttr(path, 'd', \"M 0 0 L \".concat(sideLength, \" \").concat(sideLength / 2, \" L 0 \").concat(sideLength, \" z\"));\n  return marker;\n}\n\nmodule.exports.createArrowMarker = createArrowMarker;\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/svgHelper.js?");

/***/ }),

/***/ "./src/Utils/timer.js":
/*!****************************!*\
  !*** ./src/Utils/timer.js ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n */\nmodule.exports = createTimer();\n\nfunction createTimer() {\n  let lastTime = 0,\n      vendors = ['ms', 'moz', 'webkit', 'o'],\n      i,\n      scope;\n\n  if (typeof window !== 'undefined') {\n    scope = window;\n  } else if (typeof __webpack_require__.g !== 'undefined') {\n    scope = __webpack_require__.g;\n  } else {\n    scope = {\n      setTimeout: noop,\n      clearTimeout: noop\n    };\n  }\n\n  for (i = 0; i < vendors.length && !scope.requestAnimationFrame; ++i) {\n    let vendorPrefix = vendors[i];\n    scope.requestAnimationFrame = scope[vendorPrefix + 'RequestAnimationFrame'];\n    scope.cancelAnimationFrame = scope[vendorPrefix + 'CancelAnimationFrame'] || scope[vendorPrefix + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!scope.requestAnimationFrame) {\n    scope.requestAnimationFrame = rafPolyfill;\n  }\n\n  if (!scope.cancelAnimationFrame) {\n    scope.cancelAnimationFrame = cancelRafPolyfill;\n  }\n\n  return timer;\n  /**\r\n   * Timer that fires callback with given interval (in ms) until\r\n   * callback returns true;\r\n   */\n\n  function timer(callback) {\n    let intervalId;\n    startTimer(); // start it right away.\n\n    return {\n      /**\r\n       * Stops execution of the callback\r\n       */\n      stop: stopTimer,\n      restart: restart\n    };\n\n    function startTimer() {\n      intervalId = scope.requestAnimationFrame(startTimer);\n\n      if (!callback()) {\n        stopTimer();\n      }\n    }\n\n    function stopTimer() {\n      scope.cancelAnimationFrame(intervalId);\n      intervalId = 0;\n    }\n\n    function restart() {\n      if (!intervalId) {\n        startTimer();\n      }\n    }\n  }\n\n  function rafPolyfill(callback) {\n    let currTime = new Date().getTime();\n    let timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    let id = scope.setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  }\n\n  function cancelRafPolyfill(id) {\n    scope.clearTimeout(id);\n  }\n}\n\nfunction noop() {}\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/timer.js?");

/***/ }),

/***/ "./src/Views/SingleLayerView.js":
/*!**************************************!*\
  !*** ./src/Views/SingleLayerView.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const View = __webpack_require__(/*! ./View */ \"./src/Views/View.js\");\n\nclass SingleLayerView extends View {\n  constructor(layer) {\n    super();\n    this.layer = layer;\n  }\n\n  _isNodeVisible(node) {\n    return node.depth === this.layer;\n  }\n\n  getVisibleNodes(cached) {\n    if (!cached) {\n      let nodes = [];\n      this.graph.systemTrees.forEach(tree => {\n        nodes.push(...tree.getSystems(this.layer));\n      });\n      this.visibleNodes = nodes;\n    }\n\n    return this.visibleNodes;\n  }\n\n  _isEdgeVisible(edge) {\n    if (this._isNodeOrAncestorVisible(edge.source) && this._isNodeOrAncestorVisible(edge.target)) {\n      return true;\n    }\n  }\n\n}\n\nmodule.exports = SingleLayerView;\n\n//# sourceURL=webpack://vivagraphjs/./src/Views/SingleLayerView.js?");

/***/ }),

/***/ "./src/Views/View.js":
/*!***************************!*\
  !*** ./src/Views/View.js ***!
  \***************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const SystemLandscape = __webpack_require__(/*! ../Graphs/SystemLandscape */ \"./src/Graphs/SystemLandscape.js\");\n\nconst SystemNode = __webpack_require__(/*! ../Graphs/SystemNode */ \"./src/Graphs/SystemNode.js\");\n\nconst EventManager = __webpack_require__(/*! ../Utils/EventManager */ \"./src/Utils/EventManager.js\");\n\nconst NodeGroup = __webpack_require__(/*! ../Graphs/NodeGroup */ \"./src/Graphs/NodeGroup.js\");\n\nconst Edge = __webpack_require__(/*! ../Graphs/Edge */ \"./src/Graphs/Edge.js\"); // Expected API:\n// - init(SystemLandscaper)\n// - getVisibleNodes()\n//\t\tReturn Set/Array of all nodes that are visible\n\n\nclass View extends EventManager {\n  /**\n   * Base-View Class. Probably you want to use a subclass of this.\n   *\n   * Emitted Events:\n   * - \"[type]-add\"\n   * - \"[type]-remove\"\n   * - \"[type]-update\"\n   *\n   * where \"type\" is one of:\n   * - node\n   * - edge\n   * - group\n   */\n  constructor() {\n    super();\n    /** @type {?SystemLandscape} */\n\n    this.graph = null;\n    /** @type {SystemNode[]} */\n\n    this.visibleNodes = [];\n    /** @type {Edge[]} */\n\n    this.visibleEdges = [];\n    /** @type {NodeGroup} */\n\n    this.grouping = new NodeGroup();\n  }\n\n  init(graph) {\n    this.graph = graph;\n    this.graph.on('change', this._onGraphChange.bind(this)); // Populate visible nodes/edges for cache:\n\n    this.getVisibleNodes(false);\n    this.getVisibleEdges(false);\n    return this;\n  }\n\n  _onGraphChange(el, type) {\n    switch (type) {\n      case 'add':\n        if (el instanceof SystemNode) this._onNodeAdded(el);else if (el instanceof Edge) this._onEdgeAdded(el);else if (el instanceof SystemTree) this._onSystemTreeAdded(el);\n        break;\n\n      case 'remove':\n        if (el instanceof SystemNode) this._onNodeRemoved(el);else if (el instanceof Edge) this._onEdgeRemoved(el);else if (el instanceof SystemTree) this._onSystemTreeRemoved(el);\n        break;\n\n      case 'update':\n        if (el instanceof SystemNode) this._onNodeUpdated(el);else if (el instanceof Edge) this._onEdgeUpdated(el);else if (el instanceof SystemTree) this._onSystemTreeUpdated(el);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  _onNodeAdded(node) {\n    if (this._isNodeVisible(node)) {\n      this.visibleNodes.push(node);\n\n      this._addNodeToGroups(node);\n\n      this.emit('node-add', node);\n    }\n  }\n\n  _onNodeUpdated(node) {\n    if (this.visibleNodes.indexOf(node) !== -1) {\n      this.emit('node-update', node);\n    }\n  }\n\n  _onNodeRemoved(node) {\n    let idx = this.visibleNodes.indexOf(node);\n\n    if (idx !== -1) {\n      this.visibleNodes.splice(idx, 1);\n      this.groups.removeNode(node);\n      this.emit('node-remove', node);\n    }\n  }\n\n  _onEdgeAdded(edge) {\n    if (this._isEdgeVisible(edge)) {\n      this.visibleEdges.push(edge);\n      this.emit('edge-add', edge);\n    }\n  }\n\n  _onEdgeUpdated(edge) {\n    if (this.visibleEdges.indexOf(edge) !== -1) {\n      this.emit('edge-update', edge);\n    }\n  }\n\n  _onEdgeRemoved(edge) {\n    let idx = this.visibleEdges.indexOf(edge);\n\n    if (idx !== -1) {\n      this.visibleEdges.splice(idx, 1);\n      this.emit('edge-remove', edge);\n    }\n  }\n\n  _onSystemTreeAdded(systemTree) {\n    let g = new NodeGroup(systemTree.id, systemTree.name);\n    this.grouping.addGroups(g);\n    this.emit('group-add', g);\n  }\n\n  _onSystemTreeUpdated(systemTree) {\n    let g = this.grouping.findSubGroup(group => group.id === systemTree.id);\n\n    if (g) {\n      g.name = systemTree.name;\n      this.emit('group-update', g);\n    }\n  }\n\n  _onSystemTreeRemoved(systemTree) {\n    let g = this.grouping.removeSubGroup(systemTree.id);\n    this.emit('group-remove', g);\n  }\n  /**\n   * Check whether the specified node is visible or not. This function should be overwritten by children classes.\n   * @param {SystemNode} node\n   * @returns {boolean}\n   */\n\n\n  _isNodeVisible(node) {\n    return true; // For the base class, all nodes are visible\n  }\n\n  _isNodeOrAncestorVisible(node) {\n    if (this.visibleNodes.includes(node)) return true;else if (node !== null && node !== void 0 && node.parent) return this._isNodeOrAncestorVisible(node.parent);else return false;\n  }\n  /**\n   * Get a list of all Nodes that are visible in this view.\n   * @params {boolean} cached Wether to use the cached list or not. If not, the cache gets updated. Default: true\n   * @returns {SystemNode[]}\n   */\n\n\n  getVisibleNodes() {\n    let cached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!cached) this.visibleNodes = this.graph.getNodes().filter(this._isNodeVisible.bind(this));\n    return this.visibleNodes;\n  }\n  /**\n   *\n   * @param {SystemNode} node\n   */\n\n\n  _addNodeToGroups(node) {\n    let group = this.grouping.findSubGroup(group => {\n      var _node$systemTree;\n\n      return group.id === ((_node$systemTree = node.systemTree) === null || _node$systemTree === void 0 ? void 0 : _node$systemTree.id);\n    });\n    if (group) group.addNodes(node);else {\n      this.grouping.addGroups(new NodeGroup(node.systemTree.id, node.systemTree.name, {}, [node]));\n\n      this._onSystemTreeAdded(node.systemTree);\n    }\n  }\n  /**\n   * Check whether the specified node is visible or not. This function should be overwritten by children classes.\n   * @param {Edge} edge\n   * @returns {boolean}\n   */\n\n\n  _isEdgeVisible(edge) {\n    return true;\n  }\n  /**\n   * Get a list of all Edges that should be visible as edges/arrows in this view.\n   * @params {boolean} cached Wether to use the cached list or not. If not, the cache gets updated. Default: true\n   * @returns {Edge[]}\n   */\n\n\n  getVisibleEdges() {\n    let cached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!cached) this.visibleEdges = this.graph.edges.filter(this._isEdgeVisible.bind(this));\n    return this.visibleEdges;\n  }\n\n}\n\nmodule.exports = View;\n\n//# sourceURL=webpack://vivagraphjs/./src/Views/View.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// const Main = {\n// \t// TODO: Update Graph to use SystemLandscape\n// \tgraph: require('./Graphs/SystemLandscape.js'),\n// \tserializer: {\n// \t\t// TODO: Update Serializers\n// \t\tloadFromJSON: require('ngraph.fromjson'),\n// \t\tstoreToJSON: require('ngraph.tojson'),\n// \t},\n// \tGeom: {\n// \t\tintersect: require('gintersect'),\n// \t\tintersectRect: require('./Geom/intersectRect.js'),\n// \t\tRect: require('./Geom/rect.js'),\n// \t},\n// \tInput: {\n// \t\tdomInputManager: require('./Input/domInputManager.js'),\n// \t\tdragndrop: require('./Input/dragndrop.js'),\n// \t\tfindElementPosition: require('./Input/findElementPosition.js'),\n// \t\tgetDimension: require('./Input/getDimensions.js'),\n// \t},\n// \tUtils: {\n// \t\tdocumentEvents: require('./Utils/documentEvents.js'),\n// \t\tnullEvents: require('./Utils/nullEvents.js'),\n// \t\twindowEvents: require('./Utils/windowEvents.js'),\n// \t\ttimer: require('./Utils/timer.js'),\n// \t\tnewID: require('./Utils/id.js'),\n// \t\tEventManager: require('./Utils/EventManager.js'),\n// \t\tTrie: require('./Utils/Trie.js'),\n// \t\tTree: require('./Utils/Tree.js'),\n// \t\tExtendedSet: require('./Utils/ExtendedSet.js'),\n// \t},\n// \tLayout: {\n// \t\tforceDirected: require('ngraph.forcelayout'),\n// \t\tconstant: require('./Layout/constant.js'),\n// \t\tinteractive: require('./Layout/interactive.js'),\n// \t},\n// \tsvgGraphics: require('./svgGraphics.js'),\n// \trenderer: require('./renderer.js'),\n// \tsvg: require('simplesvg'),\n// \tbrowserInfo: require('./Utils/browserInfo.js'),\n// };\nconst SystemLandscape = __webpack_require__(/*! ./Graphs/SystemLandscape.js */ \"./src/Graphs/SystemLandscape.js\");\n\nconst Renderer = __webpack_require__(/*! ./Renderer.js */ \"./src/Renderer.js\");\n\nconst View = __webpack_require__(/*! ./Views/View.js */ \"./src/Views/View.js\");\n\nconst SingleLayerView = __webpack_require__(/*! ./Views/SingleLayerView.js */ \"./src/Views/SingleLayerView.js\");\n\nconst defaultLayout = __webpack_require__(/*! ./Layout/randLayout.js */ \"./src/Layout/randLayout.js\");\n\nconst Main = {\n  Graph: SystemLandscape,\n  views: {\n    View: View,\n    SingleLayerView: SingleLayerView\n  },\n  Layouts: {\n    defaultLayout: defaultLayout\n  },\n  Renderer: Renderer\n};\n__webpack_require__.g.SystemMapper = Main;\nmodule.exports = Main;\n\n//# sourceURL=webpack://vivagraphjs/./src/main.js?");

/***/ }),

/***/ "./node_modules/gintersect/index.js":
/*!******************************************!*\
  !*** ./node_modules/gintersect/index.js ***!
  \******************************************/
/***/ (function(module) {

eval("module.exports = intersect;\n\n/**\n * Original authors: Mukesh Prasad, Appeared in Graphics Gem II book\n * http://www.opensource.apple.com/source/graphviz/graphviz-498/graphviz/dynagraph/common/xlines.c\n * and adopted to javascript version by Andrei Kashcha.\n *\n * This function computes whether two line segments,\n * respectively joining the input points (x1,y1) -- (x2,y2)\n * and the input points (x3,y3) -- (x4,y4) intersect.\n * If the lines intersect, the output variables x, y are\n * set to coordinates of the point of intersection.\n *\n * @param {Number} x1 First line segment coordinates\n * @param {Number} y1 First line segment coordinates\n * @param {Number} x2 First line segment coordinates\n * @param {Number} x2 First line segment coordinates\n *\n * @param {Number} x3 Second line segment coordinates\n * @param {Number} y3 Second line segment coordinates\n * @param {Number} x4 Second line segment coordinates\n * @param {Number} x4 Second line segment coordinates\n *\n * @return {Object} x, y coordinates of intersection point or falsy value if no\n * intersection found..\n */\nfunction intersect(\n  x1, y1, x2, y2, // first line segment\n  x3, y3, x4, y4  // second line segment\n) {\n\n  var a1, a2, b1, b2, c1, c2, /* Coefficients of line eqns. */\n    r1, r2, r3, r4, /* 'Sign' values */\n    denom, offset, num, /* Intermediate values */\n    result = {\n      x: 0,\n      y: 0\n    };\n\n  /* Compute a1, b1, c1, where line joining points 1 and 2\n   * is \"a1 x  +  b1 y  +  c1  =  0\".\n   */\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2;\n\n  /* Compute r3 and r4.\n   */\n  r3 = a1 * x3 + b1 * y3 + c1;\n  r4 = a1 * x4 + b1 * y4 + c1;\n\n  /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\n   * same side of line 1, the line segments do not intersect.\n   */\n\n  if (r3 !== 0 && r4 !== 0 && ((r3 >= 0) === (r4 >= 4))) {\n    return null; //no intersection.\n  }\n\n  /* Compute a2, b2, c2 */\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4;\n\n  /* Compute r1 and r2 */\n\n  r1 = a2 * x1 + b2 * y1 + c2;\n  r2 = a2 * x2 + b2 * y2 + c2;\n\n  /* Check signs of r1 and r2.  If both point 1 and point 2 lie\n   * on same side of second line segment, the line segments do\n   * not intersect.\n   */\n  if (r1 !== 0 && r2 !== 0 && ((r1 >= 0) === (r2 >= 0))) {\n    return null; // no intersection;\n  }\n  /* Line segments intersect: compute intersection point.\n   */\n\n  denom = a1 * b2 - a2 * b1;\n  if (denom === 0) {\n    return null; // Actually collinear..\n  }\n\n  offset = denom < 0 ? -denom / 2 : denom / 2;\n  offset = 0.0;\n\n  /* The denom/2 is to get rounding instead of truncating.  It\n   * is added or subtracted to the numerator, depending upon the\n   * sign of the numerator.\n   */\n  num = b1 * c2 - b2 * c1;\n  result.x = (num < 0 ? num - offset : num + offset) / denom;\n\n  num = a2 * c1 - a1 * c2;\n  result.y = (num < 0 ? num - offset : num + offset) / denom;\n\n  return result;\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/gintersect/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;