/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/add-event-listener/index.js":
/*!**************************************************!*\
  !*** ./node_modules/add-event-listener/index.js ***!
  \**************************************************/
/***/ (function(module) {

eval("addEventListener.removeEventListener = removeEventListener\naddEventListener.addEventListener = addEventListener\n\nmodule.exports = addEventListener\n\nvar Events = null\n\nfunction addEventListener(el, eventName, listener, useCapture) {\n  Events = Events || (\n    document.addEventListener ?\n    {add: stdAttach, rm: stdDetach} :\n    {add: oldIEAttach, rm: oldIEDetach}\n  )\n  \n  return Events.add(el, eventName, listener, useCapture)\n}\n\nfunction removeEventListener(el, eventName, listener, useCapture) {\n  Events = Events || (\n    document.addEventListener ?\n    {add: stdAttach, rm: stdDetach} :\n    {add: oldIEAttach, rm: oldIEDetach}\n  )\n  \n  return Events.rm(el, eventName, listener, useCapture)\n}\n\nfunction stdAttach(el, eventName, listener, useCapture) {\n  el.addEventListener(eventName, listener, useCapture)\n}\n\nfunction stdDetach(el, eventName, listener, useCapture) {\n  el.removeEventListener(eventName, listener, useCapture)\n}\n\nfunction oldIEAttach(el, eventName, listener, useCapture) {\n  if(useCapture) {\n    throw new Error('cannot useCapture in oldIE')\n  }\n\n  el.attachEvent('on' + eventName, listener)\n}\n\nfunction oldIEDetach(el, eventName, listener, useCapture) {\n  el.detachEvent('on' + eventName, listener)\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/add-event-listener/index.js?");

/***/ }),

/***/ "./src/Geom/intersectRect.js":
/*!***********************************!*\
  !*** ./src/Geom/intersectRect.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var intersect = __webpack_require__(/*! gintersect */ \"./node_modules/gintersect/index.js\");\n\nmodule.exports = intersectRect;\n\nfunction intersectRect(left, top, right, bottom, x1, y1, x2, y2) {\n  return intersect(left, top, left, bottom, x1, y1, x2, y2) || intersect(left, bottom, right, bottom, x1, y1, x2, y2) || intersect(right, bottom, right, top, x1, y1, x2, y2) || intersect(right, top, left, top, x1, y1, x2, y2);\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/Geom/intersectRect.js?");

/***/ }),

/***/ "./src/Geom/rect.js":
/*!**************************!*\
  !*** ./src/Geom/rect.js ***!
  \**************************/
/***/ (function(module) {

eval("module.exports = Rect;\n/**\r\n * Very generic rectangle.\r\n */\n\nfunction Rect(x1, y1, x2, y2) {\n  this.x1 = x1 || 0;\n  this.y1 = y1 || 0;\n  this.x2 = x2 || 0;\n  this.y2 = y2 || 0;\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/Geom/rect.js?");

/***/ }),

/***/ "./src/Graphs/Edge.js":
/*!****************************!*\
  !*** ./src/Graphs/Edge.js ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const EventManager = __webpack_require__(/*! ../Utils/EventManager.js */ \"./src/Utils/EventManager.js\");\n\nconst nextID = __webpack_require__(/*! ../Utils/id.js */ \"./src/Utils/id.js\");\n\nclass Edge extends EventManager {\n  /**\n   * Create a new Edge to connect to Nodes. This class offers certain events to listen to changes:\n   \n   - `sourceChanged`: When the source of this edge changes. Args: `(newSourceID, edge)`\n   - `targetChanged`: When the target of this edge changes. Args: `(newTargetID, edge)`\n   - `dataChanged`: When the data of this edge changes. Args: `(updatedData, edge)`\n   - `update`: When any of the above events occurs. Args: `(...args of the event - this edge is always the second argument)`\n   * @param {Number} source ID of the source node\n   * @param {Number} target ID of the target node\n   * @param {any} data Data associated with this edge. Defaults to an empty object.\n   */\n  constructor(source, target) {\n    var _this;\n\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    _this = this;\n    this.id = nextID();\n    this.source = source;\n    this.target = target;\n    this.data = data || {};\n    this.on('sourceChanged', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _this.emit('update', ...args);\n    });\n    this.on('targetChanged', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return _this.emit('update', ...args);\n    });\n    this.on('dataChanged', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return _this.emit('update', ...args);\n    });\n  }\n\n  get fromId() {\n    return this.source.id;\n  }\n\n  get toId() {\n    return this.target.id;\n  }\n\n  setSource(source) {\n    this.source = source;\n    this.emit('sourceChanged', source, this);\n  }\n\n  setTarget(target) {\n    this.target = target;\n    this.emit('targetChanged', target, this);\n  }\n\n  setData(data) {\n    this.data = data;\n    this.emit('dataChanged', this.data, this);\n  }\n\n  updateData(data) {\n    this.data = { ...this.data,\n      ...data\n    };\n    this.emit('dataChanged', this.data, this);\n  }\n\n}\n\nmodule.exports = Edge;\n\n//# sourceURL=webpack://vivagraphjs/./src/Graphs/Edge.js?");

/***/ }),

/***/ "./src/Graphs/SystemLandscape.js":
/*!***************************************!*\
  !*** ./src/Graphs/SystemLandscape.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const newID = __webpack_require__(/*! ../Utils/id */ \"./src/Utils/id.js\");\n\nconst Trie = __webpack_require__(/*! ../Utils/Trie */ \"./src/Utils/Trie.js\");\n\nconst EventManager = __webpack_require__(/*! ../Utils/EventManager */ \"./src/Utils/EventManager.js\");\n\nconst XSet = __webpack_require__(/*! ../Utils/ExtendedSet */ \"./src/Utils/ExtendedSet.js\");\n\nconst SystemTree = __webpack_require__(/*! ./SystemTree */ \"./src/Graphs/SystemTree.js\");\n\nconst SystemNode = __webpack_require__(/*! ./SystemNode */ \"./src/Graphs/SystemNode.js\");\n\nconst Edge = __webpack_require__(/*! ./Edge */ \"./src/Graphs/Edge.js\"); // Expected API:\n// \t\t- addNode(node: NodeId, data?: NodeData) => Node<NodeData>\n// \t\t- addLink(from: NodeId, to: NodeId, data?: LinkData) => Link<LinkData>\n// - removeNode(node: NodeId) => boolean\n// - removeLink(link: LinkId) => boolean\n// \t\t- getNode(node: NodeId) => Node<NodeData> | undefined\n// \t\t- getLink(fromNodeId: NodeId, toNodeId: NodeId) => Link<LinkData> | undefined // TODO: null instead of undefined returned\n// \t\t- hasLink(fromNodeId: NodeId, toNodeId: NodeId) => Link<LinkData> | undefined // TODO: Returns Boolean\n// \t\t- getNodesCount() => number\n// \t\t- getNodeCount() = getNodesCount()\n// \t\t- getLinksCount() => number\n// \t\t- getLinkCount() = getLinksCount()\n// \t\t- getLinks(nodeId: NodeId) => Set<Link<LinkData>> | null // TODO: Different name\n// - forEachNode(callback: (node: Node<NodeData>) => void) => void\n// - forEachLink(callback: (link: Link<LinkData>) => void) => void\n// - forEachLinkedNode(nodeId: NodeId, callback: (node: Node<NodeData>, link: Link<LinkData>) => void) => void, oriented: boolean) => void\n// - beginUpdate() => void\n// - endUpdate() => void\n// - clear() => void\n// export default function createGraph<NodeData = any, LinkData = any>(options?: { multigraph: boolean }): Graph<NodeData, LinkData> & EventedType\n// TODO: Add Events for Renderer to listen to\n\n\nclass SystemLandscape extends EventManager {\n  constructor() {\n    super();\n    this.id = newID();\n    this.systemTrees = [];\n    this.systemsByName = new Trie();\n    this.systemsByID = new Map();\n    this.edges = [];\n  } // Checks\n\n\n  hasSystem(id) {\n    return this.systemsByID.has(id);\n  }\n\n  hasEdgeId(id) {\n    return this.getEdgeId(id) !== null;\n  }\n\n  hasEdge() {\n    let from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return this.getEdge(from, to) !== null;\n  }\n\n  isVerticalEdge(edge) {\n    var _edge$source, _edge$target;\n\n    return ((_edge$source = edge.source) === null || _edge$source === void 0 ? void 0 : _edge$source.systemTree) === ((_edge$target = edge.target) === null || _edge$target === void 0 ? void 0 : _edge$target.systemTree);\n  }\n\n  sameNode(a, b) {\n    if (!(a instanceof SystemNode)) a = this.getSystem(a);\n    if (!(b instanceof SystemNode)) b = this.getSystem(b);\n    return a.id === b.id;\n  } // Getting Data\n\n  /**\r\n   * Get the system uniquely identified by its ID or name.\r\n   * @param {Number|String|SystemNode} id The unique ID or name of the system. If the system itself is inputted, it is simply returned.\r\n   * @returns {?SystemNode}\r\n   */\n\n\n  getSystem(id) {\n    if (id instanceof SystemNode) return id;\n    if (typeof id === 'string') return this.getSystemByName(id);\n    if (this.hasSystem(id)) return this.systemsByID.get(id);else return null;\n  }\n\n  getNode(id) {\n    return this.getSystem(id);\n  }\n\n  getSystemTree(id) {\n    return this.systemTrees.find(tree => tree.id === id);\n  }\n\n  getSystems() {\n    let startLayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let endLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startLayer;\n    let flatten = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let res = this.systemTrees.map(tree => tree.getSystems(startLayer, endLayer));\n    if (flatten) return res.flat(1);else return res;\n  }\n\n  getSystemsByName(name) {\n    return this.systemsByName.findPrefix(name);\n  }\n\n  getSystemByName(name) {\n    return this.systemsByName.find(name);\n  }\n\n  getEdgesOfSystem(systemID) {\n    let horizontal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let vertical = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let includeLinksOfChildren = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let links = new Set();\n    if (!this.hasSystem(systemID)) return links;\n\n    if (horizontal) {\n      this.edges.forEach(edge => {\n        if (edge.source === systemID || edge.target === systemID) links.add(edge.id);\n      });\n    }\n\n    if (vertical) {\n      this.getSystem(systemID).getVerticalLinks().forEach(edge => links.add(edge.id));\n    }\n\n    if (includeLinksOfChildren) {\n      this.getSystem(systemID).getChildren().forEach(child => {\n        this.getEdgesOfSystem(child.id, horizontal, vertical, false).forEach(edge => links.add(edge.id));\n      });\n    }\n\n    return links;\n  }\n\n  getEdgeId(id) {\n    if (id instanceof Edge) return id;\n    return this.edges.find(edge => edge.id === id);\n  }\n\n  getLinkId(id) {\n    return this.getEdgeId(id);\n  }\n\n  getEdge(from, to) {\n    return this.edges.find(edge => {\n      if (!this.sameNode(edge.source, from)) return false;\n      if (!this.sameNode(edge.target, to)) return false;\n      return true;\n    });\n  }\n\n  getLink(from, to) {\n    return this.getEdge(from, to);\n  }\n\n  getSystemsCount() {\n    return this.systemsByID.size;\n  }\n\n  getNodesCount() {\n    return this.getSystemsCount();\n  }\n\n  getNodeCount() {\n    return this.getSystemsCount();\n  }\n\n  getSystemTreesCount() {\n    return this.systemTrees.length;\n  }\n\n  getTreesCount() {\n    return this.getSystemTreesCount();\n  }\n\n  getEdgesCount() {\n    return this.edges.length;\n  }\n\n  getLinksCount() {\n    return this.getEdgesCount();\n  }\n\n  getLinkCount() {\n    return this.getEdgesCount();\n  } // Event Handling\n\n  /**\r\n   * This function exists currently purely to integrate with the renderer. Before optimizing this, the renderer would have to be changed as well.\r\n   * @param {SystemNode|SystemTree|Edge} element element that updated\r\n   * @param {'add'|'update'|'remove'} changeType type of change\r\n   */\n\n\n  emitChange(element, changeType) {\n    let change = {\n      changeType\n    };\n    if (element instanceof SystemNode) change.node = element;else if (element instanceof Edge) change.edge = element;\n    this.emit('changed', [change]);\n  }\n\n  onVerticalEdgeAdded(edge, parent, child) {\n    this.addEdge(edge);\n  }\n\n  onVerticalEdgeRemoved(edge, parent, child) {\n    this.edges.splice(this.edges.indexOf(edge), 1);\n    this.emitChange(edge, 'remove');\n  }\n\n  onSystemTreeChanged(systemTree, node) {\n    // TODO\n    if (systemTree.isEmpty()) {\n      this.systemTrees.splice(this.systemTrees.indexOf(systemTree), 1);\n    }\n  }\n\n  addEventListenersToSystem(system) {\n    var _this = this;\n\n    system.on('edgeAdded', function () {\n      return _this.onVerticalEdgeAdded(...arguments);\n    });\n    system.on('edgeRemoved', function () {\n      return _this.onVerticalEdgeRemoved(...arguments);\n    });\n    system.on('systemTreeChanged', function () {\n      return _this.onSystemTreeChanged(...arguments);\n    });\n  }\n\n  addEventListenersToSystemTree(tree) {// TODO\n  } // Adding Data\n\n\n  addSystem() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (typeof parent === 'string') parent = this.getSystemByName(parent);\n    let system = new SystemNode(name, parent, data);\n    if (name === null) name = String(system.id);\n    this.systemsByName.insert(name, system);\n    this.systemsByID.set(system.id, system);\n\n    if (!system.systemTree) {\n      let tree = new SystemTree(system);\n      this.systemTrees.push(tree);\n      this.addEventListenersToSystemTree(tree);\n    }\n\n    this.addEventListenersToSystem(system);\n    this.emitChange(system, 'add');\n    return system;\n  }\n\n  addEdge(edge) {\n    this.edges.push(edge);\n    this.emit('edgeAdded', edge, this.isVerticalEdge(edge));\n    this.emitChange(edge, 'add');\n    return edge;\n  }\n  /**\r\n   * Create a new edge to link two systems/systemTrees. If the systems are not in the landscape, they will be added. If an edge between the two systems already exists, it will be returned.\r\n   * @param {?SystemNode|SystemTree} from SystemNode or SystemTree from which the edge comes from\r\n   * @param {?SystemNode|SystemTree} to SystemNode or SystemTree to which the edge goes to\r\n   * @param {any} data Data associated with the edge\r\n   */\n\n\n  linkSystems(from, to) {\n    var _from, _to;\n\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let edge = this.getEdge(from, to);\n\n    if (edge) {\n      edge.changeData(data);\n      return edge;\n    }\n\n    from = this.getSystem(from);\n    to = this.getSystem(to);\n    if (!this.hasSystem((_from = from) === null || _from === void 0 ? void 0 : _from.id)) from = this.addSystem();\n    if (!this.hasSystem((_to = to) === null || _to === void 0 ? void 0 : _to.id)) to = this.addSystem();\n    edge = new Edge(from, to, data);\n    this.addEdge(edge);\n    return edge;\n  }\n\n  linkSystemsUndirected(system1, system2, data) {\n    this.linkSystems(system1, system2, data);\n    this.linkSystems(system2, system1, data); // TODO: Anything else to do?\n  } // Removing Data\n\n\n  removeSystem(id) {\n    let sys = this.getSystem(id);\n    this.systemsByID.delete(id);\n    this.systemsByName.delete(sys.name);\n    this.emit('systemRemoved', sys);\n    this.emitChange(sys, 'remove');\n  }\n\n  removeEdge(id) {\n    let keepBidirectional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let edge = this.getEdgeId(id);\n\n    if (keepBidirectional) {\n      let edge2 = this.getEdge(edge.target, edge.source);\n\n      if (edge2) {\n        this.removeEdge(edge2, false);\n      }\n    }\n\n    let isVertical = this.isVerticalEdge(edge);\n\n    if (isVertical) {\n      this.getSystem(edge.source).removeChild(edge.target.id);\n    }\n\n    let idx = this.edges.findIndex(e => e.id === edge.id); // console.log(edge, idx, this.edges[idx]);\n\n    if (idx === -1) return false;\n    this.edges.splice(idx, 1);\n    this.emit('edgeRemoved', edge, isVertical);\n    this.emitChange(edge, 'remove');\n    return true;\n  } // Updating Data\n\n\n  updateSystemName(id, newName) {\n    let sys = this.getSystem(id);\n    this.systemsByName.delete(sys.name);\n    this.systemsByName.insert(newName, sys);\n    sys.name = newName;\n    this.emitChange(sys, 'update');\n  }\n\n  updateSystem(id, data) {\n    let sys = this.getSystem(id);\n\n    if (data !== null && data !== void 0 && data.name) {\n      this.updateSystemName(sys, data.name);\n      delete data.name;\n    }\n\n    sys.data = { ...sys.data,\n      ...data\n    };\n    this.emitChange(sys, 'update');\n    return sys;\n  }\n\n  updateEdge(id, data) {\n    let edge = this.getEdgeId(id);\n    edge.data = { ...edge.data,\n      ...data\n    };\n    this.emitChange(edge, 'update');\n    return edge;\n  } // Moving Data\n\n\n  moveSystem(id) {\n    let newParentId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let system = this.getSystem(id);\n    if (!system) return false; // Edge from old parent should be removed automatically via event listeners\n\n    let newParent = newParentId === null ? null : this.getSystem(newParentId);\n\n    if (newParent) {\n      newParent.addChild(system); // New Edge from new Parent should be added automatically via event listeners\n    } else {\n      // If there's no new parent, the system should have its own systemTree created\n      let tree = new SystemTree(system);\n      this.systemTrees.push(tree);\n    }\n\n    this.emitChange(system, 'update'); // TODO: Test if \"update\" works here\n  }\n\n  moveEdgeId(id) {\n    let newSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let newTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let keepBidirectional = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let edge = this.getEdgeId(id);\n    return this.moveEdge(edge, newSource, newTarget, keepBidirectional);\n  }\n\n  moveEdge(edge) {\n    let newSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let newTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let keepBidirectional = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (!edge) return false;\n\n    if (keepBidirectional) {\n      let otherEdge = this.getEdge(edge.target, edge.source);\n\n      if (otherEdge) {\n        this.moveEdge(otherEdge, newTarget, newSource, false);\n      }\n    }\n\n    let newSourceNode = newSource === null ? edge.source : this.getSystem(newSource);\n    let newTargetNode = newTarget === null ? edge.target : this.getSystem(newTarget);\n    let wasVertical = this.isVerticalEdge(edge);\n\n    if (wasVertical) {\n      var _edge$source2;\n\n      (_edge$source2 = edge.source) === null || _edge$source2 === void 0 ? void 0 : _edge$source2.removeChild(edge.target.id);\n    }\n\n    edge.source = newSourceNode;\n    edge.target = newTargetNode;\n    let isVertical = this.isVerticalEdge(edge);\n\n    if (isVertical) {\n      var _edge$source3;\n\n      (_edge$source3 = edge.source) === null || _edge$source3 === void 0 ? void 0 : _edge$source3.addChild(edge.target.id);\n    }\n\n    this.emit('edgeMoved', edge, wasVertical, isVertical);\n    this.emitChange(edge, 'update'); // TODO: Test if \"update\" works here\n\n    return true;\n  } // Looping\n\n\n  forEachSystem(callback) {\n    return this.forEachNode(callback);\n  }\n\n  forEachNode(callback) {\n    this.systemsByID.forEach(node => callback(node));\n  }\n\n  forEachEdge(callback) {\n    this.edges.forEach(edge => callback(edge));\n  }\n\n  forEachLink(callback) {\n    return this.forEachEdge(callback);\n  } // Positioning\n\n\n  positionSystem(id, x, y) {// TODO\n  }\n\n  positionSystemTree(id, x, y) {// TODO\n  }\n\n  automaticLayout(layout) {// TODO\n  }\n\n  positionEdge(params) {// TODO\n  } // Saving / Loading\n\n\n  save(format) {// TODO\n\n    let location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  }\n\n  load(location) {// TODO\n\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  }\n\n  saveView(name) {// TODO\n  }\n\n  deleteView(name) {// TODO\n  }\n\n  goBack() {// TODO\n\n    let steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  }\n\n  goForward() {// TODO\n\n    let steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  }\n\n}\n\nmodule.exports = () => new SystemLandscape();\n\n//# sourceURL=webpack://vivagraphjs/./src/Graphs/SystemLandscape.js?");

/***/ }),

/***/ "./src/Graphs/SystemNode.js":
/*!**********************************!*\
  !*** ./src/Graphs/SystemNode.js ***!
  \**********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const Tree = __webpack_require__(/*! ../Utils/Tree */ \"./src/Utils/Tree.js\");\n\nconst Edge = __webpack_require__(/*! ./Edge */ \"./src/Graphs/Edge.js\");\n\nclass SystemNode extends Tree {\n  /**\r\n   * Create a new SystemNode. SystemNodes represent single systems in a tree-like hierachy of systems. To connect several systems (or systemTrees) together, you need to use the SystemLandscape class.\r\n   * @param {?SystemNode} parent The parent of this tree-node\r\n   * @param {any} data Data associated with this node\r\n   */\n  constructor() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(null, data);\n    this.name = name;\n    this.systemTree = parent instanceof SystemNode ? parent.systemTree : null;\n    this.edgesToChildren = [];\n    /** @type {?SystemNode} (For documentation only, remove this and use typescript type-annotations instead in the future) */\n\n    this.parent;\n    this.changeParent(parent);\n  } // Getting Data\n\n\n  getEdge(toId) {\n    return this.edgesToChildren.find(edge => edge.target === toId);\n  }\n\n  getVerticalLinks() {\n    let includeLinkFromParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let res = [];\n    if (includeLinkFromParent && this.parent) res.push(this.parent.getEdge(this.id));\n    res.push(...this.edgesToChildren);\n    return res;\n  } // Updating Data\n\n\n  changeSystemTree(systemTree) {\n    this.systemTree = systemTree;\n    this.emit('systemTreeChanged', systemTree, this);\n    this.children.forEach(child => child.changeSystemTree(systemTree));\n  } // Adding Data\n\n\n  addChild(child) {\n    super.addChild(child);\n    child.changeSystemTree(this.systemTree);\n    const edge = new Edge(this, child);\n    this.edgesToChildren.push(edge);\n    this.emit('edgeAdded', edge, this, child);\n    return child;\n  } // Removing Data\n\n\n  removeChild(id) {\n    let c = super.removeChild(id);\n\n    if (c) {\n      let idx = this.edgesToChildren.findIndex(edge => edge.target !== id);\n      this.emit('edgeRemoved', this.edgesToChildren[idx], this, c);\n      this.edgesToChildren.splice(idx, 1);\n    }\n\n    return c;\n  }\n\n}\n\nmodule.exports = SystemNode;\n\n//# sourceURL=webpack://vivagraphjs/./src/Graphs/SystemNode.js?");

/***/ }),

/***/ "./src/Graphs/SystemTree.js":
/*!**********************************!*\
  !*** ./src/Graphs/SystemTree.js ***!
  \**********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const EventManager = __webpack_require__(/*! ../Utils/EventManager */ \"./src/Utils/EventManager.js\");\n\nconst newID = __webpack_require__(/*! ../Utils/id */ \"./src/Utils/id.js\");\n\nconst SystemNode = __webpack_require__(/*! ./SystemNode */ \"./src/Graphs/SystemNode.js\"); // require('./System) can't be called at the top:\n// https://stackoverflow.com/questions/29023320/resolving-circular-dependency-in-nodejs-model\n// Solution: require('./System') inside each function that needs access to it.\n// Another solution would be to not use class syntax but function prototypes\n// That would work since Classes are technically just syntactic sugar\n// Problem with that is the difficult use of \"this\":\n// https://stackoverflow.com/a/20279485/13764271\n\n\nclass SystemTree extends EventManager {\n  /**\r\n   * Create a new SystemTree object. SystemTrees store the tree-like structure of systems and allows easy interaction with them. This class also adds events to listen to changes in the tree.\r\n   * @param {?SystemNode} root Root node of the systemTree.\r\n   * @param {any} data Data to store with the systemTree.\r\n   */\n  constructor() {\n    let root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.id = newID();\n    this.data = data || {};\n    this.root = root;\n    if (this.root instanceof SystemNode) this.root.changeSystemTree(this);\n  } // Checks\n\n\n  isEmpty() {\n    return !this.root && Object.keys(this.data).length === 0;\n  } // Getting Data\n\n\n  getSystems() {\n    var _this$root$getChildre, _this$root;\n\n    let startLayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let endLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startLayer;\n    return (_this$root$getChildre = (_this$root = this.root) === null || _this$root === void 0 ? void 0 : _this$root.getChildren(startLayer, endLayer)) !== null && _this$root$getChildre !== void 0 ? _this$root$getChildre : [];\n  }\n\n  getSystem(id) {\n    var _this$root$getByID, _this$root2;\n\n    return (_this$root$getByID = (_this$root2 = this.root) === null || _this$root2 === void 0 ? void 0 : _this$root2.getByID(id)) !== null && _this$root$getByID !== void 0 ? _this$root$getByID : null;\n  }\n\n  getEdge(toId) {\n    var _this$root$getEdge, _this$root3;\n\n    return (_this$root$getEdge = (_this$root3 = this.root) === null || _this$root3 === void 0 ? void 0 : _this$root3.getEdge(toId)) !== null && _this$root$getEdge !== void 0 ? _this$root$getEdge : null;\n  }\n\n  getEdgesFrom(fromId) {\n    var _this$getVerticalLink;\n\n    return (_this$getVerticalLink = this.getVerticalLinks(fromId, false)) !== null && _this$getVerticalLink !== void 0 ? _this$getVerticalLink : [];\n  }\n\n  getVerticalLinks() {\n    var _node$getVerticalLink;\n\n    let nodeId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let includeLinkFromParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let node = nodeId ? this.getSystem(nodeId) : this.root;\n    return (_node$getVerticalLink = node === null || node === void 0 ? void 0 : node.getVerticalLinks(includeLinkFromParent)) !== null && _node$getVerticalLink !== void 0 ? _node$getVerticalLink : [];\n  } // Adding Data\n\n\n  addChild(system) {\n    this.addSystem(system);\n  }\n\n  addSystem(system) {// TODO\n\n    let parentId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  } // Updating Data\n\n  /**\r\n   * Change the Parent of a system in this tree.\r\n   * @param {Number} systemId ID of the system to change the parent of\r\n   * @param {?SystemTree} newParent The new parent of this system. If set to null, the system will have no parent.\r\n   * @returns {Boolean} Indicates whether the system was found and the parent could thus be changed.\r\n   */\n\n\n  changeParent(systemId) {\n    let newParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let system = this.getSystem(systemId);\n    if (!system) return false;\n    system === null || system === void 0 ? void 0 : system.changeParent(newParent);\n    return true;\n  } // Removing Data\n\n\n  removeChild(id) {\n    return this.removeSystem(id);\n  }\n\n  removeSystem(systemId) {\n    let system = this.getSystem(systemId);\n    if (!system) return false;\n    system.parent.removeChild(system.id);\n    return true;\n  }\n\n}\n\nmodule.exports = SystemTree;\n\n//# sourceURL=webpack://vivagraphjs/./src/Graphs/SystemTree.js?");

/***/ }),

/***/ "./src/Input/domInputManager.js":
/*!**************************************!*\
  !*** ./src/Input/domInputManager.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n */\nmodule.exports = domInputManager;\n\nvar dragndrop = __webpack_require__(/*! ./dragndrop.js */ \"./src/Input/dragndrop.js\");\n\nfunction domInputManager(graph, graphics) {\n  var nodeEvents = {};\n  return {\n    /**\r\n     * Called by renderer to listen to drag-n-drop events from node. E.g. for SVG\r\n     * graphics we may listen to DOM events, whereas for WebGL the graphics\r\n     * should provide custom eventing mechanism.\r\n     *\r\n     * @param node - to be monitored.\r\n     * @param handlers - object with set of three callbacks:\r\n     *   onStart: function(),\r\n     *   onDrag: function(e, offset),\r\n     *   onStop: function()\r\n     */\n    bindDragNDrop: bindDragNDrop\n  };\n\n  function bindDragNDrop(node, handlers) {\n    var events;\n\n    if (handlers) {\n      var nodeUI = graphics.getNodeUI(node.id);\n      events = dragndrop(nodeUI);\n\n      if (typeof handlers.onStart === 'function') {\n        events.onStart(handlers.onStart);\n      }\n\n      if (typeof handlers.onDrag === 'function') {\n        events.onDrag(handlers.onDrag);\n      }\n\n      if (typeof handlers.onStop === 'function') {\n        events.onStop(handlers.onStop);\n      }\n\n      nodeEvents[node.id] = events;\n    } else if (events = nodeEvents[node.id]) {\n      events.release();\n      delete nodeEvents[node.id];\n    }\n  }\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/Input/domInputManager.js?");

/***/ }),

/***/ "./src/Input/dragndrop.js":
/*!********************************!*\
  !*** ./src/Input/dragndrop.js ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n */\nmodule.exports = dragndrop;\n\nvar documentEvents = __webpack_require__(/*! ../Utils/documentEvents.js */ \"./src/Utils/documentEvents.js\");\n\nvar browserInfo = __webpack_require__(/*! ../Utils/browserInfo.js */ \"./src/Utils/browserInfo.js\");\n\nvar findElementPosition = __webpack_require__(/*! ./findElementPosition.js */ \"./src/Input/findElementPosition.js\"); // TODO: Move to input namespace\n// TODO: Methods should be extracted into the prototype. This class\n// does not need to consume so much memory for every tracked element\n\n\nfunction dragndrop(element) {\n  var start,\n      drag,\n      end,\n      scroll,\n      prevSelectStart,\n      prevDragStart,\n      startX = 0,\n      startY = 0,\n      dragObject,\n      touchInProgress = false,\n      pinchZoomLength = 0,\n      getMousePos = function (e) {\n    var posx = 0,\n        posy = 0;\n    e = e || window.event;\n\n    if (e.pageX || e.pageY) {\n      posx = e.pageX;\n      posy = e.pageY;\n    } else if (e.clientX || e.clientY) {\n      posx = e.clientX + window.document.body.scrollLeft + window.document.documentElement.scrollLeft;\n      posy = e.clientY + window.document.body.scrollTop + window.document.documentElement.scrollTop;\n    }\n\n    return [posx, posy];\n  },\n      move = function (e, clientX, clientY) {\n    if (drag) {\n      drag(e, {\n        x: clientX - startX,\n        y: clientY - startY\n      });\n    }\n\n    startX = clientX;\n    startY = clientY;\n  },\n      stopPropagation = function (e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else {\n      e.cancelBubble = true;\n    }\n  },\n      preventDefault = function (e) {\n    if (e.preventDefault) e.preventDefault();\n  },\n      handleDisabledEvent = function (e) {\n    stopPropagation(e);\n    return false;\n  },\n      handleMouseMove = function (e) {\n    e = e || window.event;\n    move(e, e.clientX, e.clientY);\n  },\n      handleMouseDown = function (e) {\n    e = e || window.event;\n\n    if (touchInProgress) {\n      // modern browsers will fire mousedown for touch events too\n      // we do not want this, since touch is handled separately.\n      stopPropagation(e);\n      return false;\n    } // for IE, left click == 1\n    // for Firefox, left click == 0\n\n\n    var isLeftButton = e.button === 1 && window.event !== null || e.button === 0;\n\n    if (isLeftButton) {\n      startX = e.clientX;\n      startY = e.clientY; // TODO: bump zIndex?\n\n      dragObject = e.target || e.srcElement;\n\n      if (start) {\n        start(e, {\n          x: startX,\n          y: startY\n        });\n      }\n\n      documentEvents.on('mousemove', handleMouseMove);\n      documentEvents.on('mouseup', handleMouseUp);\n      stopPropagation(e); // TODO: What if event already there? Not bullet proof:\n\n      prevSelectStart = window.document.onselectstart;\n      prevDragStart = window.document.ondragstart;\n      window.document.onselectstart = handleDisabledEvent;\n      dragObject.ondragstart = handleDisabledEvent; // prevent text selection (except IE)\n\n      return false;\n    }\n  },\n      handleMouseUp = function (e) {\n    e = e || window.event;\n    documentEvents.off('mousemove', handleMouseMove);\n    documentEvents.off('mouseup', handleMouseUp);\n    window.document.onselectstart = prevSelectStart;\n    dragObject.ondragstart = prevDragStart;\n    dragObject = null;\n\n    if (end) {\n      end(e);\n    }\n  },\n      handleMouseWheel = function (e) {\n    if (typeof scroll !== 'function') {\n      return;\n    }\n\n    e = e || window.event;\n    if (e.preventDefault) e.preventDefault();\n    e.returnValue = false;\n    var delta = -e.deltaY,\n        mousePos = getMousePos(e),\n        elementOffset = findElementPosition(element),\n        relMousePos = {\n      x: mousePos[0] - elementOffset[0],\n      y: mousePos[1] - elementOffset[1]\n    };\n    scroll(e, delta, relMousePos);\n  },\n      updateScrollEvents = function (scrollCallback) {\n    if (!scroll && scrollCallback) {\n      // client is interested in scrolling. Start listening to events:\n      element.addEventListener('wheel', handleMouseWheel, false);\n    } else if (scroll && !scrollCallback) {\n      element.removeEventListener('wheel', handleMouseWheel, false);\n    }\n\n    scroll = scrollCallback;\n  },\n      getPinchZoomLength = function (finger1, finger2) {\n    return (finger1.clientX - finger2.clientX) * (finger1.clientX - finger2.clientX) + (finger1.clientY - finger2.clientY) * (finger1.clientY - finger2.clientY);\n  },\n      handleTouchMove = function (e) {\n    if (e.touches.length === 1) {\n      stopPropagation(e);\n      var touch = e.touches[0];\n      move(e, touch.clientX, touch.clientY);\n    } else if (e.touches.length === 2) {\n      // it's a zoom:\n      var currentPinchLength = getPinchZoomLength(e.touches[0], e.touches[1]);\n      var delta = 0;\n\n      if (currentPinchLength < pinchZoomLength) {\n        delta = -1;\n      } else if (currentPinchLength > pinchZoomLength) {\n        delta = 1;\n      }\n\n      scroll(e, delta, {\n        x: e.touches[0].clientX,\n        y: e.touches[0].clientY\n      });\n      pinchZoomLength = currentPinchLength;\n      stopPropagation(e);\n      preventDefault(e);\n    }\n  },\n      handleTouchEnd = function (e) {\n    touchInProgress = false;\n    documentEvents.off('touchmove', handleTouchMove);\n    documentEvents.off('touchend', handleTouchEnd);\n    documentEvents.off('touchcancel', handleTouchEnd);\n    dragObject = null;\n\n    if (end) {\n      end(e);\n    }\n  },\n      handleSignleFingerTouch = function (e, touch) {\n    stopPropagation(e);\n    preventDefault(e);\n    startX = touch.clientX;\n    startY = touch.clientY;\n    dragObject = e.target || e.srcElement;\n\n    if (start) {\n      start(e, {\n        x: startX,\n        y: startY\n      });\n    } // TODO: can I enter into the state when touch is in progress\n    // but it's still a single finger touch?\n\n\n    if (!touchInProgress) {\n      touchInProgress = true;\n      documentEvents.on('touchmove', handleTouchMove);\n      documentEvents.on('touchend', handleTouchEnd);\n      documentEvents.on('touchcancel', handleTouchEnd);\n    }\n  },\n      handleTouchStart = function (e) {\n    if (e.touches.length === 1) {\n      return handleSignleFingerTouch(e, e.touches[0]);\n    } else if (e.touches.length === 2) {\n      // handleTouchMove() will care about pinch zoom.\n      stopPropagation(e);\n      preventDefault(e);\n      pinchZoomLength = getPinchZoomLength(e.touches[0], e.touches[1]);\n    } // don't care about the rest.\n\n  };\n\n  element.addEventListener('mousedown', handleMouseDown);\n  element.addEventListener('touchstart', handleTouchStart);\n  return {\n    onStart: function (callback) {\n      start = callback;\n      return this;\n    },\n    onDrag: function (callback) {\n      drag = callback;\n      return this;\n    },\n    onStop: function (callback) {\n      end = callback;\n      return this;\n    },\n\n    /**\r\n     * Occurs when mouse wheel event happens. callback = function(e, scrollDelta, scrollPoint);\r\n     */\n    onScroll: function (callback) {\n      updateScrollEvents(callback);\n      return this;\n    },\n    release: function () {\n      // TODO: could be unsafe. We might wanna release dragObject, etc.\n      element.removeEventListener('mousedown', handleMouseDown);\n      element.removeEventListener('touchstart', handleTouchStart);\n      documentEvents.off('mousemove', handleMouseMove);\n      documentEvents.off('mouseup', handleMouseUp);\n      documentEvents.off('touchmove', handleTouchMove);\n      documentEvents.off('touchend', handleTouchEnd);\n      documentEvents.off('touchcancel', handleTouchEnd);\n      updateScrollEvents(null);\n    }\n  };\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/Input/dragndrop.js?");

/***/ }),

/***/ "./src/Input/findElementPosition.js":
/*!******************************************!*\
  !*** ./src/Input/findElementPosition.js ***!
  \******************************************/
/***/ (function(module) {

eval("/**\r\n * Finds the absolute position of an element on a page\r\n */\nmodule.exports = findElementPosition;\n\nfunction findElementPosition(obj) {\n  var curleft = 0,\n      curtop = 0;\n\n  if (obj.offsetParent) {\n    do {\n      curleft += obj.offsetLeft;\n      curtop += obj.offsetTop;\n    } while ((obj = obj.offsetParent) !== null);\n  }\n\n  return [curleft, curtop];\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/Input/findElementPosition.js?");

/***/ }),

/***/ "./src/Input/getDimensions.js":
/*!************************************!*\
  !*** ./src/Input/getDimensions.js ***!
  \************************************/
/***/ (function(module) {

eval("module.exports = getDimension;\n\nfunction getDimension(container) {\n  if (!container) {\n    throw {\n      message: 'Cannot get dimensions of undefined container'\n    };\n  } // TODO: Potential cross browser bug.\n\n\n  var width = container.clientWidth;\n  var height = container.clientHeight;\n  return {\n    left: 0,\n    top: 0,\n    width: width,\n    height: height\n  };\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/Input/getDimensions.js?");

/***/ }),

/***/ "./src/Layout/constant.js":
/*!********************************!*\
  !*** ./src/Layout/constant.js ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = constant;\n\nvar merge = __webpack_require__(/*! ngraph.merge */ \"./node_modules/ngraph.merge/index.js\");\n\nvar random = (__webpack_require__(/*! ngraph.random */ \"./node_modules/ngraph.random/index.js\").random);\n\nvar Rect = __webpack_require__(/*! ../Geom/rect.js */ \"./src/Geom/rect.js\");\n/**\r\n * Does not really perform any layouting algorithm but is compliant\r\n * with renderer interface. Allowing clients to provide specific positioning\r\n * callback and get static layout of the graph\r\n *\r\n * @param {Viva.Graph.graph} graph to layout\r\n * @param {Object} userSettings\r\n */\n\n\nfunction constant(graph, userSettings) {\n  userSettings = merge(userSettings, {\n    maxX: 1024,\n    maxY: 1024,\n    seed: 'Deterministic randomness made me do this'\n  }); // This class simply follows API, it does not use some of the arguments:\n\n  /*jshint unused: false */\n\n  var rand = random(userSettings.seed),\n      graphRect = new Rect(Number.MAX_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MIN_VALUE),\n      layoutLinks = {},\n      placeNodeCallback = function (node) {\n    return {\n      x: rand.next(userSettings.maxX),\n      y: rand.next(userSettings.maxY)\n    };\n  },\n      updateGraphRect = function (position, graphRect) {\n    if (position.x < graphRect.x1) {\n      graphRect.x1 = position.x;\n    }\n\n    if (position.x > graphRect.x2) {\n      graphRect.x2 = position.x;\n    }\n\n    if (position.y < graphRect.y1) {\n      graphRect.y1 = position.y;\n    }\n\n    if (position.y > graphRect.y2) {\n      graphRect.y2 = position.y;\n    }\n  },\n      layoutNodes = typeof Object.create === 'function' ? Object.create(null) : {},\n      ensureNodeInitialized = function (node) {\n    layoutNodes[node.id] = placeNodeCallback(node);\n    updateGraphRect(layoutNodes[node.id], graphRect);\n  },\n      updateNodePositions = function () {\n    if (graph.getNodesCount() === 0) {\n      return;\n    }\n\n    graphRect.x1 = Number.MAX_VALUE;\n    graphRect.y1 = Number.MAX_VALUE;\n    graphRect.x2 = Number.MIN_VALUE;\n    graphRect.y2 = Number.MIN_VALUE;\n    graph.forEachNode(ensureNodeInitialized);\n  },\n      ensureLinkInitialized = function (link) {\n    layoutLinks[link.id] = link;\n  },\n      onGraphChanged = function (changes) {\n    for (var i = 0; i < changes.length; ++i) {\n      var change = changes[i];\n\n      if (change.node) {\n        if (change.changeType === 'add') {\n          ensureNodeInitialized(change.node);\n        } else {\n          delete layoutNodes[change.node.id];\n        }\n      }\n\n      if (change.link) {\n        if (change.changeType === 'add') {\n          ensureLinkInitialized(change.link);\n        } else {\n          delete layoutLinks[change.link.id];\n        }\n      }\n    }\n  };\n\n  graph.forEachNode(ensureNodeInitialized);\n  graph.forEachLink(ensureLinkInitialized);\n  graph.on('changed', onGraphChanged);\n  return {\n    /**\r\n     * Attempts to layout graph within given number of iterations.\r\n     *\r\n     * @param {integer} [iterationsCount] number of algorithm's iterations.\r\n     *  The constant layout ignores this parameter.\r\n     */\n    run: function (iterationsCount) {\n      this.step();\n    },\n\n    /**\r\n     * One step of layout algorithm.\r\n     */\n    step: function () {\n      updateNodePositions();\n      return true; // no need to continue.\n    },\n\n    /**\r\n     * Returns rectangle structure {x1, y1, x2, y2}, which represents\r\n     * current space occupied by graph.\r\n     */\n    getGraphRect: function () {\n      return graphRect;\n    },\n\n    /**\r\n     * Request to release all resources\r\n     */\n    dispose: function () {\n      graph.off('change', onGraphChanged);\n    },\n\n    /*\r\n     * Checks whether given node is pinned; all nodes in this layout are pinned.\r\n     */\n    isNodePinned: function (node) {\n      return true;\n    },\n\n    /*\r\n     * Requests layout algorithm to pin/unpin node to its current position\r\n     * Pinned nodes should not be affected by layout algorithm and always\r\n     * remain at their position\r\n     */\n    pinNode: function (node, isPinned) {// noop\n    },\n\n    /*\r\n     * Gets position of a node by its id. If node was not seen by this\r\n     * layout algorithm undefined value is returned;\r\n     */\n    getNodePosition: getNodePosition,\n\n    /**\r\n     * Returns {from, to} position of a link.\r\n     */\n    getLinkPosition: function (linkId) {\n      var link = layoutLinks[linkId];\n      return {\n        from: getNodePosition(link.fromId),\n        to: getNodePosition(link.toId)\n      };\n    },\n\n    /**\r\n     * Sets position of a node to a given coordinates\r\n     */\n    setNodePosition: function (nodeId, x, y) {\n      var pos = layoutNodes[nodeId];\n\n      if (pos) {\n        pos.x = x;\n        pos.y = y;\n      }\n    },\n    // Layout specific methods:\n\n    /**\r\n     * Based on argument either update default node placement callback or\r\n     * attempts to place given node using current placement callback.\r\n     * Setting new node callback triggers position update for all nodes.\r\n     *\r\n     * @param {Object} newPlaceNodeCallbackOrNode - if it is a function then\r\n     * default node placement callback is replaced with new one. Node placement\r\n     * callback has a form of function (node) {}, and is expected to return an\r\n     * object with x and y properties set to numbers.\r\n     *\r\n     * Otherwise if it's not a function the argument is treated as graph node\r\n     * and current node placement callback will be used to place it.\r\n     */\n    placeNode: function (newPlaceNodeCallbackOrNode) {\n      if (typeof newPlaceNodeCallbackOrNode === 'function') {\n        placeNodeCallback = newPlaceNodeCallbackOrNode;\n        updateNodePositions();\n        return this;\n      } // it is not a request to update placeNodeCallback, trying to place\n      // a node using current callback:\n\n\n      return placeNodeCallback(newPlaceNodeCallbackOrNode);\n    }\n  };\n\n  function getNodePosition(nodeId) {\n    return layoutNodes[nodeId];\n  }\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/Layout/constant.js?");

/***/ }),

/***/ "./src/Layout/interactive.js":
/*!***********************************!*\
  !*** ./src/Layout/interactive.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = constant;\n\nvar merge = __webpack_require__(/*! ngraph.merge */ \"./node_modules/ngraph.merge/index.js\");\n\nvar random = (__webpack_require__(/*! ngraph.random */ \"./node_modules/ngraph.random/index.js\").random);\n\nvar Rect = __webpack_require__(/*! ../Geom/rect.js */ \"./src/Geom/rect.js\");\n/**\r\n * Does not really perform any layouting algorithm but is compliant\r\n * with renderer interface. Allowing clients to provide specific positioning\r\n * callback and get static layout of the graph\r\n *\r\n * @param {Viva.Graph.graph} graph to layout\r\n * @param {Object} userSettings\r\n */\n\n\nfunction constant(graph, userSettings) {\n  userSettings = merge(userSettings, {\n    maxX: 1024,\n    maxY: 1024,\n    seed: 'Deterministic randomness made me do this'\n  }); // This class simply follows API, it does not use some of the arguments:\n\n  /*jshint unused: false */\n\n  var rand = random(userSettings.seed),\n      graphRect = new Rect(Number.MAX_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MIN_VALUE),\n      layoutLinks = {},\n      placeNodeCallback = function (node) {\n    return {\n      x: rand.next(userSettings.maxX),\n      y: rand.next(userSettings.maxY)\n    };\n  },\n      updateGraphRect = function (position, graphRect) {\n    if (position.x < graphRect.x1) {\n      graphRect.x1 = position.x;\n    }\n\n    if (position.x > graphRect.x2) {\n      graphRect.x2 = position.x;\n    }\n\n    if (position.y < graphRect.y1) {\n      graphRect.y1 = position.y;\n    }\n\n    if (position.y > graphRect.y2) {\n      graphRect.y2 = position.y;\n    }\n  },\n      layoutNodes = typeof Object.create === 'function' ? Object.create(null) : {},\n      ensureNodeInitialized = function (node) {\n    if (!layoutNodes[node.id]) layoutNodes[node.id] = placeNodeCallback(node); // console.log({ layoutNodes });\n\n    updateGraphRect(layoutNodes[node.id], graphRect);\n  },\n      updateNodePositions = function () {\n    if (graph.getNodesCount() === 0) {\n      return;\n    }\n\n    graphRect.x1 = Number.MAX_VALUE;\n    graphRect.y1 = Number.MAX_VALUE;\n    graphRect.x2 = Number.MIN_VALUE;\n    graphRect.y2 = Number.MIN_VALUE;\n    graph.forEachNode(ensureNodeInitialized);\n  },\n      ensureLinkInitialized = function (link) {\n    layoutLinks[link.id] = link;\n  },\n      onGraphChanged = function (changes) {\n    for (var i = 0; i < changes.length; ++i) {\n      var change = changes[i];\n\n      if (change.node) {\n        if (change.changeType === 'add') {\n          ensureNodeInitialized(change.node);\n        } else {\n          delete layoutNodes[change.node.id];\n        }\n      }\n\n      if (change.link) {\n        if (change.changeType === 'add') {\n          ensureLinkInitialized(change.link);\n        } else {\n          delete layoutLinks[change.link.id];\n        }\n      }\n    }\n  };\n\n  graph.forEachNode(ensureNodeInitialized);\n  graph.forEachLink(ensureLinkInitialized);\n  graph.on('changed', onGraphChanged);\n  return {\n    /**\r\n     * Attempts to layout graph within given number of iterations.\r\n     *\r\n     * @param {integer} [iterationsCount] number of algorithm's iterations.\r\n     *  The constant layout ignores this parameter.\r\n     */\n    run: function (iterationsCount) {\n      this.step();\n    },\n\n    /**\r\n     * One step of layout algorithm.\r\n     */\n    step: function () {\n      updateNodePositions();\n      return true; // no need to continue.\n    },\n\n    /**\r\n     * Returns rectangle structure {x1, y1, x2, y2}, which represents\r\n     * current space occupied by graph.\r\n     */\n    getGraphRect: function () {\n      return graphRect;\n    },\n\n    /**\r\n     * Request to release all resources\r\n     */\n    dispose: function () {\n      graph.off('change', onGraphChanged);\n    },\n\n    /*\r\n     * Checks whether given node is pinned; all nodes in this layout are pinned.\r\n     */\n    isNodePinned: function (node) {\n      return true;\n    },\n\n    /*\r\n     * Requests layout algorithm to pin/unpin node to its current position\r\n     * Pinned nodes should not be affected by layout algorithm and always\r\n     * remain at their position\r\n     */\n    pinNode: function (node, isPinned) {// noop\n    },\n\n    /*\r\n     * Gets position of a node by its id. If node was not seen by this\r\n     * layout algorithm undefined value is returned;\r\n     */\n    getNodePosition: getNodePosition,\n\n    /**\r\n     * Returns {from, to} position of a link.\r\n     */\n    getLinkPosition: function (linkId) {\n      var link = layoutLinks[linkId];\n      return {\n        from: getNodePosition(link.fromId),\n        to: getNodePosition(link.toId)\n      };\n    },\n\n    /**\r\n     * Sets position of a node to a given coordinates\r\n     */\n    setNodePosition: function (nodeId, x, y) {\n      var pos = layoutNodes[nodeId];\n\n      if (pos) {\n        pos.x = x;\n        pos.y = y;\n      }\n    },\n    // Layout specific methods:\n\n    /**\r\n     * Based on argument either update default node placement callback or\r\n     * attempts to place given node using current placement callback.\r\n     * Setting new node callback triggers position update for all nodes.\r\n     *\r\n     * @param {Object} newPlaceNodeCallbackOrNode - if it is a function then\r\n     * default node placement callback is replaced with new one. Node placement\r\n     * callback has a form of function (node) {}, and is expected to return an\r\n     * object with x and y properties set to numbers.\r\n     *\r\n     * Otherwise if it's not a function the argument is treated as graph node\r\n     * and current node placement callback will be used to place it.\r\n     */\n    placeNode: function (newPlaceNodeCallbackOrNode) {\n      if (typeof newPlaceNodeCallbackOrNode === 'function') {\n        placeNodeCallback = newPlaceNodeCallbackOrNode;\n        updateNodePositions();\n        return this;\n      } // it is not a request to update placeNodeCallback, trying to place\n      // a node using current callback:\n\n\n      return placeNodeCallback(newPlaceNodeCallbackOrNode);\n    }\n  };\n\n  function getNodePosition(nodeId) {\n    return layoutNodes[nodeId];\n  }\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/Layout/interactive.js?");

/***/ }),

/***/ "./src/Utils/EventManager.js":
/*!***********************************!*\
  !*** ./src/Utils/EventManager.js ***!
  \***********************************/
/***/ (function(module) {

eval("class EventManager {\n  constructor() {\n    this.events = {};\n  }\n\n  on(event, callback) {\n    if (!this.events[event]) this.events[event] = [];\n    this.events[event].push(callback);\n    return this;\n  }\n\n  once(event, callback) {\n    const self = this;\n\n    const onceCallback = function () {\n      callback(...arguments);\n      self.off(event, onceCallback);\n    };\n\n    return this.on(event, onceCallback);\n  }\n\n  off() {\n    let event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (event === null) this.events = {};else if (this.events[event]) {\n      if (callback === null) delete this.events[event];else this.events[event] = this.events[event].filter(cb => cb !== callback);\n    }\n    return this;\n  }\n\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (!this.events[event]) {\n      return;\n    }\n\n    this.events[event].forEach(cb => cb(...args));\n    return this;\n  }\n\n}\n\nmodule.exports = EventManager;\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/EventManager.js?");

/***/ }),

/***/ "./src/Utils/ExtendedSet.js":
/*!**********************************!*\
  !*** ./src/Utils/ExtendedSet.js ***!
  \**********************************/
/***/ (function(module) {

eval("class ExtendedSet extends Set {\n  constructor() {\n    super(...arguments);\n  }\n\n  push() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args.forEach(arg => this.add(arg));\n    return this;\n  }\n\n  find(cb) {\n    let i = 0;\n    let vals = this.values;\n\n    for (let i = 0; i < vals.length; i++) {\n      if (cb(v, i)) return v;\n    }\n\n    return null;\n  }\n\n  filter(cb) {\n    let asArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let arr = [];\n    let i = 0;\n    this.forEach(v => {\n      if (cb(v, i)) arr.push(v);\n      i++;\n    });\n    if (asArray) return arr;\n    return new ExtendedSet(arr);\n  }\n\n  map(cb) {\n    let asArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let arr = [];\n    let i = 0;\n    this.forEach(v => {\n      arr.push(cb(v, i));\n      i++;\n    });\n    if (asArray) return arr;\n    return new ExtendedSet(arr);\n  }\n\n  reduce(cb, initialValue) {\n    let asArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let arr = Array.from(this.values).reduce(cb, initialValue);\n    if (asArray) return arr;\n    return new ExtendedSet(arr);\n  }\n\n}\n\nmodule.exports = ExtendedSet;\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/ExtendedSet.js?");

/***/ }),

/***/ "./src/Utils/Tree.js":
/*!***************************!*\
  !*** ./src/Utils/Tree.js ***!
  \***************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const newID = __webpack_require__(/*! ../Utils/id */ \"./src/Utils/id.js\");\n\nconst EventManager = __webpack_require__(/*! ./EventManager */ \"./src/Utils/EventManager.js\");\n\nclass Tree extends EventManager {\n  /**\r\n   * Create a new Tree object. All nodes in the Tree are instances of this Tree class.\r\n   * @param {?Tree} parent The parent of this tree-node\r\n   * @param {any} data Data associated with this node\r\n   */\n  constructor() {\n    let parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    /** @type {Number} */\n\n    this.id = newID();\n    /** @type {any} */\n\n    this.data = data || {};\n    /** @type {?Tree} */\n\n    this.parent = parent;\n    /** @type {Tree[]} */\n\n    this.children = [];\n  }\n  /**\r\n   * Returns how many levels deep this node is in the tree.\r\n   * @returns {Number}\r\n   */\n\n\n  get depth() {\n    let depth = 0;\n    let parent = this.parent;\n\n    while (parent !== null) {\n      depth++;\n      parent = parent.parent;\n    }\n\n    return depth;\n  }\n  /**\r\n   * Returns how many levels the tree goes deeper from here\r\n   * @returns {Number}\r\n   */\n\n\n  get height() {\n    return Math.max(...this.children.map(child => child.height)) + 1;\n  }\n  /**\r\n   * Get the root-node of this tree.\r\n   * @returns {Tree}\r\n   */\n\n\n  get root() {\n    if (this.parent === null) return this;\n    let parent = this.parent;\n\n    while (parent.parent !== null) {\n      parent = parent.parent;\n    }\n\n    return parent;\n  }\n  /**\r\n   * Check if this Tree-Node is empty - i.e. has no children and no data associated with it.\r\n   * @returns {Boolean}\r\n   */\n\n\n  isEmpty() {\n    return this.children.length === 0 && Object.keys(this.data).length === 0;\n  }\n  /**\r\n   * Get all nodes in the tree, that are in startLayer, endLayer or any layer in between. The layers are counted from this node onward. That is done to implement this method recursively, as users will mainly call it from the root only anyways.\r\n   \r\n   If startLayer is 0, this node is included in the result as well.\r\n   \r\n   Defaults to get all nodes in the tree, starting from layer 0 and going to layer Infinity (that is until the tree ended).\r\n   * @param {Number} startLayer The first layer to get nodes from\r\n   * @param {Number} endLayer The last layer to get nodes from\r\n   * @returns {Tree[]} List of Nodes in the specified range of layers.\r\n   */\n\n\n  getChildren() {\n    let startLayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let endLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n\n    if (startLayer === 0 && endLayer === 0) {\n      return [this];\n    } else if (startLayer === 0) {\n      return [this, ...this.children.map(child => child.getChildren(0, endLayer - 1))];\n    } else {\n      return [...this.children.map(child => child.getChildren(startLayer - 1, endLayer - 1))];\n    }\n  }\n  /**\r\n   * Get the Node with the specified id. If it doesn't exist in this Tree, `null` is returned instead.\r\n   * @param {Number} id The ID of the node to get\r\n   * @returns {?Tree}\r\n   */\n\n\n  getByID(id) {\n    if (this.id === id) return this;\n\n    for (let child of this.children) {\n      let res = child.getByID(id);\n      if (res !== null) return res;\n    }\n\n    return null;\n  }\n  /**\r\n   * Add a child-node to this node.\r\n   * @param {Tree} child The child to add to this tree\r\n   * @returns {Tree} The child that was added\r\n   */\n\n\n  addChild(child) {\n    var _child$parent;\n\n    child === null || child === void 0 ? void 0 : (_child$parent = child.parent) === null || _child$parent === void 0 ? void 0 : _child$parent.removeChild(child.id);\n    child.parent = this;\n    this.children.push(child);\n    return child;\n  }\n  /**\r\n   * Change this node's parent.\r\n   * @param {?Tree} newParent The new parent of this node. If set to null, this system will have no parent.\r\n   */\n\n\n  changeParent() {\n    var _this$parent;\n\n    let newParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.removeChild(this.id);\n    newParent === null || newParent === void 0 ? void 0 : newParent.addChild(this);\n  }\n  /**\r\n   * Remove a child of this tree. To remove this node itself, set all references to it to `null` and let the garbage collector handle it. All children of the node will be removed as well, unless you save another reference to them before.\r\n   * @param {Number} id The ID of the node to remove\r\n   * @returns {?Tree} Returns the removed child or `null` if the child couldn't be found.\r\n   */\n\n\n  removeChild(id) {\n    let idx = this.children.findIndex(child => child.id === id);\n\n    if (idx === -1) {\n      for (let child of this.children) {\n        let res = child.removeChild(id);\n        if (res) return res;\n      }\n\n      return null;\n    } else {\n      let removedChild = this.children.splice(idx, 1)[0];\n      this.emit('childRemoved', removedChild, this);\n      return removedChild;\n    }\n  }\n\n}\n\nmodule.exports = Tree;\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/Tree.js?");

/***/ }),

/***/ "./src/Utils/Trie.js":
/*!***************************!*\
  !*** ./src/Utils/Trie.js ***!
  \***************************/
/***/ (function(module) {

eval("function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\n\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\n\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\n\nvar _allKeys = /*#__PURE__*/new WeakSet();\n\nvar _replacePrefix = /*#__PURE__*/new WeakSet();\n\nclass Trie {\n  constructor() {\n    _classPrivateMethodInitSpec(this, _replacePrefix);\n\n    _classPrivateMethodInitSpec(this, _allKeys);\n\n    /** @type {String[]} */\n    this.chars = [];\n    /** @type {Trie[]} */\n\n    this.tries = [];\n    /** @type {any} */\n\n    this.val = null;\n  }\n  /**\r\n   * Check if this Node is empty - i.e. has no children and no value and is therefore ready to be removed.\r\n   * @returns {boolean}\r\n   */\n\n\n  isEmpty() {\n    return this.chars.length === 0 && this.val === null;\n  }\n  /**\r\n   * Find the value associated with the name `str`\r\n   * @param {String} str Name of the Node\r\n   * @returns {?any} If the Node doesn't exist, `null` is returned\r\n   */\n\n\n  find(str) {\n    if (str === '') return this.val;\n    let idx = this.chars.indexOf(str[0]);\n    if (idx === -1) return null;else return this.tries[idx].find(str.substring(1));\n  }\n  /**\r\n   * Insert a new value associated with some name\r\n   * @param {String} str Name of the Node\r\n   * @param {any} val Value to associate with the name `str`\r\n   * @returns {Trie} Returns this Trie to allow chained calls\r\n   */\n\n\n  insert(str, val) {\n    if (str === '') {\n      this.val = val;\n      return this;\n    }\n\n    let idx = this.chars.indexOf(str[0]);\n\n    if (idx === -1) {\n      this.chars.push(str[0]);\n      this.tries.push(new Trie());\n      idx = this.chars.length - 1;\n    }\n\n    this.tries[idx].insert(str.substring(1), val);\n    return this;\n  }\n  /**\r\n   * Remove the Node associated with `str`\r\n   * @param {String} str Name of the Node\r\n   * @returns {boolean} Indicates whether the Node was successfully removed. Should only be `false` if the Node didn't exist.\r\n   */\n\n\n  delete(str) {\n    if (str === '') {\n      this.val = null;\n      return;\n    }\n\n    let idx = this.chars.indexOf(str[0]);\n    if (idx === -1) return;\n    this.tries[idx].delete(str.substring(1));\n\n    if (this.tries[idx].isEmpty()) {\n      this.chars.splice(idx, 1);\n      this.tries.splice(idx, 1);\n    }\n  } // For String Completion\n\n  /**\r\n   * Auxiliary function for #replacePrefix()\r\n   * @param {String} str\r\n   * @param {String} prefix\r\n   * @returns {String[]}\r\n   */\n\n\n  /**\r\n   * Find all keys in this Trie that start with `str`\r\n   * @param {String} str Prefix to search for\r\n   * @returns {String[]} Returns all valid names in the Trie that start with `str`\r\n   */\n  findPrefix(str) {\n    return _classPrivateMethodGet(this, _replacePrefix, _replacePrefix2).call(this, str, str);\n  }\n\n}\n\nfunction _allKeys2(str) {\n  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  let res = [];\n  if (this.val !== null) res.push(prefix);\n  this.chars.forEach((c, i) => {\n    var _this$tries$i;\n\n    res.push(..._classPrivateMethodGet(_this$tries$i = this.tries[i], _allKeys, _allKeys2).call(_this$tries$i, str, prefix + c));\n  });\n  return res;\n}\n\nfunction _replacePrefix2(str) {\n  var _this$tries$idx;\n\n  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  if (str === '') return _classPrivateMethodGet(this, _allKeys, _allKeys2).call(this, prefix);\n  let idx = this.chars.indexOf(str[0]);\n  if (idx === -1) return [];else return _classPrivateMethodGet(_this$tries$idx = this.tries[idx], _replacePrefix, _replacePrefix2).call(_this$tries$idx, str.substring(1), prefix);\n}\n\nmodule.exports = Trie;\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/Trie.js?");

/***/ }),

/***/ "./src/Utils/browserInfo.js":
/*!**********************************!*\
  !*** ./src/Utils/browserInfo.js ***!
  \**********************************/
/***/ (function(module) {

eval("module.exports = browserInfo();\n\nfunction browserInfo() {\n  if (typeof window === 'undefined' || !window.hasOwnProperty('navigator')) {\n    return {\n      browser: '',\n      version: '0'\n    };\n  }\n\n  var ua = window.navigator.userAgent.toLowerCase(),\n      // Useragent RegExp\n  rwebkit = /(webkit)[ \\/]([\\w.]+)/,\n      ropera = /(opera)(?:.*version)?[ \\/]([\\w.]+)/,\n      rmsie = /(msie) ([\\w.]+)/,\n      rmozilla = /(mozilla)(?:.*? rv:([\\w.]+))?/,\n      match = rwebkit.exec(ua) || ropera.exec(ua) || rmsie.exec(ua) || ua.indexOf('compatible') < 0 && rmozilla.exec(ua) || [];\n  return {\n    browser: match[1] || '',\n    version: match[2] || '0'\n  };\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/browserInfo.js?");

/***/ }),

/***/ "./src/Utils/documentEvents.js":
/*!*************************************!*\
  !*** ./src/Utils/documentEvents.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var nullEvents = __webpack_require__(/*! ./nullEvents.js */ \"./src/Utils/nullEvents.js\");\n\nmodule.exports = createDocumentEvents();\n\nfunction createDocumentEvents() {\n  if (typeof document === undefined) {\n    return nullEvents;\n  }\n\n  return {\n    on: on,\n    off: off\n  };\n}\n\nfunction on(eventName, handler) {\n  document.addEventListener(eventName, handler);\n}\n\nfunction off(eventName, handler) {\n  document.removeEventListener(eventName, handler);\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/documentEvents.js?");

/***/ }),

/***/ "./src/Utils/id.js":
/*!*************************!*\
  !*** ./src/Utils/id.js ***!
  \*************************/
/***/ (function(module) {

eval("globalIDCounter = 0;\n\nmodule.exports = function newID() {\n  return ++globalIDCounter;\n};\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/id.js?");

/***/ }),

/***/ "./src/Utils/nullEvents.js":
/*!*********************************!*\
  !*** ./src/Utils/nullEvents.js ***!
  \*********************************/
/***/ (function(module) {

eval("module.exports = createNullEvents();\n\nfunction createNullEvents() {\n  return {\n    on: noop,\n    off: noop,\n    stop: noop\n  };\n}\n\nfunction noop() {}\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/nullEvents.js?");

/***/ }),

/***/ "./src/Utils/timer.js":
/*!****************************!*\
  !*** ./src/Utils/timer.js ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n */\nmodule.exports = createTimer();\n\nfunction createTimer() {\n  var lastTime = 0,\n      vendors = ['ms', 'moz', 'webkit', 'o'],\n      i,\n      scope;\n\n  if (typeof window !== 'undefined') {\n    scope = window;\n  } else if (typeof __webpack_require__.g !== 'undefined') {\n    scope = __webpack_require__.g;\n  } else {\n    scope = {\n      setTimeout: noop,\n      clearTimeout: noop\n    };\n  }\n\n  for (i = 0; i < vendors.length && !scope.requestAnimationFrame; ++i) {\n    var vendorPrefix = vendors[i];\n    scope.requestAnimationFrame = scope[vendorPrefix + 'RequestAnimationFrame'];\n    scope.cancelAnimationFrame = scope[vendorPrefix + 'CancelAnimationFrame'] || scope[vendorPrefix + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!scope.requestAnimationFrame) {\n    scope.requestAnimationFrame = rafPolyfill;\n  }\n\n  if (!scope.cancelAnimationFrame) {\n    scope.cancelAnimationFrame = cancelRafPolyfill;\n  }\n\n  return timer;\n  /**\r\n   * Timer that fires callback with given interval (in ms) until\r\n   * callback returns true;\r\n   */\n\n  function timer(callback) {\n    var intervalId;\n    startTimer(); // start it right away.\n\n    return {\n      /**\r\n       * Stops execution of the callback\r\n       */\n      stop: stopTimer,\n      restart: restart\n    };\n\n    function startTimer() {\n      intervalId = scope.requestAnimationFrame(startTimer);\n\n      if (!callback()) {\n        stopTimer();\n      }\n    }\n\n    function stopTimer() {\n      scope.cancelAnimationFrame(intervalId);\n      intervalId = 0;\n    }\n\n    function restart() {\n      if (!intervalId) {\n        startTimer();\n      }\n    }\n  }\n\n  function rafPolyfill(callback) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = scope.setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  }\n\n  function cancelRafPolyfill(id) {\n    scope.clearTimeout(id);\n  }\n}\n\nfunction noop() {}\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/timer.js?");

/***/ }),

/***/ "./src/Utils/windowEvents.js":
/*!***********************************!*\
  !*** ./src/Utils/windowEvents.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var nullEvents = __webpack_require__(/*! ./nullEvents.js */ \"./src/Utils/nullEvents.js\");\n\nmodule.exports = createDocumentEvents();\n\nfunction createDocumentEvents() {\n  if (typeof window === 'undefined') {\n    return nullEvents;\n  }\n\n  return {\n    on: on,\n    off: off\n  };\n}\n\nfunction on(eventName, handler) {\n  window.addEventListener(eventName, handler);\n}\n\nfunction off(eventName, handler) {\n  window.removeEventListener(eventName, handler);\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/Utils/windowEvents.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const Main = {\n  // TODO: Update Graph to use SystemLandscape\n  graph: __webpack_require__(/*! ./Graphs/SystemLandscape.js */ \"./src/Graphs/SystemLandscape.js\"),\n  serializer: {\n    // TODO: Update Serializers\n    loadFromJSON: __webpack_require__(/*! ngraph.fromjson */ \"./node_modules/ngraph.fromjson/index.js\"),\n    storeToJSON: __webpack_require__(/*! ngraph.tojson */ \"./node_modules/ngraph.tojson/index.js\")\n  },\n  Geom: {\n    intersect: __webpack_require__(/*! gintersect */ \"./node_modules/gintersect/index.js\"),\n    intersectRect: __webpack_require__(/*! ./Geom/intersectRect.js */ \"./src/Geom/intersectRect.js\"),\n    Rect: __webpack_require__(/*! ./Geom/rect.js */ \"./src/Geom/rect.js\")\n  },\n  Input: {\n    domInputManager: __webpack_require__(/*! ./Input/domInputManager.js */ \"./src/Input/domInputManager.js\"),\n    dragndrop: __webpack_require__(/*! ./Input/dragndrop.js */ \"./src/Input/dragndrop.js\"),\n    findElementPosition: __webpack_require__(/*! ./Input/findElementPosition.js */ \"./src/Input/findElementPosition.js\"),\n    getDimension: __webpack_require__(/*! ./Input/getDimensions.js */ \"./src/Input/getDimensions.js\")\n  },\n  Utils: {\n    documentEvents: __webpack_require__(/*! ./Utils/documentEvents.js */ \"./src/Utils/documentEvents.js\"),\n    nullEvents: __webpack_require__(/*! ./Utils/nullEvents.js */ \"./src/Utils/nullEvents.js\"),\n    windowEvents: __webpack_require__(/*! ./Utils/windowEvents.js */ \"./src/Utils/windowEvents.js\"),\n    timer: __webpack_require__(/*! ./Utils/timer.js */ \"./src/Utils/timer.js\"),\n    newID: __webpack_require__(/*! ./Utils/id.js */ \"./src/Utils/id.js\"),\n    EventManager: __webpack_require__(/*! ./Utils/EventManager.js */ \"./src/Utils/EventManager.js\"),\n    Trie: __webpack_require__(/*! ./Utils/Trie.js */ \"./src/Utils/Trie.js\"),\n    Tree: __webpack_require__(/*! ./Utils/Tree.js */ \"./src/Utils/Tree.js\"),\n    ExtendedSet: __webpack_require__(/*! ./Utils/ExtendedSet.js */ \"./src/Utils/ExtendedSet.js\")\n  },\n  Layout: {\n    forceDirected: __webpack_require__(/*! ngraph.forcelayout */ \"./node_modules/ngraph.forcelayout/index.js\"),\n    constant: __webpack_require__(/*! ./Layout/constant.js */ \"./src/Layout/constant.js\"),\n    interactive: __webpack_require__(/*! ./Layout/interactive.js */ \"./src/Layout/interactive.js\")\n  },\n  svgGraphics: __webpack_require__(/*! ./svgGraphics.js */ \"./src/svgGraphics.js\"),\n  renderer: __webpack_require__(/*! ./renderer.js */ \"./src/renderer.js\"),\n  svg: __webpack_require__(/*! simplesvg */ \"./node_modules/simplesvg/index.js\"),\n  browserInfo: __webpack_require__(/*! ./Utils/browserInfo.js */ \"./src/Utils/browserInfo.js\")\n};\n__webpack_require__.g.SystemLandscaper = Main;\nmodule.exports = Main;\n\n//# sourceURL=webpack://vivagraphjs/./src/main.js?");

/***/ }),

/***/ "./src/renderer.js":
/*!*************************!*\
  !*** ./src/renderer.js ***!
  \*************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\r\n * @fileOverview Defines a graph renderer that uses CSS based drawings.\r\n *\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n * @author Val Richter (aka ArtInLines) / https://github.com/ArtInLines - modified for System-Landscaper\r\n */\nvar eventify = __webpack_require__(/*! ngraph.events */ \"./node_modules/ngraph.events/index.js\");\n\nvar forceDirected = __webpack_require__(/*! ngraph.forcelayout */ \"./node_modules/ngraph.forcelayout/index.js\");\n\nvar svgGraphics = __webpack_require__(/*! ./svgGraphics.js */ \"./src/svgGraphics.js\");\n\nvar windowEvents = __webpack_require__(/*! ./Utils/windowEvents.js */ \"./src/Utils/windowEvents.js\");\n\nvar domInputManager = __webpack_require__(/*! ./Input/domInputManager.js */ \"./src/Input/domInputManager.js\");\n\nvar timer = __webpack_require__(/*! ./Utils/timer.js */ \"./src/Utils/timer.js\");\n\nvar getDimension = __webpack_require__(/*! ./Input/getDimensions.js */ \"./src/Input/getDimensions.js\");\n\nvar dragndrop = __webpack_require__(/*! ./Input/dragndrop.js */ \"./src/Input/dragndrop.js\");\n\nconst EventManager = __webpack_require__(/*! ./Utils/EventManager.js */ \"./src/Utils/EventManager.js\");\n/**\r\n * This is heart of the rendering. Class accepts graph to be rendered and rendering settings.\r\n * It monitors graph changes and depicts them accordingly.\r\n *\r\n * @param graph - Viva.Graph.graph() object to be rendered.\r\n * @param settings - rendering settings, composed from the following parts (with their defaults shown):\r\n *   settings = {\r\n *     // Represents a module that is capable of displaying graph nodes and links.\r\n *     // all graphics has to correspond to defined interface and can be later easily\r\n *     // replaced for specific needs (e.g. adding WebGL should be piece of cake as long\r\n *     // as WebGL has implemented required interface). See svgGraphics for example.\r\n *     graphics : Viva.Graph.View.svgGraphics(),\r\n *\r\n *     // Where the renderer should draw graph. Container size matters, because\r\n *     // renderer will attempt center graph to that size. Also graphics modules\r\n *     // might depend on it.\r\n *     container : document.body,\r\n *\r\n *     // Defines whether graph can respond to use input\r\n *     interactive: true,\r\n *\r\n *     // Layout algorithm to be used. The algorithm is expected to comply with defined\r\n *     // interface and is expected to be iterative. Renderer will use it then to calculate\r\n *     // graph's layout. For examples of the interface refer to Viva.Graph.Layout.forceDirected()\r\n *     layout : Viva.Graph.Layout.forceDirected(),\r\n *\r\n *     // Directs renderer to display links. Usually rendering links is the slowest part of this\r\n *     // library. So if you don't need to display links, consider settings this property to false.\r\n *     renderLinks : true,\r\n *\r\n *     // Number of layout iterations to run before displaying the graph. The bigger you set this number\r\n *     // the closer to ideal position graph will appear first time. But be careful: for large graphs\r\n *     // it can freeze the browser.\r\n *     prerender : 0\r\n *   }\r\n */\n\n/**\r\n * @typedef {Object} rendererSettings\r\n * @property {any} layout - Layout algorithm to be used. The algorithm is expected to comply with defined interface and is expected to be iterative. Renderer will use it then to calculate graph's layout. For examples of the interface refer to Viva.Graph.Layout.forceDirected()\r\n * @property {any} graphics - Graphics module that is used to render nodes and links.\r\n * @property {HTMLElement} container - Where the renderer should draw graph. Container size matters, because renderer will attempt center graph to that size. Also graphics modules might depend on it.\r\n * @property {boolean|('node'|'scroll'|'drag')} interactive - Defines whether graph can respond to user input. Defaults to `true`. When set to a string, then only the specified action is interactive\r\n * @property {boolean} renderLinks - Directs renderer to display links. Defaults to `true`\r\n * @property {number} prerender - Number of layout iterations to run before displaying the graph. The bigger you set this number the closer to the ideal position the graph will appear first time. But be careful: for large graphs it can freeze the browser. Defaults to `0`.\r\n */\n\n/** @type {rendererSettings} */\n\n\nconst defaultSettings = {\n  layout: __webpack_require__(/*! ./Layout/interactive.js */ \"./src/Layout/interactive.js\"),\n  graphics: __webpack_require__(/*! ./svgGraphics.js */ \"./src/svgGraphics.js\"),\n  container: document.body,\n  interactive: true,\n  renderLinks: true,\n  prerender: 0\n};\n\nclass Renderer extends EventManager {\n  /**\r\n   * @param {Graph} graph - Graph to be rendered.\r\n   * @param {rendererSettings} settings - Rendering settings.\r\n   */\n  constructor(graph, settings) {\n    super();\n    this.FRAME_INTERVAL = 30;\n    this.graph = graph;\n    settings = { ...defaultSettings,\n      ...settings\n    };\n    this.layout = settings.layout(graph, settings);\n    this.graphics = settings.graphics();\n    this.container = settings.container;\n    this.interactive = settings.interactive;\n    this.renderLinks = settings.renderLinks;\n    this.prerender = settings.prerender;\n    this.inputManager = (this.graphics.inputManager || domInputManager)(this.graph, this.graphics);\n    this.animationTimer;\n    this.isInitialized = false;\n    this.updateCenterRequired = true;\n    this.isStable = false;\n    this.userInteraction = false;\n    this.isPaused = false;\n    this.transform = {\n      offsetX: 0,\n      offsetY: 0,\n      scale: 1\n    };\n    this.containerDrag;\n  } // TODO: Update the following Getters to be actual getters\n\n  /**\r\n   * Returns current transformation matrix.\r\n   */\n\n\n  getTransform() {\n    return transform;\n  }\n  /**\r\n   * Gets current graphics object\r\n   */\n\n\n  getGraphics() {\n    return graphics;\n  }\n  /**\r\n   * Gets current layout.\r\n   */\n\n\n  getLayout() {\n    return this.layout;\n  }\n  /**\r\n   * Performs rendering of the graph.\r\n   *\r\n   * @param iterationsCount if specified renderer will run only given number of iterations\r\n   * and then stop. Otherwise graph rendering is performed indefinitely.\r\n   *\r\n   * Note: if rendering stopped by used started dragging nodes or new nodes were added to the\r\n   * graph renderer will give run more iterations to reflect changes.\r\n   */\n\n\n  run(iterationsCount) {\n    if (!this.isInitialized) {\n      this._prerender();\n\n      this._initDom();\n\n      this._updateCenter();\n\n      this._listenToEvents();\n\n      this.isInitialized = true;\n    }\n\n    this._renderIterations(iterationsCount);\n\n    return this;\n  }\n\n  reset() {\n    graphics.resetScale();\n\n    this._updateCenter();\n\n    this.transform.scale = 1;\n  }\n\n  pause() {\n    this.isPaused = true;\n    this.animationTimer.stop();\n  }\n\n  resume() {\n    this.isPaused = false;\n    this.animationTimer.restart();\n  }\n\n  rerender() {\n    this._renderGraph();\n\n    return this;\n  }\n\n  zoomOut() {\n    return this._scale(true);\n  }\n\n  zoomIn() {\n    return this._scale(false);\n  }\n  /**\r\n   * Centers renderer at x,y graph's coordinates\r\n   */\n\n\n  moveTo(x, y) {\n    this.graphics.graphCenterChanged(transform.offsetX - x * transform.scale, transform.offsetY - y * transform.scale);\n\n    this._renderGraph();\n  }\n  /**\r\n   * Removes this renderer and deallocates all resources/timers\r\n   */\n\n\n  dispose() {\n    this._stopListenToEvents(); // I quit!\n\n  }\n  /**\r\n   * Checks whether given interaction (node/scroll) is enabled\r\n   */\n\n\n  _isInteractive(interactionName) {\n    if (typeof this.interactive === 'string') {\n      return this.interactive.indexOf(interactionName) >= 0;\n    } else return this.interactive;\n  }\n\n  _renderGraph() {\n    this.graphics.beginRender(); // TODO: move this check graphics\n\n    if (this.renderLinks) this.graphics.renderLinks();\n    this.graphics.renderNodes();\n    this.graphics.endRender();\n  }\n\n  _onRenderFrame() {\n    this.isStable = this.getLayout().step() && !this.userInteraction;\n\n    this._renderGraph();\n\n    return !this.isStable;\n  }\n\n  _renderIterations(iterationsCount) {\n    if (this.animationTimer) return;\n\n    if (typeof iterationsCount === 'number') {\n      this.animationTimer = timer(() => {\n        iterationsCount -= 1;\n        if (iterationsCount < 0) return false;else return this._onRenderFrame();\n      }, this.FRAME_INTERVAL);\n    } else {\n      this.animationTimer = timer(() => this._onRenderFrame(), this.FRAME_INTERVAL);\n    }\n  }\n\n  _resetStable() {\n    if (this.isPaused) return;\n    this.isStable = false;\n    this.animationTimer.restart();\n  }\n\n  _prerender() {\n    // To get good initial positions for the graph\n    // perform several prerender steps in background.\n    for (let i = 0; i < this.prerender; i += 1) layout.step();\n  }\n\n  _updateCenter() {\n    let graphRect = this.layout.getGraphRect();\n    let containerSize = getDimension(this.container);\n    var cx = (graphRect.x2 + graphRect.x1) / 2;\n    var cy = (graphRect.y2 + graphRect.y1) / 2;\n    this.transform.offsetX = containerSize.width / 2 - (cx * this.transform.scale - cx);\n    this.transform.offsetY = containerSize.height / 2 - (cy * this.transform.scale - cy);\n    this.graphics.graphCenterChanged(this.transform.offsetX, this.transform.offsetY);\n    this.updateCenterRequired = false;\n  }\n\n  _createNodeUi(node) {\n    let nodePosition = this.layout.getNodePosition(node.id);\n    this.graphics.addNode(node, nodePosition);\n  }\n\n  _removeNodeUi(node) {\n    this.graphics.releaseNode(node);\n  }\n\n  _createLinkUi(link) {\n    let linkPosition = this.layout.getLinkPosition(link.id);\n    this.graphics.addLink(link, linkPosition);\n  }\n\n  _removeLinkUi(link) {\n    this.graphics.releaseLink(link);\n  }\n\n  _listenNodeEvents(node) {\n    if (!this._isInteractive('node')) return;\n    let wasPinned = false; // TODO: This may not be memory efficient. Consider reusing handlers object.\n\n    this.inputManager.bindDragNDrop(node, {\n      onStart: () => {\n        wasPinned = this.layout.isNodePinned(node);\n        this.layout.pinNode(node, true);\n        this.userInteraction = true;\n\n        this._resetStable();\n      },\n      onDrag: (e, offset) => {\n        let oldPos = this.layout.getNodePosition(node.id);\n        this.layout.setNodePosition(node.id, oldPos.x + offset.x / this.transform.scale, oldPos.y + offset.y / this.transform.scale);\n        this.userInteraction = true;\n\n        this._renderGraph();\n      },\n      onStop: () => {\n        this.layout.pinNode(node, wasPinned);\n        this.userInteraction = false;\n      }\n    });\n  }\n\n  _releaseNodeEvents(node) {\n    this.inputManager.bindDragNDrop(node, null);\n  }\n\n  _initDom() {\n    this.graphics.init(this.container);\n    this.graph.forEachNode(node => this._createNodeUi(node));\n    if (this.renderLinks) this.graph.forEachLink(link => this._createLinkUi(link));\n  }\n\n  _releaseDom() {\n    this.graphics.release(this.container);\n  }\n\n  _processNodeChange(change) {\n    let node = change.node;\n\n    switch (change.changeType) {\n      case 'add':\n        this._createNodeUi(node);\n\n        this._listenNodeEvents(node);\n\n        if (this.updateCenterRequired) this._updateCenter();\n        break;\n\n      case 'remove':\n        this._releaseNodeEvents(node);\n\n        this._removeNodeUi(node);\n\n        if (this.graph.getNodesCount() === 0) this.updateCenterRequired = true; // Next time when node is added - center the graph.\n\n        break;\n\n      case 'update':\n        this._releaseNodeEvents(node);\n\n        this._removeNodeUi(node);\n\n        this._createNodeUi(node);\n\n        this._listenNodeEvents(node);\n\n        break;\n    }\n  }\n\n  _processLinkChange(change) {\n    if (!this.renderLinks) return;\n\n    switch (change.changeType) {\n      case 'add':\n        this._createLinkUi(change.link);\n\n        break;\n\n      case 'remove':\n        this._removeLinkUi(change.link);\n\n        break;\n\n      case 'update':\n        throw 'Update type is not implemented. TODO: Implement me!';\n    }\n  }\n\n  _onGraphChanged(changes) {\n    for (let change of changes) {\n      if (change.node) this._processNodeChange(change);else if (change.link) this._processLinkChange(change);\n    }\n\n    this._resetStable();\n  }\n\n  _onWindowResized() {\n    this._updateCenter();\n\n    this._onRenderFrame();\n  }\n\n  _releaseContainerDragManager() {\n    if (this.containerDrag) {\n      this.containerDrag.release();\n      this.containerDrag = null;\n    }\n  }\n\n  _releaseGraphEvents() {\n    this.graph.off('changed', this._onGraphChanged);\n  }\n\n  _scale(out, scrollPoint) {\n    if (!scrollPoint) {\n      let containerSize = getDimension(container);\n      scrollPoint = {\n        x: containerSize.width / 2,\n        y: containerSize.height / 2\n      };\n    }\n\n    let scaleFactor = Math.pow(1 + 0.4, out ? -0.2 : 0.2);\n    this.transform.scale = this.graphics.scale(scaleFactor, scrollPoint);\n\n    this._renderGraph();\n\n    this.emit('scale', this.transform.scale);\n    return this.transform.scale;\n  }\n\n  _listenToEvents() {\n    windowEvents.on('resize', this._onWindowResized);\n\n    this._releaseContainerDragManager();\n\n    if (this._isInteractive('drag')) {\n      this.containerDrag = dragndrop(this.container);\n      this.containerDrag.onDrag((e, offset) => {\n        this.graphics.translateRel(offset.x, offset.y);\n\n        this._renderGraph();\n\n        this.emit('drag', offset);\n      });\n    }\n\n    if (this._isInteractive('scroll')) {\n      if (!this.containerDrag) {\n        this.containerDrag = dragndrop(this.container);\n      }\n\n      this.containerDrag.onScroll((e, scaleOffset, scrollPoint) => {\n        this._scale(scaleOffset < 0, scrollPoint);\n      });\n    }\n\n    this.graph.forEachNode(node => this._listenNodeEvents(node));\n\n    this._releaseGraphEvents();\n\n    this.graph.on('changed', this._onGraphChanged);\n  }\n\n  _stopListenToEvents() {\n    this.rendererInitialized = false;\n\n    this._releaseGraphEvents();\n\n    this._releaseContainerDragManager();\n\n    windowEvents.off('resize', this._onWindowResized);\n    this.off();\n    this.animationTimer.stop();\n    this.graph.forEachLink(link => {\n      if (this.renderLinks) this._removeLinkUi(link);\n    });\n    this.graph.forEachNode(node => {\n      this._releaseNodeEvents(node);\n\n      this._removeNodeUi(node);\n    });\n    this.layout.dispose();\n\n    this._releaseDom();\n  }\n\n}\n\nfunction createRenderer(graph, settings) {\n  return new Renderer(graph, settings);\n}\n\nmodule.exports = createRenderer;\n\n//# sourceURL=webpack://vivagraphjs/./src/renderer.js?");

/***/ }),

/***/ "./src/svgGraphics.js":
/*!****************************!*\
  !*** ./src/svgGraphics.js ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\r\n * @fileOverview Defines a graph renderer that uses SVG based drawings.\r\n *\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n */\nmodule.exports = svgGraphics;\n\nvar svg = __webpack_require__(/*! simplesvg */ \"./node_modules/simplesvg/index.js\");\n\nvar eventify = __webpack_require__(/*! ngraph.events */ \"./node_modules/ngraph.events/index.js\");\n\nvar domInputManager = __webpack_require__(/*! ./Input/domInputManager.js */ \"./src/Input/domInputManager.js\");\n/**\r\n * Performs svg-based graph rendering. This module does not perform\r\n * layout, but only visualizes nodes and edges of the graph.\r\n */\n\n\nfunction svgGraphics() {\n  // TODO: Let settings be passed in the constructor, so the user can customize them\n  var svgContainer,\n      svgRoot,\n      offsetX = 0,\n      offsetY = 0,\n      initCallback,\n      actualScale = 1,\n      allNodes = {},\n      allLinks = {},\n      nodeLength = 30,\n\n  /*jshint unused: false */\n  nodeBuilder = function (node) {\n    return svg('rect').attr('width', nodeLength).attr('height', nodeLength).attr('fill', '#00a2e8');\n  },\n      nodePositionCallback = function (nodeUI, pos) {\n    nodeUI.attr('x', pos.x - nodeLength / 2).attr('y', pos.y - nodeLength / 2);\n  },\n      linkBuilder = function (link) {\n    return svg('line').attr('stroke', '#111');\n  },\n      linkPositionCallback = function (linkUI, fromPos, toPos) {\n    linkUI.attr('x1', fromPos.x).attr('y1', fromPos.y).attr('x2', toPos.x).attr('y2', toPos.y);\n  },\n      fireRescaled = function (graphics) {\n    // TODO: maybe we shall copy changes?\n    graphics.fire('rescaled');\n  },\n      cachedPos = {\n    x: 0,\n    y: 0\n  },\n      cachedFromPos = {\n    x: 0,\n    y: 0\n  },\n      cachedToPos = {\n    x: 0,\n    y: 0\n  },\n      updateTransform = function () {\n    if (svgContainer) {\n      var transform = 'matrix(' + actualScale + ', 0, 0,' + actualScale + ',' + offsetX + ',' + offsetY + ')';\n      svgContainer.attr('transform', transform);\n    }\n  };\n\n  svgRoot = createSvgRoot();\n  var graphics = {\n    getNodeUI: function (nodeId) {\n      return allNodes[nodeId];\n    },\n    getLinkUI: function (linkId) {\n      return allLinks[linkId];\n    },\n\n    /**\r\n     * Sets the callback that creates node representation.\r\n     *\r\n     * @param builderCallback a callback function that accepts graph node\r\n     * as a parameter and must return an element representing this node.\r\n     *\r\n     * @returns If builderCallbackOrNode is a valid callback function, instance of this is returned;\r\n     * Otherwise undefined value is returned\r\n     */\n    node: function (builderCallback) {\n      if (typeof builderCallback !== 'function') {\n        return; // todo: throw? This is not compatible with old versions\n      }\n\n      nodeBuilder = builderCallback;\n      return this;\n    },\n\n    /**\r\n     * Sets the callback that creates link representation\r\n     *\r\n     * @param builderCallback a callback function that accepts graph link\r\n     * as a parameter and must return an element representing this link.\r\n     *\r\n     * @returns If builderCallback is a valid callback function, instance of this is returned;\r\n     * Otherwise undefined value is returned.\r\n     */\n    link: function (builderCallback) {\n      if (typeof builderCallback !== 'function') {\n        return; // todo: throw? This is not compatible with old versions\n      }\n\n      linkBuilder = builderCallback;\n      return this;\n    },\n\n    /**\r\n     * Allows to override default position setter for the node with a new\r\n     * function. newPlaceCallback(nodeUI, position, node) is function which\r\n     * is used by updateNodePosition().\r\n     */\n    placeNode: function (newPlaceCallback) {\n      nodePositionCallback = newPlaceCallback;\n      return this;\n    },\n    placeLink: function (newPlaceLinkCallback) {\n      linkPositionCallback = newPlaceLinkCallback;\n      return this;\n    },\n\n    /**\r\n     * Called every before renderer starts rendering.\r\n     */\n    beginRender: function () {},\n\n    /**\r\n     * Called every time when renderer finishes one step of rendering.\r\n     */\n    endRender: function () {},\n\n    /**\r\n     * Sets translate operation that should be applied to all nodes and links.\r\n     */\n    graphCenterChanged: function (x, y) {\n      offsetX = x;\n      offsetY = y;\n      updateTransform();\n    },\n\n    /**\r\n     * Default input manager listens to DOM events to process nodes drag-n-drop\r\n     */\n    inputManager: domInputManager,\n    translateRel: function (dx, dy) {\n      var p = svgRoot.createSVGPoint(),\n          t = svgContainer.getCTM(),\n          origin = svgRoot.createSVGPoint().matrixTransform(t.inverse());\n      p.x = dx;\n      p.y = dy;\n      p = p.matrixTransform(t.inverse());\n      p.x = (p.x - origin.x) * t.a;\n      p.y = (p.y - origin.y) * t.d;\n      t.e += p.x;\n      t.f += p.y;\n      var transform = 'matrix(' + t.a + ', 0, 0,' + t.d + ',' + t.e + ',' + t.f + ')';\n      svgContainer.attr('transform', transform);\n    },\n    scale: function (scaleFactor, scrollPoint) {\n      var p = svgRoot.createSVGPoint();\n      p.x = scrollPoint.x;\n      p.y = scrollPoint.y;\n      p = p.matrixTransform(svgContainer.getCTM().inverse()); // translate to SVG coordinates\n      // Compute new scale matrix in current mouse position\n\n      var k = svgRoot.createSVGMatrix().translate(p.x, p.y).scale(scaleFactor).translate(-p.x, -p.y),\n          t = svgContainer.getCTM().multiply(k);\n      actualScale = t.a;\n      offsetX = t.e;\n      offsetY = t.f;\n      var transform = 'matrix(' + t.a + ', 0, 0,' + t.d + ',' + t.e + ',' + t.f + ')';\n      svgContainer.attr('transform', transform);\n      fireRescaled(this);\n      return actualScale;\n    },\n    resetScale: function () {\n      actualScale = 1;\n      var transform = 'matrix(1, 0, 0, 1, 0, 0)';\n      svgContainer.attr('transform', transform);\n      fireRescaled(this);\n      return this;\n    },\n\n    /**\r\n     * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n     * provider prepare to render.\r\n     */\n    init: function (container) {\n      container.appendChild(svgRoot);\n      updateTransform(); // Notify the world if someone waited for update. TODO: should send an event\n\n      if (typeof initCallback === 'function') {\n        initCallback(svgRoot);\n      }\n    },\n\n    /**\r\n     * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n     * provider release occupied resources.\r\n     */\n    release: function (container) {\n      if (svgRoot && container) {\n        container.removeChild(svgRoot);\n      }\n    },\n\n    /**\r\n     * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n     * provider prepare to render given link of the graph\r\n     *\r\n     * @param link - model of a link\r\n     */\n    addLink: function (link, pos) {\n      var linkUI = linkBuilder(link);\n\n      if (!linkUI) {\n        return;\n      }\n\n      linkUI.position = pos;\n      linkUI.link = link;\n      allLinks[link.id] = linkUI;\n\n      if (svgContainer.childElementCount > 0) {\n        svgContainer.insertBefore(linkUI, svgContainer.firstChild);\n      } else {\n        svgContainer.appendChild(linkUI);\n      }\n\n      return linkUI;\n    },\n\n    /**\r\n     * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n     * provider remove link from rendering surface.\r\n     *\r\n     * @param linkUI visual representation of the link created by link() execution.\r\n     **/\n    releaseLink: function (link) {\n      var linkUI = allLinks[link.id];\n\n      if (linkUI) {\n        svgContainer.removeChild(linkUI);\n        delete allLinks[link.id];\n      }\n    },\n\n    /**\r\n     * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n     * provider prepare to render given node of the graph.\r\n     *\r\n     * @param nodeUI visual representation of the node created by node() execution.\r\n     **/\n    addNode: function (node, pos) {\n      var nodeUI = nodeBuilder(node);\n\n      if (!nodeUI) {\n        return;\n      }\n\n      nodeUI.position = pos;\n      nodeUI.node = node;\n      allNodes[node.id] = nodeUI;\n      svgContainer.appendChild(nodeUI);\n      return nodeUI;\n    },\n\n    /**\r\n     * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n     * provider remove node from rendering surface.\r\n     *\r\n     * @param node graph's node\r\n     **/\n    releaseNode: function (node) {\n      var nodeUI = allNodes[node.id];\n\n      if (nodeUI) {\n        svgContainer.removeChild(nodeUI);\n        delete allNodes[node.id];\n      }\n    },\n    renderNodes: function () {\n      for (var key in allNodes) {\n        if (allNodes.hasOwnProperty(key)) {\n          var nodeUI = allNodes[key];\n          cachedPos.x = nodeUI.position.x;\n          cachedPos.y = nodeUI.position.y;\n          nodePositionCallback(nodeUI, cachedPos, nodeUI.node);\n        }\n      }\n    },\n    renderLinks: function () {\n      for (var key in allLinks) {\n        if (allLinks.hasOwnProperty(key)) {\n          var linkUI = allLinks[key];\n          cachedFromPos.x = linkUI.position.from.x;\n          cachedFromPos.y = linkUI.position.from.y;\n          cachedToPos.x = linkUI.position.to.x;\n          cachedToPos.y = linkUI.position.to.y;\n          linkPositionCallback(linkUI, cachedFromPos, cachedToPos, linkUI.link);\n        }\n      }\n    },\n\n    /**\r\n     * Returns root element which hosts graphics.\r\n     */\n    getGraphicsRoot: function (callbackWhenReady) {\n      // todo: should fire an event, instead of having this context.\n      if (typeof callbackWhenReady === 'function') {\n        if (svgRoot) {\n          callbackWhenReady(svgRoot);\n        } else {\n          initCallback = callbackWhenReady;\n        }\n      }\n\n      return svgRoot;\n    },\n\n    /**\r\n     * Returns root SVG element.\r\n     *\r\n     * Note: This is internal method specific to this renderer\r\n     */\n    getSvgRoot: function () {\n      return svgRoot;\n    }\n  }; // Let graphics fire events before we return it to the caller.\n\n  eventify(graphics);\n  return graphics;\n\n  function createSvgRoot() {\n    var svgRoot = svg('svg');\n    svgContainer = svg('g').attr('buffered-rendering', 'dynamic');\n    svgRoot.appendChild(svgContainer);\n    return svgRoot;\n  }\n}\n\n//# sourceURL=webpack://vivagraphjs/./src/svgGraphics.js?");

/***/ }),

/***/ "./node_modules/gintersect/index.js":
/*!******************************************!*\
  !*** ./node_modules/gintersect/index.js ***!
  \******************************************/
/***/ (function(module) {

eval("module.exports = intersect;\n\n/**\n * Original authors: Mukesh Prasad, Appeared in Graphics Gem II book\n * http://www.opensource.apple.com/source/graphviz/graphviz-498/graphviz/dynagraph/common/xlines.c\n * and adopted to javascript version by Andrei Kashcha.\n *\n * This function computes whether two line segments,\n * respectively joining the input points (x1,y1) -- (x2,y2)\n * and the input points (x3,y3) -- (x4,y4) intersect.\n * If the lines intersect, the output variables x, y are\n * set to coordinates of the point of intersection.\n *\n * @param {Number} x1 First line segment coordinates\n * @param {Number} y1 First line segment coordinates\n * @param {Number} x2 First line segment coordinates\n * @param {Number} x2 First line segment coordinates\n *\n * @param {Number} x3 Second line segment coordinates\n * @param {Number} y3 Second line segment coordinates\n * @param {Number} x4 Second line segment coordinates\n * @param {Number} x4 Second line segment coordinates\n *\n * @return {Object} x, y coordinates of intersection point or falsy value if no\n * intersection found..\n */\nfunction intersect(\n  x1, y1, x2, y2, // first line segment\n  x3, y3, x4, y4  // second line segment\n) {\n\n  var a1, a2, b1, b2, c1, c2, /* Coefficients of line eqns. */\n    r1, r2, r3, r4, /* 'Sign' values */\n    denom, offset, num, /* Intermediate values */\n    result = {\n      x: 0,\n      y: 0\n    };\n\n  /* Compute a1, b1, c1, where line joining points 1 and 2\n   * is \"a1 x  +  b1 y  +  c1  =  0\".\n   */\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2;\n\n  /* Compute r3 and r4.\n   */\n  r3 = a1 * x3 + b1 * y3 + c1;\n  r4 = a1 * x4 + b1 * y4 + c1;\n\n  /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\n   * same side of line 1, the line segments do not intersect.\n   */\n\n  if (r3 !== 0 && r4 !== 0 && ((r3 >= 0) === (r4 >= 4))) {\n    return null; //no intersection.\n  }\n\n  /* Compute a2, b2, c2 */\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4;\n\n  /* Compute r1 and r2 */\n\n  r1 = a2 * x1 + b2 * y1 + c2;\n  r2 = a2 * x2 + b2 * y2 + c2;\n\n  /* Check signs of r1 and r2.  If both point 1 and point 2 lie\n   * on same side of second line segment, the line segments do\n   * not intersect.\n   */\n  if (r1 !== 0 && r2 !== 0 && ((r1 >= 0) === (r2 >= 0))) {\n    return null; // no intersection;\n  }\n  /* Line segments intersect: compute intersection point.\n   */\n\n  denom = a1 * b2 - a2 * b1;\n  if (denom === 0) {\n    return null; // Actually collinear..\n  }\n\n  offset = denom < 0 ? -denom / 2 : denom / 2;\n  offset = 0.0;\n\n  /* The denom/2 is to get rounding instead of truncating.  It\n   * is added or subtracted to the numerator, depending upon the\n   * sign of the numerator.\n   */\n  num = b1 * c2 - b2 * c1;\n  result.x = (num < 0 ? num - offset : num + offset) / denom;\n\n  num = a2 * c1 - a1 * c2;\n  result.y = (num < 0 ? num - offset : num + offset) / denom;\n\n  return result;\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/gintersect/index.js?");

/***/ }),

/***/ "./node_modules/ngraph.events/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ngraph.events/index.js ***!
  \*********************************************/
/***/ (function(module) {

eval("module.exports = function(subject) {\n  validateSubject(subject);\n\n  var eventsStorage = createEventsStorage(subject);\n  subject.on = eventsStorage.on;\n  subject.off = eventsStorage.off;\n  subject.fire = eventsStorage.fire;\n  return subject;\n};\n\nfunction createEventsStorage(subject) {\n  // Store all event listeners to this hash. Key is event name, value is array\n  // of callback records.\n  //\n  // A callback record consists of callback function and its optional context:\n  // { 'eventName' => [{callback: function, ctx: object}] }\n  var registeredEvents = Object.create(null);\n\n  return {\n    on: function (eventName, callback, ctx) {\n      if (typeof callback !== 'function') {\n        throw new Error('callback is expected to be a function');\n      }\n      var handlers = registeredEvents[eventName];\n      if (!handlers) {\n        handlers = registeredEvents[eventName] = [];\n      }\n      handlers.push({callback: callback, ctx: ctx});\n\n      return subject;\n    },\n\n    off: function (eventName, callback) {\n      var wantToRemoveAll = (typeof eventName === 'undefined');\n      if (wantToRemoveAll) {\n        // Killing old events storage should be enough in this case:\n        registeredEvents = Object.create(null);\n        return subject;\n      }\n\n      if (registeredEvents[eventName]) {\n        var deleteAllCallbacksForEvent = (typeof callback !== 'function');\n        if (deleteAllCallbacksForEvent) {\n          delete registeredEvents[eventName];\n        } else {\n          var callbacks = registeredEvents[eventName];\n          for (var i = 0; i < callbacks.length; ++i) {\n            if (callbacks[i].callback === callback) {\n              callbacks.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      return subject;\n    },\n\n    fire: function (eventName) {\n      var callbacks = registeredEvents[eventName];\n      if (!callbacks) {\n        return subject;\n      }\n\n      var fireArguments;\n      if (arguments.length > 1) {\n        fireArguments = Array.prototype.splice.call(arguments, 1);\n      }\n      for(var i = 0; i < callbacks.length; ++i) {\n        var callbackInfo = callbacks[i];\n        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n      }\n\n      return subject;\n    }\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('Eventify cannot use falsy object as events subject');\n  }\n  var reservedWords = ['on', 'fire', 'off'];\n  for (var i = 0; i < reservedWords.length; ++i) {\n    if (subject.hasOwnProperty(reservedWords[i])) {\n      throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n    }\n  }\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.events/index.js?");

/***/ }),

/***/ "./node_modules/ngraph.expose/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ngraph.expose/index.js ***!
  \*********************************************/
/***/ (function(module) {

eval("module.exports = exposeProperties;\n\n/**\n * Augments `target` object with getter/setter functions, which modify settings\n *\n * @example\n *  var target = {};\n *  exposeProperties({ age: 42}, target);\n *  target.age(); // returns 42\n *  target.age(24); // make age 24;\n *\n *  var filteredTarget = {};\n *  exposeProperties({ age: 42, name: 'John'}, filteredTarget, ['name']);\n *  filteredTarget.name(); // returns 'John'\n *  filteredTarget.age === undefined; // true\n */\nfunction exposeProperties(settings, target, filter) {\n  var needsFilter = Object.prototype.toString.call(filter) === '[object Array]';\n  if (needsFilter) {\n    for (var i = 0; i < filter.length; ++i) {\n      augment(settings, target, filter[i]);\n    }\n  } else {\n    for (var key in settings) {\n      augment(settings, target, key);\n    }\n  }\n}\n\nfunction augment(source, target, key) {\n  if (source.hasOwnProperty(key)) {\n    if (typeof target[key] === 'function') {\n      // this accessor is already defined. Ignore it\n      return;\n    }\n    target[key] = function (value) {\n      if (value !== undefined) {\n        source[key] = value;\n        return target;\n      }\n      return source[key];\n    }\n  }\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.expose/index.js?");

/***/ }),

/***/ "./node_modules/ngraph.forcelayout/index.js":
/*!**************************************************!*\
  !*** ./node_modules/ngraph.forcelayout/index.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = createLayout;\nmodule.exports.simulator = __webpack_require__(/*! ngraph.physics.simulator */ \"./node_modules/ngraph.physics.simulator/index.js\");\n\nvar eventify = __webpack_require__(/*! ngraph.events */ \"./node_modules/ngraph.forcelayout/node_modules/ngraph.events/index.js\");\n\n/**\n * Creates force based layout for a given graph.\n *\n * @param {ngraph.graph} graph which needs to be laid out\n * @param {object} physicsSettings if you need custom settings\n * for physics simulator you can pass your own settings here. If it's not passed\n * a default one will be created.\n */\nfunction createLayout(graph, physicsSettings) {\n  if (!graph) {\n    throw new Error('Graph structure cannot be undefined');\n  }\n\n  var createSimulator = __webpack_require__(/*! ngraph.physics.simulator */ \"./node_modules/ngraph.physics.simulator/index.js\");\n  var physicsSimulator = createSimulator(physicsSettings);\n\n  var nodeMass = defaultNodeMass\n  if (physicsSettings && typeof physicsSettings.nodeMass === 'function') {\n    nodeMass = physicsSettings.nodeMass\n  }\n\n  var nodeBodies = Object.create(null);\n  var springs = {};\n  var bodiesCount = 0;\n\n  var springTransform = physicsSimulator.settings.springTransform || noop;\n\n  // Initialize physics with what we have in the graph:\n  initPhysics();\n  listenToEvents();\n\n  var wasStable = false;\n\n  var api = {\n    /**\n     * Performs one step of iterative layout algorithm\n     *\n     * @returns {boolean} true if the system should be considered stable; Flase otherwise.\n     * The system is stable if no further call to `step()` can improve the layout.\n     */\n    step: function() {\n      if (bodiesCount === 0) return true; // TODO: This will never fire 'stable'\n\n      var lastMove = physicsSimulator.step();\n\n      // Save the movement in case if someone wants to query it in the step\n      // callback.\n      api.lastMove = lastMove;\n\n      // Allow listeners to perform low-level actions after nodes are updated.\n      api.fire('step');\n\n      var ratio = lastMove/bodiesCount;\n      var isStableNow = ratio <= 0.01; // TODO: The number is somewhat arbitrary...\n\n      if (wasStable !== isStableNow) {\n        wasStable = isStableNow;\n        onStableChanged(isStableNow);\n      }\n\n      return isStableNow;\n    },\n\n    /**\n     * For a given `nodeId` returns position\n     */\n    getNodePosition: function (nodeId) {\n      return getInitializedBody(nodeId).pos;\n    },\n\n    /**\n     * Sets position of a node to a given coordinates\n     * @param {string} nodeId node identifier\n     * @param {number} x position of a node\n     * @param {number} y position of a node\n     * @param {number=} z position of node (only if applicable to body)\n     */\n    setNodePosition: function (nodeId) {\n      var body = getInitializedBody(nodeId);\n      body.setPosition.apply(body, Array.prototype.slice.call(arguments, 1));\n      physicsSimulator.invalidateBBox();\n    },\n\n    /**\n     * @returns {Object} Link position by link id\n     * @returns {Object.from} {x, y} coordinates of link start\n     * @returns {Object.to} {x, y} coordinates of link end\n     */\n    getLinkPosition: function (linkId) {\n      var spring = springs[linkId];\n      if (spring) {\n        return {\n          from: spring.from.pos,\n          to: spring.to.pos\n        };\n      }\n    },\n\n    /**\n     * @returns {Object} area required to fit in the graph. Object contains\n     * `x1`, `y1` - top left coordinates\n     * `x2`, `y2` - bottom right coordinates\n     */\n    getGraphRect: function () {\n      return physicsSimulator.getBBox();\n    },\n\n    /**\n     * Iterates over each body in the layout simulator and performs a callback(body, nodeId)\n     */\n    forEachBody: forEachBody,\n\n    /*\n     * Requests layout algorithm to pin/unpin node to its current position\n     * Pinned nodes should not be affected by layout algorithm and always\n     * remain at their position\n     */\n    pinNode: function (node, isPinned) {\n      var body = getInitializedBody(node.id);\n       body.isPinned = !!isPinned;\n    },\n\n    /**\n     * Checks whether given graph's node is currently pinned\n     */\n    isNodePinned: function (node) {\n      return getInitializedBody(node.id).isPinned;\n    },\n\n    /**\n     * Request to release all resources\n     */\n    dispose: function() {\n      graph.off('changed', onGraphChanged);\n      api.fire('disposed');\n    },\n\n    /**\n     * Gets physical body for a given node id. If node is not found undefined\n     * value is returned.\n     */\n    getBody: getBody,\n\n    /**\n     * Gets spring for a given edge.\n     *\n     * @param {string} linkId link identifer. If two arguments are passed then\n     * this argument is treated as formNodeId\n     * @param {string=} toId when defined this parameter denotes head of the link\n     * and first argument is trated as tail of the link (fromId)\n     */\n    getSpring: getSpring,\n\n    /**\n     * [Read only] Gets current physics simulator\n     */\n    simulator: physicsSimulator,\n\n    /**\n     * Gets the graph that was used for layout\n     */\n    graph: graph,\n\n    /**\n     * Gets amount of movement performed during last step opeartion\n     */\n    lastMove: 0\n  };\n\n  eventify(api);\n\n  return api;\n\n  function forEachBody(cb) {\n    Object.keys(nodeBodies).forEach(function(bodyId) {\n      cb(nodeBodies[bodyId], bodyId);\n    });\n  }\n\n  function getSpring(fromId, toId) {\n    var linkId;\n    if (toId === undefined) {\n      if (typeof fromId !== 'object') {\n        // assume fromId as a linkId:\n        linkId = fromId;\n      } else {\n        // assume fromId to be a link object:\n        linkId = fromId.id;\n      }\n    } else {\n      // toId is defined, should grab link:\n      var link = graph.hasLink(fromId, toId);\n      if (!link) return;\n      linkId = link.id;\n    }\n\n    return springs[linkId];\n  }\n\n  function getBody(nodeId) {\n    return nodeBodies[nodeId];\n  }\n\n  function listenToEvents() {\n    graph.on('changed', onGraphChanged);\n  }\n\n  function onStableChanged(isStable) {\n    api.fire('stable', isStable);\n  }\n\n  function onGraphChanged(changes) {\n    for (var i = 0; i < changes.length; ++i) {\n      var change = changes[i];\n      if (change.changeType === 'add') {\n        if (change.node) {\n          initBody(change.node.id);\n        }\n        if (change.link) {\n          initLink(change.link);\n        }\n      } else if (change.changeType === 'remove') {\n        if (change.node) {\n          releaseNode(change.node);\n        }\n        if (change.link) {\n          releaseLink(change.link);\n        }\n      }\n    }\n    bodiesCount = graph.getNodesCount();\n  }\n\n  function initPhysics() {\n    bodiesCount = 0;\n\n    graph.forEachNode(function (node) {\n      initBody(node.id);\n      bodiesCount += 1;\n    });\n\n    graph.forEachLink(initLink);\n  }\n\n  function initBody(nodeId) {\n    var body = nodeBodies[nodeId];\n    if (!body) {\n      var node = graph.getNode(nodeId);\n      if (!node) {\n        throw new Error('initBody() was called with unknown node id');\n      }\n\n      var pos = node.position;\n      if (!pos) {\n        var neighbors = getNeighborBodies(node);\n        pos = physicsSimulator.getBestNewBodyPosition(neighbors);\n      }\n\n      body = physicsSimulator.addBodyAt(pos);\n      body.id = nodeId;\n\n      nodeBodies[nodeId] = body;\n      updateBodyMass(nodeId);\n\n      if (isNodeOriginallyPinned(node)) {\n        body.isPinned = true;\n      }\n    }\n  }\n\n  function releaseNode(node) {\n    var nodeId = node.id;\n    var body = nodeBodies[nodeId];\n    if (body) {\n      nodeBodies[nodeId] = null;\n      delete nodeBodies[nodeId];\n\n      physicsSimulator.removeBody(body);\n    }\n  }\n\n  function initLink(link) {\n    updateBodyMass(link.fromId);\n    updateBodyMass(link.toId);\n\n    var fromBody = nodeBodies[link.fromId],\n        toBody  = nodeBodies[link.toId],\n        spring = physicsSimulator.addSpring(fromBody, toBody, link.length);\n\n    springTransform(link, spring);\n\n    springs[link.id] = spring;\n  }\n\n  function releaseLink(link) {\n    var spring = springs[link.id];\n    if (spring) {\n      var from = graph.getNode(link.fromId),\n          to = graph.getNode(link.toId);\n\n      if (from) updateBodyMass(from.id);\n      if (to) updateBodyMass(to.id);\n\n      delete springs[link.id];\n\n      physicsSimulator.removeSpring(spring);\n    }\n  }\n\n  function getNeighborBodies(node) {\n    // TODO: Could probably be done better on memory\n    var neighbors = [];\n    if (!node.links) {\n      return neighbors;\n    }\n    var maxNeighbors = Math.min(node.links.length, 2);\n    for (var i = 0; i < maxNeighbors; ++i) {\n      var link = node.links[i];\n      var otherBody = link.fromId !== node.id ? nodeBodies[link.fromId] : nodeBodies[link.toId];\n      if (otherBody && otherBody.pos) {\n        neighbors.push(otherBody);\n      }\n    }\n\n    return neighbors;\n  }\n\n  function updateBodyMass(nodeId) {\n    var body = nodeBodies[nodeId];\n    body.mass = nodeMass(nodeId);\n    if (Number.isNaN(body.mass)) {\n      throw new Error('Node mass should be a number')\n    }\n  }\n\n  /**\n   * Checks whether graph node has in its settings pinned attribute,\n   * which means layout algorithm cannot move it. Node can be preconfigured\n   * as pinned, if it has \"isPinned\" attribute, or when node.data has it.\n   *\n   * @param {Object} node a graph node to check\n   * @return {Boolean} true if node should be treated as pinned; false otherwise.\n   */\n  function isNodeOriginallyPinned(node) {\n    return (node && (node.isPinned || (node.data && node.data.isPinned)));\n  }\n\n  function getInitializedBody(nodeId) {\n    var body = nodeBodies[nodeId];\n    if (!body) {\n      initBody(nodeId);\n      body = nodeBodies[nodeId];\n    }\n    return body;\n  }\n\n  /**\n   * Calculates mass of a body, which corresponds to node with given id.\n   *\n   * @param {String|Number} nodeId identifier of a node, for which body mass needs to be calculated\n   * @returns {Number} recommended mass of the body;\n   */\n  function defaultNodeMass(nodeId) {\n    var links = graph.getLinks(nodeId);\n    if (!links) return 1;\n    return 1 + links.length / 3.0;\n  }\n}\n\nfunction noop() { }\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.forcelayout/index.js?");

/***/ }),

/***/ "./node_modules/ngraph.forcelayout/node_modules/ngraph.events/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ngraph.forcelayout/node_modules/ngraph.events/index.js ***!
  \*****************************************************************************/
/***/ (function(module) {

eval("module.exports = function(subject) {\n  validateSubject(subject);\n\n  var eventsStorage = createEventsStorage(subject);\n  subject.on = eventsStorage.on;\n  subject.off = eventsStorage.off;\n  subject.fire = eventsStorage.fire;\n  return subject;\n};\n\nfunction createEventsStorage(subject) {\n  // Store all event listeners to this hash. Key is event name, value is array\n  // of callback records.\n  //\n  // A callback record consists of callback function and its optional context:\n  // { 'eventName' => [{callback: function, ctx: object}] }\n  var registeredEvents = Object.create(null);\n\n  return {\n    on: function (eventName, callback, ctx) {\n      if (typeof callback !== 'function') {\n        throw new Error('callback is expected to be a function');\n      }\n      var handlers = registeredEvents[eventName];\n      if (!handlers) {\n        handlers = registeredEvents[eventName] = [];\n      }\n      handlers.push({callback: callback, ctx: ctx});\n\n      return subject;\n    },\n\n    off: function (eventName, callback) {\n      var wantToRemoveAll = (typeof eventName === 'undefined');\n      if (wantToRemoveAll) {\n        // Killing old events storage should be enough in this case:\n        registeredEvents = Object.create(null);\n        return subject;\n      }\n\n      if (registeredEvents[eventName]) {\n        var deleteAllCallbacksForEvent = (typeof callback !== 'function');\n        if (deleteAllCallbacksForEvent) {\n          delete registeredEvents[eventName];\n        } else {\n          var callbacks = registeredEvents[eventName];\n          for (var i = 0; i < callbacks.length; ++i) {\n            if (callbacks[i].callback === callback) {\n              callbacks.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      return subject;\n    },\n\n    fire: function (eventName) {\n      var callbacks = registeredEvents[eventName];\n      if (!callbacks) {\n        return subject;\n      }\n\n      var fireArguments;\n      if (arguments.length > 1) {\n        fireArguments = Array.prototype.splice.call(arguments, 1);\n      }\n      for(var i = 0; i < callbacks.length; ++i) {\n        var callbackInfo = callbacks[i];\n        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n      }\n\n      return subject;\n    }\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('Eventify cannot use falsy object as events subject');\n  }\n  var reservedWords = ['on', 'fire', 'off'];\n  for (var i = 0; i < reservedWords.length; ++i) {\n    if (subject.hasOwnProperty(reservedWords[i])) {\n      throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n    }\n  }\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.forcelayout/node_modules/ngraph.events/index.js?");

/***/ }),

/***/ "./node_modules/ngraph.fromjson/index.js":
/*!***********************************************!*\
  !*** ./node_modules/ngraph.fromjson/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = load;\n\nvar createGraph = __webpack_require__(/*! ngraph.graph */ \"./node_modules/ngraph.graph/index.js\");\n\nfunction load(jsonGraph, nodeTransform, linkTransform) {\n  var stored;\n  nodeTransform = nodeTransform || id;\n  linkTransform = linkTransform || id;\n  if (typeof jsonGraph === 'string') {\n    stored = JSON.parse(jsonGraph);\n  } else {\n    stored = jsonGraph;\n  }\n\n  var graph = createGraph(),\n      i;\n\n  if (stored.links === undefined || stored.nodes === undefined) {\n    throw new Error('Cannot load graph without links and nodes');\n  }\n\n  for (i = 0; i < stored.nodes.length; ++i) {\n    var parsedNode = nodeTransform(stored.nodes[i]);\n    if (!parsedNode.hasOwnProperty('id')) {\n      throw new Error('Graph node format is invalid: Node id is missing');\n    }\n\n    graph.addNode(parsedNode.id, parsedNode.data);\n  }\n\n  for (i = 0; i < stored.links.length; ++i) {\n    var link = linkTransform(stored.links[i]);\n    if (!link.hasOwnProperty('fromId') || !link.hasOwnProperty('toId')) {\n      throw new Error('Graph link format is invalid. Both fromId and toId are required');\n    }\n\n    graph.addLink(link.fromId, link.toId, link.data);\n  }\n\n  return graph;\n}\n\nfunction id(x) { return x; }\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.fromjson/index.js?");

/***/ }),

/***/ "./node_modules/ngraph.graph/index.js":
/*!********************************************!*\
  !*** ./node_modules/ngraph.graph/index.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * @fileOverview Contains definition of the core graph object.\n */\n\n// TODO: need to change storage layer:\n// 1. Be able to get all nodes O(1)\n// 2. Be able to get number of links O(1)\n\n/**\n * @example\n *  var graph = require('ngraph.graph')();\n *  graph.addNode(1);     // graph has one node.\n *  graph.addLink(2, 3);  // now graph contains three nodes and one link.\n *\n */\nmodule.exports = createGraph;\n\nvar eventify = __webpack_require__(/*! ngraph.events */ \"./node_modules/ngraph.events/index.js\");\n\n/**\n * Creates a new graph\n */\nfunction createGraph(options) {\n  // Graph structure is maintained as dictionary of nodes\n  // and array of links. Each node has 'links' property which\n  // hold all links related to that node. And general links\n  // array is used to speed up all links enumeration. This is inefficient\n  // in terms of memory, but simplifies coding.\n  options = options || {};\n  if ('uniqueLinkId' in options) {\n    console.warn(\n      'ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\\n' +\n      'Use `multigraph` option instead\\n',\n      '\\n',\n      'Note: there is also change in default behavior: From now own each graph\\n'+\n      'is considered to be not a multigraph by default (each edge is unique).'\n    );\n\n    options.multigraph = options.uniqueLinkId;\n  }\n\n  // Dear reader, the non-multigraphs do not guarantee that there is only\n  // one link for a given pair of node. When this option is set to false\n  // we can save some memory and CPU (18% faster for non-multigraph);\n  if (options.multigraph === undefined) options.multigraph = false;\n\n  var nodes = typeof Object.create === 'function' ? Object.create(null) : {},\n    links = [],\n    // Hash of multi-edges. Used to track ids of edges between same nodes\n    multiEdges = {},\n    nodesCount = 0,\n    suspendEvents = 0,\n\n    forEachNode = createNodeIterator(),\n    createLink = options.multigraph ? createUniqueLink : createSingleLink,\n\n    // Our graph API provides means to listen to graph changes. Users can subscribe\n    // to be notified about changes in the graph by using `on` method. However\n    // in some cases they don't use it. To avoid unnecessary memory consumption\n    // we will not record graph changes until we have at least one subscriber.\n    // Code below supports this optimization.\n    //\n    // Accumulates all changes made during graph updates.\n    // Each change element contains:\n    //  changeType - one of the strings: 'add', 'remove' or 'update';\n    //  node - if change is related to node this property is set to changed graph's node;\n    //  link - if change is related to link this property is set to changed graph's link;\n    changes = [],\n    recordLinkChange = noop,\n    recordNodeChange = noop,\n    enterModification = noop,\n    exitModification = noop;\n\n  // this is our public API:\n  var graphPart = {\n    /**\n     * Adds node to the graph. If node with given id already exists in the graph\n     * its data is extended with whatever comes in 'data' argument.\n     *\n     * @param nodeId the node's identifier. A string or number is preferred.\n     * @param [data] additional data for the node being added. If node already\n     *   exists its data object is augmented with the new one.\n     *\n     * @return {node} The newly added node or node with given id if it already exists.\n     */\n    addNode: addNode,\n\n    /**\n     * Adds a link to the graph. The function always create a new\n     * link between two nodes. If one of the nodes does not exists\n     * a new node is created.\n     *\n     * @param fromId link start node id;\n     * @param toId link end node id;\n     * @param [data] additional data to be set on the new link;\n     *\n     * @return {link} The newly created link\n     */\n    addLink: addLink,\n\n    /**\n     * Removes link from the graph. If link does not exist does nothing.\n     *\n     * @param link - object returned by addLink() or getLinks() methods.\n     *\n     * @returns true if link was removed; false otherwise.\n     */\n    removeLink: removeLink,\n\n    /**\n     * Removes node with given id from the graph. If node does not exist in the graph\n     * does nothing.\n     *\n     * @param nodeId node's identifier passed to addNode() function.\n     *\n     * @returns true if node was removed; false otherwise.\n     */\n    removeNode: removeNode,\n\n    /**\n     * Gets node with given identifier. If node does not exist undefined value is returned.\n     *\n     * @param nodeId requested node identifier;\n     *\n     * @return {node} in with requested identifier or undefined if no such node exists.\n     */\n    getNode: getNode,\n\n    /**\n     * Gets number of nodes in this graph.\n     *\n     * @return number of nodes in the graph.\n     */\n    getNodesCount: function () {\n      return nodesCount;\n    },\n\n    /**\n     * Gets total number of links in the graph.\n     */\n    getLinksCount: function () {\n      return links.length;\n    },\n\n    /**\n     * Gets all links (inbound and outbound) from the node with given id.\n     * If node with given id is not found null is returned.\n     *\n     * @param nodeId requested node identifier.\n     *\n     * @return Array of links from and to requested node if such node exists;\n     *   otherwise null is returned.\n     */\n    getLinks: getLinks,\n\n    /**\n     * Invokes callback on each node of the graph.\n     *\n     * @param {Function(node)} callback Function to be invoked. The function\n     *   is passed one argument: visited node.\n     */\n    forEachNode: forEachNode,\n\n    /**\n     * Invokes callback on every linked (adjacent) node to the given one.\n     *\n     * @param nodeId Identifier of the requested node.\n     * @param {Function(node, link)} callback Function to be called on all linked nodes.\n     *   The function is passed two parameters: adjacent node and link object itself.\n     * @param oriented if true graph treated as oriented.\n     */\n    forEachLinkedNode: forEachLinkedNode,\n\n    /**\n     * Enumerates all links in the graph\n     *\n     * @param {Function(link)} callback Function to be called on all links in the graph.\n     *   The function is passed one parameter: graph's link object.\n     *\n     * Link object contains at least the following fields:\n     *  fromId - node id where link starts;\n     *  toId - node id where link ends,\n     *  data - additional data passed to graph.addLink() method.\n     */\n    forEachLink: forEachLink,\n\n    /**\n     * Suspend all notifications about graph changes until\n     * endUpdate is called.\n     */\n    beginUpdate: enterModification,\n\n    /**\n     * Resumes all notifications about graph changes and fires\n     * graph 'changed' event in case there are any pending changes.\n     */\n    endUpdate: exitModification,\n\n    /**\n     * Removes all nodes and links from the graph.\n     */\n    clear: clear,\n\n    /**\n     * Detects whether there is a link between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     * NOTE: this function is synonim for getLink()\n     *\n     * @returns link if there is one. null otherwise.\n     */\n    hasLink: getLink,\n\n    /**\n     * Detects whether there is a node with given id\n     * \n     * Operation complexity is O(1)\n     * NOTE: this function is synonim for getNode()\n     *\n     * @returns node if there is one; Falsy value otherwise.\n     */\n    hasNode: getNode,\n\n    /**\n     * Gets an edge between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     *\n     * @param {string} fromId link start identifier\n     * @param {string} toId link end identifier\n     *\n     * @returns link if there is one. null otherwise.\n     */\n    getLink: getLink\n  };\n\n  // this will add `on()` and `fire()` methods.\n  eventify(graphPart);\n\n  monitorSubscribers();\n\n  return graphPart;\n\n  function monitorSubscribers() {\n    var realOn = graphPart.on;\n\n    // replace real `on` with our temporary on, which will trigger change\n    // modification monitoring:\n    graphPart.on = on;\n\n    function on() {\n      // now it's time to start tracking stuff:\n      graphPart.beginUpdate = enterModification = enterModificationReal;\n      graphPart.endUpdate = exitModification = exitModificationReal;\n      recordLinkChange = recordLinkChangeReal;\n      recordNodeChange = recordNodeChangeReal;\n\n      // this will replace current `on` method with real pub/sub from `eventify`.\n      graphPart.on = realOn;\n      // delegate to real `on` handler:\n      return realOn.apply(graphPart, arguments);\n    }\n  }\n\n  function recordLinkChangeReal(link, changeType) {\n    changes.push({\n      link: link,\n      changeType: changeType\n    });\n  }\n\n  function recordNodeChangeReal(node, changeType) {\n    changes.push({\n      node: node,\n      changeType: changeType\n    });\n  }\n\n  function addNode(nodeId, data) {\n    if (nodeId === undefined) {\n      throw new Error('Invalid node identifier');\n    }\n\n    enterModification();\n\n    var node = getNode(nodeId);\n    if (!node) {\n      node = new Node(nodeId, data);\n      nodesCount++;\n      recordNodeChange(node, 'add');\n    } else {\n      node.data = data;\n      recordNodeChange(node, 'update');\n    }\n\n    nodes[nodeId] = node;\n\n    exitModification();\n    return node;\n  }\n\n  function getNode(nodeId) {\n    return nodes[nodeId];\n  }\n\n  function removeNode(nodeId) {\n    var node = getNode(nodeId);\n    if (!node) {\n      return false;\n    }\n\n    enterModification();\n\n    var prevLinks = node.links;\n    if (prevLinks) {\n      node.links = null;\n      for(var i = 0; i < prevLinks.length; ++i) {\n        removeLink(prevLinks[i]);\n      }\n    }\n\n    delete nodes[nodeId];\n    nodesCount--;\n\n    recordNodeChange(node, 'remove');\n\n    exitModification();\n\n    return true;\n  }\n\n\n  function addLink(fromId, toId, data) {\n    enterModification();\n\n    var fromNode = getNode(fromId) || addNode(fromId);\n    var toNode = getNode(toId) || addNode(toId);\n\n    var link = createLink(fromId, toId, data);\n\n    links.push(link);\n\n    // TODO: this is not cool. On large graphs potentially would consume more memory.\n    addLinkToNode(fromNode, link);\n    if (fromId !== toId) {\n      // make sure we are not duplicating links for self-loops\n      addLinkToNode(toNode, link);\n    }\n\n    recordLinkChange(link, 'add');\n\n    exitModification();\n\n    return link;\n  }\n\n  function createSingleLink(fromId, toId, data) {\n    var linkId = makeLinkId(fromId, toId);\n    return new Link(fromId, toId, data, linkId);\n  }\n\n  function createUniqueLink(fromId, toId, data) {\n    // TODO: Get rid of this method.\n    var linkId = makeLinkId(fromId, toId);\n    var isMultiEdge = multiEdges.hasOwnProperty(linkId);\n    if (isMultiEdge || getLink(fromId, toId)) {\n      if (!isMultiEdge) {\n        multiEdges[linkId] = 0;\n      }\n      var suffix = '@' + (++multiEdges[linkId]);\n      linkId = makeLinkId(fromId + suffix, toId + suffix);\n    }\n\n    return new Link(fromId, toId, data, linkId);\n  }\n\n  function getLinks(nodeId) {\n    var node = getNode(nodeId);\n    return node ? node.links : null;\n  }\n\n  function removeLink(link) {\n    if (!link) {\n      return false;\n    }\n    var idx = indexOfElementInArray(link, links);\n    if (idx < 0) {\n      return false;\n    }\n\n    enterModification();\n\n    links.splice(idx, 1);\n\n    var fromNode = getNode(link.fromId);\n    var toNode = getNode(link.toId);\n\n    if (fromNode) {\n      idx = indexOfElementInArray(link, fromNode.links);\n      if (idx >= 0) {\n        fromNode.links.splice(idx, 1);\n      }\n    }\n\n    if (toNode) {\n      idx = indexOfElementInArray(link, toNode.links);\n      if (idx >= 0) {\n        toNode.links.splice(idx, 1);\n      }\n    }\n\n    recordLinkChange(link, 'remove');\n\n    exitModification();\n\n    return true;\n  }\n\n  function getLink(fromNodeId, toNodeId) {\n    // TODO: Use sorted links to speed this up\n    var node = getNode(fromNodeId),\n      i;\n    if (!node || !node.links) {\n      return null;\n    }\n\n    for (i = 0; i < node.links.length; ++i) {\n      var link = node.links[i];\n      if (link.fromId === fromNodeId && link.toId === toNodeId) {\n        return link;\n      }\n    }\n\n    return null; // no link.\n  }\n\n  function clear() {\n    enterModification();\n    forEachNode(function(node) {\n      removeNode(node.id);\n    });\n    exitModification();\n  }\n\n  function forEachLink(callback) {\n    var i, length;\n    if (typeof callback === 'function') {\n      for (i = 0, length = links.length; i < length; ++i) {\n        callback(links[i]);\n      }\n    }\n  }\n\n  function forEachLinkedNode(nodeId, callback, oriented) {\n    var node = getNode(nodeId);\n\n    if (node && node.links && typeof callback === 'function') {\n      if (oriented) {\n        return forEachOrientedLink(node.links, nodeId, callback);\n      } else {\n        return forEachNonOrientedLink(node.links, nodeId, callback);\n      }\n    }\n  }\n\n  function forEachNonOrientedLink(links, nodeId, callback) {\n    var quitFast;\n    for (var i = 0; i < links.length; ++i) {\n      var link = links[i];\n      var linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;\n\n      quitFast = callback(nodes[linkedNodeId], link);\n      if (quitFast) {\n        return true; // Client does not need more iterations. Break now.\n      }\n    }\n  }\n\n  function forEachOrientedLink(links, nodeId, callback) {\n    var quitFast;\n    for (var i = 0; i < links.length; ++i) {\n      var link = links[i];\n      if (link.fromId === nodeId) {\n        quitFast = callback(nodes[link.toId], link);\n        if (quitFast) {\n          return true; // Client does not need more iterations. Break now.\n        }\n      }\n    }\n  }\n\n  // we will not fire anything until users of this library explicitly call `on()`\n  // method.\n  function noop() {}\n\n  // Enter, Exit modification allows bulk graph updates without firing events.\n  function enterModificationReal() {\n    suspendEvents += 1;\n  }\n\n  function exitModificationReal() {\n    suspendEvents -= 1;\n    if (suspendEvents === 0 && changes.length > 0) {\n      graphPart.fire('changed', changes);\n      changes.length = 0;\n    }\n  }\n\n  function createNodeIterator() {\n    // Object.keys iterator is 1.3x faster than `for in` loop.\n    // See `https://github.com/anvaka/ngraph.graph/tree/bench-for-in-vs-obj-keys`\n    // branch for perf test\n    return Object.keys ? objectKeysIterator : forInIterator;\n  }\n\n  function objectKeysIterator(callback) {\n    if (typeof callback !== 'function') {\n      return;\n    }\n\n    var keys = Object.keys(nodes);\n    for (var i = 0; i < keys.length; ++i) {\n      if (callback(nodes[keys[i]])) {\n        return true; // client doesn't want to proceed. Return.\n      }\n    }\n  }\n\n  function forInIterator(callback) {\n    if (typeof callback !== 'function') {\n      return;\n    }\n    var node;\n\n    for (node in nodes) {\n      if (callback(nodes[node])) {\n        return true; // client doesn't want to proceed. Return.\n      }\n    }\n  }\n}\n\n// need this for old browsers. Should this be a separate module?\nfunction indexOfElementInArray(element, array) {\n  if (!array) return -1;\n\n  if (array.indexOf) {\n    return array.indexOf(element);\n  }\n\n  var len = array.length,\n    i;\n\n  for (i = 0; i < len; i += 1) {\n    if (array[i] === element) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Internal structure to represent node;\n */\nfunction Node(id, data) {\n  this.id = id;\n  this.links = null;\n  this.data = data;\n}\n\nfunction addLinkToNode(node, link) {\n  if (node.links) {\n    node.links.push(link);\n  } else {\n    node.links = [link];\n  }\n}\n\n/**\n * Internal structure to represent links;\n */\nfunction Link(fromId, toId, data, id) {\n  this.fromId = fromId;\n  this.toId = toId;\n  this.data = data;\n  this.id = id;\n}\n\nfunction hashCode(str) {\n  var hash = 0, i, chr, len;\n  if (str.length == 0) return hash;\n  for (i = 0, len = str.length; i < len; i++) {\n    chr   = str.charCodeAt(i);\n    hash  = ((hash << 5) - hash) + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return hash;\n}\n\nfunction makeLinkId(fromId, toId) {\n  return fromId.toString() + '👉 ' + toId.toString();\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.graph/index.js?");

/***/ }),

/***/ "./node_modules/ngraph.merge/index.js":
/*!********************************************!*\
  !*** ./node_modules/ngraph.merge/index.js ***!
  \********************************************/
/***/ (function(module) {

eval("module.exports = merge;\n\n/**\n * Augments `target` with properties in `options`. Does not override\n * target's properties if they are defined and matches expected type in \n * options\n *\n * @returns {Object} merged object\n */\nfunction merge(target, options) {\n  var key;\n  if (!target) { target = {}; }\n  if (options) {\n    for (key in options) {\n      if (options.hasOwnProperty(key)) {\n        var targetHasIt = target.hasOwnProperty(key),\n            optionsValueType = typeof options[key],\n            shouldReplace = !targetHasIt || (typeof target[key] !== optionsValueType);\n\n        if (shouldReplace) {\n          target[key] = options[key];\n        } else if (optionsValueType === 'object') {\n          // go deep, don't care about loops here, we are simple API!:\n          target[key] = merge(target[key], options[key]);\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.merge/index.js?");

/***/ }),

/***/ "./node_modules/ngraph.physics.primitives/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/ngraph.physics.primitives/index.js ***!
  \*********************************************************/
/***/ (function(module) {

eval("module.exports = {\n  Body: Body,\n  Vector2d: Vector2d,\n  Body3d: Body3d,\n  Vector3d: Vector3d\n};\n\nfunction Body(x, y) {\n  this.pos = new Vector2d(x, y);\n  this.prevPos = new Vector2d(x, y);\n  this.force = new Vector2d();\n  this.velocity = new Vector2d();\n  this.mass = 1;\n}\n\nBody.prototype.setPosition = function (x, y) {\n  this.prevPos.x = this.pos.x = x;\n  this.prevPos.y = this.pos.y = y;\n};\n\nfunction Vector2d(x, y) {\n  if (x && typeof x !== 'number') {\n    // could be another vector\n    this.x = typeof x.x === 'number' ? x.x : 0;\n    this.y = typeof x.y === 'number' ? x.y : 0;\n  } else {\n    this.x = typeof x === 'number' ? x : 0;\n    this.y = typeof y === 'number' ? y : 0;\n  }\n}\n\nVector2d.prototype.reset = function () {\n  this.x = this.y = 0;\n};\n\nfunction Body3d(x, y, z) {\n  this.pos = new Vector3d(x, y, z);\n  this.prevPos = new Vector3d(x, y, z);\n  this.force = new Vector3d();\n  this.velocity = new Vector3d();\n  this.mass = 1;\n}\n\nBody3d.prototype.setPosition = function (x, y, z) {\n  this.prevPos.x = this.pos.x = x;\n  this.prevPos.y = this.pos.y = y;\n  this.prevPos.z = this.pos.z = z;\n};\n\nfunction Vector3d(x, y, z) {\n  if (x && typeof x !== 'number') {\n    // could be another vector\n    this.x = typeof x.x === 'number' ? x.x : 0;\n    this.y = typeof x.y === 'number' ? x.y : 0;\n    this.z = typeof x.z === 'number' ? x.z : 0;\n  } else {\n    this.x = typeof x === 'number' ? x : 0;\n    this.y = typeof y === 'number' ? y : 0;\n    this.z = typeof z === 'number' ? z : 0;\n  }\n};\n\nVector3d.prototype.reset = function () {\n  this.x = this.y = this.z = 0;\n};\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.physics.primitives/index.js?");

/***/ }),

/***/ "./node_modules/ngraph.physics.simulator/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ngraph.physics.simulator/index.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * Manages a simulation of physical forces acting on bodies and springs.\n */\nmodule.exports = physicsSimulator;\n\nfunction physicsSimulator(settings) {\n  var Spring = __webpack_require__(/*! ./lib/spring */ \"./node_modules/ngraph.physics.simulator/lib/spring.js\");\n  var expose = __webpack_require__(/*! ngraph.expose */ \"./node_modules/ngraph.expose/index.js\");\n  var merge = __webpack_require__(/*! ngraph.merge */ \"./node_modules/ngraph.merge/index.js\");\n  var eventify = __webpack_require__(/*! ngraph.events */ \"./node_modules/ngraph.events/index.js\");\n\n  settings = merge(settings, {\n      /**\n       * Ideal length for links (springs in physical model).\n       */\n      springLength: 30,\n\n      /**\n       * Hook's law coefficient. 1 - solid spring.\n       */\n      springCoeff: 0.0008,\n\n      /**\n       * Coulomb's law coefficient. It's used to repel nodes thus should be negative\n       * if you make it positive nodes start attract each other :).\n       */\n      gravity: -1.2,\n\n      /**\n       * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).\n       * The closer it's to 1 the more nodes algorithm will have to go through.\n       * Setting it to one makes Barnes Hut simulation no different from\n       * brute-force forces calculation (each node is considered).\n       */\n      theta: 0.8,\n\n      /**\n       * Drag force coefficient. Used to slow down system, thus should be less than 1.\n       * The closer it is to 0 the less tight system will be.\n       */\n      dragCoeff: 0.02,\n\n      /**\n       * Default time step (dt) for forces integration\n       */\n      timeStep : 20,\n  });\n\n  // We allow clients to override basic factory methods:\n  var createQuadTree = settings.createQuadTree || __webpack_require__(/*! ngraph.quadtreebh */ \"./node_modules/ngraph.quadtreebh/index.js\");\n  var createBounds = settings.createBounds || __webpack_require__(/*! ./lib/bounds */ \"./node_modules/ngraph.physics.simulator/lib/bounds.js\");\n  var createDragForce = settings.createDragForce || __webpack_require__(/*! ./lib/dragForce */ \"./node_modules/ngraph.physics.simulator/lib/dragForce.js\");\n  var createSpringForce = settings.createSpringForce || __webpack_require__(/*! ./lib/springForce */ \"./node_modules/ngraph.physics.simulator/lib/springForce.js\");\n  var integrate = settings.integrator || __webpack_require__(/*! ./lib/eulerIntegrator */ \"./node_modules/ngraph.physics.simulator/lib/eulerIntegrator.js\");\n  var createBody = settings.createBody || __webpack_require__(/*! ./lib/createBody */ \"./node_modules/ngraph.physics.simulator/lib/createBody.js\");\n\n  var bodies = [], // Bodies in this simulation.\n      springs = [], // Springs in this simulation.\n      quadTree =  createQuadTree(settings),\n      bounds = createBounds(bodies, settings),\n      springForce = createSpringForce(settings),\n      dragForce = createDragForce(settings);\n\n  var bboxNeedsUpdate = true;\n  var totalMovement = 0; // how much movement we made on last step\n\n  var publicApi = {\n    /**\n     * Array of bodies, registered with current simulator\n     *\n     * Note: To add new body, use addBody() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n    bodies: bodies,\n\n    quadTree: quadTree,\n\n    /**\n     * Array of springs, registered with current simulator\n     *\n     * Note: To add new spring, use addSpring() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n    springs: springs,\n\n    /**\n     * Returns settings with which current simulator was initialized\n     */\n    settings: settings,\n\n    /**\n     * Performs one step of force simulation.\n     *\n     * @returns {boolean} true if system is considered stable; False otherwise.\n     */\n    step: function () {\n      accumulateForces();\n\n      var movement = integrate(bodies, settings.timeStep);\n      bounds.update();\n\n      return movement;\n    },\n\n    /**\n     * Adds body to the system\n     *\n     * @param {ngraph.physics.primitives.Body} body physical body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n    addBody: function (body) {\n      if (!body) {\n        throw new Error('Body is required');\n      }\n      bodies.push(body);\n\n      return body;\n    },\n\n    /**\n     * Adds body to the system at given position\n     *\n     * @param {Object} pos position of a body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n    addBodyAt: function (pos) {\n      if (!pos) {\n        throw new Error('Body position is required');\n      }\n      var body = createBody(pos);\n      bodies.push(body);\n\n      return body;\n    },\n\n    /**\n     * Removes body from the system\n     *\n     * @param {ngraph.physics.primitives.Body} body to remove\n     *\n     * @returns {Boolean} true if body found and removed. falsy otherwise;\n     */\n    removeBody: function (body) {\n      if (!body) { return; }\n\n      var idx = bodies.indexOf(body);\n      if (idx < 0) { return; }\n\n      bodies.splice(idx, 1);\n      if (bodies.length === 0) {\n        bounds.reset();\n      }\n      return true;\n    },\n\n    /**\n     * Adds a spring to this simulation.\n     *\n     * @returns {Object} - a handle for a spring. If you want to later remove\n     * spring pass it to removeSpring() method.\n     */\n    addSpring: function (body1, body2, springLength, springWeight, springCoefficient) {\n      if (!body1 || !body2) {\n        throw new Error('Cannot add null spring to force simulator');\n      }\n\n      if (typeof springLength !== 'number') {\n        springLength = -1; // assume global configuration\n      }\n\n      var spring = new Spring(body1, body2, springLength, springCoefficient >= 0 ? springCoefficient : -1, springWeight);\n      springs.push(spring);\n\n      // TODO: could mark simulator as dirty.\n      return spring;\n    },\n\n    /**\n     * Returns amount of movement performed on last step() call\n     */\n    getTotalMovement: function () {\n      return totalMovement;\n    },\n\n    /**\n     * Removes spring from the system\n     *\n     * @param {Object} spring to remove. Spring is an object returned by addSpring\n     *\n     * @returns {Boolean} true if spring found and removed. falsy otherwise;\n     */\n    removeSpring: function (spring) {\n      if (!spring) { return; }\n      var idx = springs.indexOf(spring);\n      if (idx > -1) {\n        springs.splice(idx, 1);\n        return true;\n      }\n    },\n\n    getBestNewBodyPosition: function (neighbors) {\n      return bounds.getBestNewPosition(neighbors);\n    },\n\n    /**\n     * Returns bounding box which covers all bodies\n     */\n    getBBox: function () {\n      if (bboxNeedsUpdate) {\n        bounds.update();\n        bboxNeedsUpdate = false;\n      }\n      return bounds.box;\n    },\n\n    invalidateBBox: function () {\n      bboxNeedsUpdate = true;\n    },\n\n    gravity: function (value) {\n      if (value !== undefined) {\n        settings.gravity = value;\n        quadTree.options({gravity: value});\n        return this;\n      } else {\n        return settings.gravity;\n      }\n    },\n\n    theta: function (value) {\n      if (value !== undefined) {\n        settings.theta = value;\n        quadTree.options({theta: value});\n        return this;\n      } else {\n        return settings.theta;\n      }\n    }\n  };\n\n  // allow settings modification via public API:\n  expose(settings, publicApi);\n\n  eventify(publicApi);\n\n  return publicApi;\n\n  function accumulateForces() {\n    // Accumulate forces acting on bodies.\n    var body,\n        i = bodies.length;\n\n    if (i) {\n      // only add bodies if there the array is not empty:\n      quadTree.insertBodies(bodies); // performance: O(n * log n)\n      while (i--) {\n        body = bodies[i];\n        // If body is pinned there is no point updating its forces - it should\n        // never move:\n        if (!body.isPinned) {\n          body.force.reset();\n\n          quadTree.updateBodyForce(body);\n          dragForce.update(body);\n        }\n      }\n    }\n\n    i = springs.length;\n    while(i--) {\n      springForce.update(springs[i]);\n    }\n  }\n};\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.physics.simulator/index.js?");

/***/ }),

/***/ "./node_modules/ngraph.physics.simulator/lib/bounds.js":
/*!*************************************************************!*\
  !*** ./node_modules/ngraph.physics.simulator/lib/bounds.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = function (bodies, settings) {\n  var random = (__webpack_require__(/*! ngraph.random */ \"./node_modules/ngraph.random/index.js\").random)(42);\n  var boundingBox =  { x1: 0, y1: 0, x2: 0, y2: 0 };\n\n  return {\n    box: boundingBox,\n\n    update: updateBoundingBox,\n\n    reset : function () {\n      boundingBox.x1 = boundingBox.y1 = 0;\n      boundingBox.x2 = boundingBox.y2 = 0;\n    },\n\n    getBestNewPosition: function (neighbors) {\n      var graphRect = boundingBox;\n\n      var baseX = 0, baseY = 0;\n\n      if (neighbors.length) {\n        for (var i = 0; i < neighbors.length; ++i) {\n          baseX += neighbors[i].pos.x;\n          baseY += neighbors[i].pos.y;\n        }\n\n        baseX /= neighbors.length;\n        baseY /= neighbors.length;\n      } else {\n        baseX = (graphRect.x1 + graphRect.x2) / 2;\n        baseY = (graphRect.y1 + graphRect.y2) / 2;\n      }\n\n      var springLength = settings.springLength;\n      return {\n        x: baseX + random.next(springLength) - springLength / 2,\n        y: baseY + random.next(springLength) - springLength / 2\n      };\n    }\n  };\n\n  function updateBoundingBox() {\n    var i = bodies.length;\n    if (i === 0) { return; } // don't have to wory here.\n\n    var x1 = Number.MAX_VALUE,\n        y1 = Number.MAX_VALUE,\n        x2 = Number.MIN_VALUE,\n        y2 = Number.MIN_VALUE;\n\n    while(i--) {\n      // this is O(n), could it be done faster with quadtree?\n      // how about pinned nodes?\n      var body = bodies[i];\n      if (body.isPinned) {\n        body.pos.x = body.prevPos.x;\n        body.pos.y = body.prevPos.y;\n      } else {\n        body.prevPos.x = body.pos.x;\n        body.prevPos.y = body.pos.y;\n      }\n      if (body.pos.x < x1) {\n        x1 = body.pos.x;\n      }\n      if (body.pos.x > x2) {\n        x2 = body.pos.x;\n      }\n      if (body.pos.y < y1) {\n        y1 = body.pos.y;\n      }\n      if (body.pos.y > y2) {\n        y2 = body.pos.y;\n      }\n    }\n\n    boundingBox.x1 = x1;\n    boundingBox.x2 = x2;\n    boundingBox.y1 = y1;\n    boundingBox.y2 = y2;\n  }\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.physics.simulator/lib/bounds.js?");

/***/ }),

/***/ "./node_modules/ngraph.physics.simulator/lib/createBody.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ngraph.physics.simulator/lib/createBody.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var physics = __webpack_require__(/*! ngraph.physics.primitives */ \"./node_modules/ngraph.physics.primitives/index.js\");\n\nmodule.exports = function(pos) {\n  return new physics.Body(pos);\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.physics.simulator/lib/createBody.js?");

/***/ }),

/***/ "./node_modules/ngraph.physics.simulator/lib/dragForce.js":
/*!****************************************************************!*\
  !*** ./node_modules/ngraph.physics.simulator/lib/dragForce.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * Represents drag force, which reduces force value on each step by given\n * coefficient.\n *\n * @param {Object} options for the drag force\n * @param {Number=} options.dragCoeff drag force coefficient. 0.1 by default\n */\nmodule.exports = function (options) {\n  var merge = __webpack_require__(/*! ngraph.merge */ \"./node_modules/ngraph.merge/index.js\"),\n      expose = __webpack_require__(/*! ngraph.expose */ \"./node_modules/ngraph.expose/index.js\");\n\n  options = merge(options, {\n    dragCoeff: 0.02\n  });\n\n  var api = {\n    update : function (body) {\n      body.force.x -= options.dragCoeff * body.velocity.x;\n      body.force.y -= options.dragCoeff * body.velocity.y;\n    }\n  };\n\n  // let easy access to dragCoeff:\n  expose(options, api, ['dragCoeff']);\n\n  return api;\n};\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.physics.simulator/lib/dragForce.js?");

/***/ }),

/***/ "./node_modules/ngraph.physics.simulator/lib/eulerIntegrator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ngraph.physics.simulator/lib/eulerIntegrator.js ***!
  \**********************************************************************/
/***/ (function(module) {

eval("/**\n * Performs forces integration, using given timestep. Uses Euler method to solve\n * differential equation (http://en.wikipedia.org/wiki/Euler_method ).\n *\n * @returns {Number} squared distance of total position updates.\n */\n\nmodule.exports = integrate;\n\nfunction integrate(bodies, timeStep) {\n  var dx = 0, tx = 0,\n      dy = 0, ty = 0,\n      i,\n      max = bodies.length;\n\n  if (max === 0) {\n    return 0;\n  }\n\n  for (i = 0; i < max; ++i) {\n    var body = bodies[i],\n        coeff = timeStep / body.mass;\n\n    body.velocity.x += coeff * body.force.x;\n    body.velocity.y += coeff * body.force.y;\n    var vx = body.velocity.x,\n        vy = body.velocity.y,\n        v = Math.sqrt(vx * vx + vy * vy);\n\n    if (v > 1) {\n      body.velocity.x = vx / v;\n      body.velocity.y = vy / v;\n    }\n\n    dx = timeStep * body.velocity.x;\n    dy = timeStep * body.velocity.y;\n\n    body.pos.x += dx;\n    body.pos.y += dy;\n\n    tx += Math.abs(dx); ty += Math.abs(dy);\n  }\n\n  return (tx * tx + ty * ty)/max;\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.physics.simulator/lib/eulerIntegrator.js?");

/***/ }),

/***/ "./node_modules/ngraph.physics.simulator/lib/spring.js":
/*!*************************************************************!*\
  !*** ./node_modules/ngraph.physics.simulator/lib/spring.js ***!
  \*************************************************************/
/***/ (function(module) {

eval("module.exports = Spring;\n\n/**\n * Represents a physical spring. Spring connects two bodies, has rest length\n * stiffness coefficient and optional weight\n */\nfunction Spring(fromBody, toBody, length, coeff, weight) {\n    this.from = fromBody;\n    this.to = toBody;\n    this.length = length;\n    this.coeff = coeff;\n\n    this.weight = typeof weight === 'number' ? weight : 1;\n};\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.physics.simulator/lib/spring.js?");

/***/ }),

/***/ "./node_modules/ngraph.physics.simulator/lib/springForce.js":
/*!******************************************************************!*\
  !*** ./node_modules/ngraph.physics.simulator/lib/springForce.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * Represents spring force, which updates forces acting on two bodies, conntected\n * by a spring.\n *\n * @param {Object} options for the spring force\n * @param {Number=} options.springCoeff spring force coefficient.\n * @param {Number=} options.springLength desired length of a spring at rest.\n */\nmodule.exports = function (options) {\n  var merge = __webpack_require__(/*! ngraph.merge */ \"./node_modules/ngraph.merge/index.js\");\n  var random = (__webpack_require__(/*! ngraph.random */ \"./node_modules/ngraph.random/index.js\").random)(42);\n  var expose = __webpack_require__(/*! ngraph.expose */ \"./node_modules/ngraph.expose/index.js\");\n\n  options = merge(options, {\n    springCoeff: 0.0002,\n    springLength: 80\n  });\n\n  var api = {\n    /**\n     * Upsates forces acting on a spring\n     */\n    update : function (spring) {\n      var body1 = spring.from,\n          body2 = spring.to,\n          length = spring.length < 0 ? options.springLength : spring.length,\n          dx = body2.pos.x - body1.pos.x,\n          dy = body2.pos.y - body1.pos.y,\n          r = Math.sqrt(dx * dx + dy * dy);\n\n      if (r === 0) {\n          dx = (random.nextDouble() - 0.5) / 50;\n          dy = (random.nextDouble() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy);\n      }\n\n      var d = r - length;\n      var coeff = ((!spring.coeff || spring.coeff < 0) ? options.springCoeff : spring.coeff) * d / r * spring.weight;\n\n      body1.force.x += coeff * dx;\n      body1.force.y += coeff * dy;\n\n      body2.force.x -= coeff * dx;\n      body2.force.y -= coeff * dy;\n    }\n  };\n\n  expose(options, api, ['springCoeff', 'springLength']);\n  return api;\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.physics.simulator/lib/springForce.js?");

/***/ }),

/***/ "./node_modules/ngraph.quadtreebh/index.js":
/*!*************************************************!*\
  !*** ./node_modules/ngraph.quadtreebh/index.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * This is Barnes Hut simulation algorithm for 2d case. Implementation\n * is highly optimized (avoids recusion and gc pressure)\n *\n * http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html\n */\n\nmodule.exports = function(options) {\n  options = options || {};\n  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;\n  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;\n\n  // we require deterministic randomness here\n  var random = (__webpack_require__(/*! ngraph.random */ \"./node_modules/ngraph.random/index.js\").random)(1984),\n    Node = __webpack_require__(/*! ./node */ \"./node_modules/ngraph.quadtreebh/node.js\"),\n    InsertStack = __webpack_require__(/*! ./insertStack */ \"./node_modules/ngraph.quadtreebh/insertStack.js\"),\n    isSamePosition = __webpack_require__(/*! ./isSamePosition */ \"./node_modules/ngraph.quadtreebh/isSamePosition.js\");\n\n  var gravity = options.gravity,\n    updateQueue = [],\n    insertStack = new InsertStack(),\n    theta = options.theta,\n\n    nodesCache = [],\n    currentInCache = 0,\n    root = newNode();\n\n  return {\n    insertBodies: insertBodies,\n    /**\n     * Gets root node if its present\n     */\n    getRoot: function() {\n      return root;\n    },\n    updateBodyForce: update,\n    options: function(newOptions) {\n      if (newOptions) {\n        if (typeof newOptions.gravity === 'number') {\n          gravity = newOptions.gravity;\n        }\n        if (typeof newOptions.theta === 'number') {\n          theta = newOptions.theta;\n        }\n\n        return this;\n      }\n\n      return {\n        gravity: gravity,\n        theta: theta\n      };\n    }\n  };\n\n  function newNode() {\n    // To avoid pressure on GC we reuse nodes.\n    var node = nodesCache[currentInCache];\n    if (node) {\n      node.quad0 = null;\n      node.quad1 = null;\n      node.quad2 = null;\n      node.quad3 = null;\n      node.body = null;\n      node.mass = node.massX = node.massY = 0;\n      node.left = node.right = node.top = node.bottom = 0;\n    } else {\n      node = new Node();\n      nodesCache[currentInCache] = node;\n    }\n\n    ++currentInCache;\n    return node;\n  }\n\n  function update(sourceBody) {\n    var queue = updateQueue,\n      v,\n      dx,\n      dy,\n      r, fx = 0,\n      fy = 0,\n      queueLength = 1,\n      shiftIdx = 0,\n      pushIdx = 1;\n\n    queue[0] = root;\n\n    while (queueLength) {\n      var node = queue[shiftIdx],\n        body = node.body;\n\n      queueLength -= 1;\n      shiftIdx += 1;\n      var differentBody = (body !== sourceBody);\n      if (body && differentBody) {\n        // If the current node is a leaf node (and it is not source body),\n        // calculate the force exerted by the current node on body, and add this\n        // amount to body's net force.\n        dx = body.pos.x - sourceBody.pos.x;\n        dy = body.pos.y - sourceBody.pos.y;\n        r = Math.sqrt(dx * dx + dy * dy);\n\n        if (r === 0) {\n          // Poor man's protection against zero distance.\n          dx = (random.nextDouble() - 0.5) / 50;\n          dy = (random.nextDouble() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy);\n        }\n\n        // This is standard gravition force calculation but we divide\n        // by r^3 to save two operations when normalizing force vector.\n        v = gravity * body.mass * sourceBody.mass / (r * r * r);\n        fx += v * dx;\n        fy += v * dy;\n      } else if (differentBody) {\n        // Otherwise, calculate the ratio s / r,  where s is the width of the region\n        // represented by the internal node, and r is the distance between the body\n        // and the node's center-of-mass\n        dx = node.massX / node.mass - sourceBody.pos.x;\n        dy = node.massY / node.mass - sourceBody.pos.y;\n        r = Math.sqrt(dx * dx + dy * dy);\n\n        if (r === 0) {\n          // Sorry about code duplucation. I don't want to create many functions\n          // right away. Just want to see performance first.\n          dx = (random.nextDouble() - 0.5) / 50;\n          dy = (random.nextDouble() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy);\n        }\n        // If s / r < θ, treat this internal node as a single body, and calculate the\n        // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n        if ((node.right - node.left) / r < theta) {\n          // in the if statement above we consider node's width only\n          // because the region was squarified during tree creation.\n          // Thus there is no difference between using width or height.\n          v = gravity * node.mass * sourceBody.mass / (r * r * r);\n          fx += v * dx;\n          fy += v * dy;\n        } else {\n          // Otherwise, run the procedure recursively on each of the current node's children.\n\n          // I intentionally unfolded this loop, to save several CPU cycles.\n          if (node.quad0) {\n            queue[pushIdx] = node.quad0;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n          if (node.quad1) {\n            queue[pushIdx] = node.quad1;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n          if (node.quad2) {\n            queue[pushIdx] = node.quad2;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n          if (node.quad3) {\n            queue[pushIdx] = node.quad3;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n        }\n      }\n    }\n\n    sourceBody.force.x += fx;\n    sourceBody.force.y += fy;\n  }\n\n  function insertBodies(bodies) {\n    var x1 = Number.MAX_VALUE,\n      y1 = Number.MAX_VALUE,\n      x2 = Number.MIN_VALUE,\n      y2 = Number.MIN_VALUE,\n      i,\n      max = bodies.length;\n\n    // To reduce quad tree depth we are looking for exact bounding box of all particles.\n    i = max;\n    while (i--) {\n      var x = bodies[i].pos.x;\n      var y = bodies[i].pos.y;\n      if (x < x1) {\n        x1 = x;\n      }\n      if (x > x2) {\n        x2 = x;\n      }\n      if (y < y1) {\n        y1 = y;\n      }\n      if (y > y2) {\n        y2 = y;\n      }\n    }\n\n    // Squarify the bounds.\n    var dx = x2 - x1,\n      dy = y2 - y1;\n    if (dx > dy) {\n      y2 = y1 + dx;\n    } else {\n      x2 = x1 + dy;\n    }\n\n    currentInCache = 0;\n    root = newNode();\n    root.left = x1;\n    root.right = x2;\n    root.top = y1;\n    root.bottom = y2;\n\n    i = max - 1;\n    if (i >= 0) {\n      root.body = bodies[i];\n    }\n    while (i--) {\n      insert(bodies[i], root);\n    }\n  }\n\n  function insert(newBody) {\n    insertStack.reset();\n    insertStack.push(root, newBody);\n\n    while (!insertStack.isEmpty()) {\n      var stackItem = insertStack.pop(),\n        node = stackItem.node,\n        body = stackItem.body;\n\n      if (!node.body) {\n        // This is internal node. Update the total mass of the node and center-of-mass.\n        var x = body.pos.x;\n        var y = body.pos.y;\n        node.mass = node.mass + body.mass;\n        node.massX = node.massX + body.mass * x;\n        node.massY = node.massY + body.mass * y;\n\n        // Recursively insert the body in the appropriate quadrant.\n        // But first find the appropriate quadrant.\n        var quadIdx = 0, // Assume we are in the 0's quad.\n          left = node.left,\n          right = (node.right + left) / 2,\n          top = node.top,\n          bottom = (node.bottom + top) / 2;\n\n        if (x > right) { // somewhere in the eastern part.\n          quadIdx = quadIdx + 1;\n          left = right;\n          right = node.right;\n        }\n        if (y > bottom) { // and in south.\n          quadIdx = quadIdx + 2;\n          top = bottom;\n          bottom = node.bottom;\n        }\n\n        var child = getChild(node, quadIdx);\n        if (!child) {\n          // The node is internal but this quadrant is not taken. Add\n          // subnode to it.\n          child = newNode();\n          child.left = left;\n          child.top = top;\n          child.right = right;\n          child.bottom = bottom;\n          child.body = body;\n\n          setChild(node, quadIdx, child);\n        } else {\n          // continue searching in this quadrant.\n          insertStack.push(child, body);\n        }\n      } else {\n        // We are trying to add to the leaf node.\n        // We have to convert current leaf into internal node\n        // and continue adding two nodes.\n        var oldBody = node.body;\n        node.body = null; // internal nodes do not cary bodies\n\n        if (isSamePosition(oldBody.pos, body.pos)) {\n          // Prevent infinite subdivision by bumping one node\n          // anywhere in this quadrant\n          var retriesCount = 3;\n          do {\n            var offset = random.nextDouble();\n            var dx = (node.right - node.left) * offset;\n            var dy = (node.bottom - node.top) * offset;\n\n            oldBody.pos.x = node.left + dx;\n            oldBody.pos.y = node.top + dy;\n            retriesCount -= 1;\n            // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n\n          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n            // This is very bad, we ran out of precision.\n            // if we do not return from the method we'll get into\n            // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n            // Next layout iteration should get larger bounding box in the first step and fix this\n            return;\n          }\n        }\n        // Next iteration should subdivide node further.\n        insertStack.push(node, oldBody);\n        insertStack.push(node, body);\n      }\n    }\n  }\n};\n\nfunction getChild(node, idx) {\n  if (idx === 0) return node.quad0;\n  if (idx === 1) return node.quad1;\n  if (idx === 2) return node.quad2;\n  if (idx === 3) return node.quad3;\n  return null;\n}\n\nfunction setChild(node, idx, child) {\n  if (idx === 0) node.quad0 = child;\n  else if (idx === 1) node.quad1 = child;\n  else if (idx === 2) node.quad2 = child;\n  else if (idx === 3) node.quad3 = child;\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.quadtreebh/index.js?");

/***/ }),

/***/ "./node_modules/ngraph.quadtreebh/insertStack.js":
/*!*******************************************************!*\
  !*** ./node_modules/ngraph.quadtreebh/insertStack.js ***!
  \*******************************************************/
/***/ (function(module) {

eval("module.exports = InsertStack;\n\n/**\n * Our implmentation of QuadTree is non-recursive to avoid GC hit\n * This data structure represent stack of elements\n * which we are trying to insert into quad tree.\n */\nfunction InsertStack () {\n    this.stack = [];\n    this.popIdx = 0;\n}\n\nInsertStack.prototype = {\n    isEmpty: function() {\n        return this.popIdx === 0;\n    },\n    push: function (node, body) {\n        var item = this.stack[this.popIdx];\n        if (!item) {\n            // we are trying to avoid memory pressue: create new element\n            // only when absolutely necessary\n            this.stack[this.popIdx] = new InsertStackElement(node, body);\n        } else {\n            item.node = node;\n            item.body = body;\n        }\n        ++this.popIdx;\n    },\n    pop: function () {\n        if (this.popIdx > 0) {\n            return this.stack[--this.popIdx];\n        }\n    },\n    reset: function () {\n        this.popIdx = 0;\n    }\n};\n\nfunction InsertStackElement(node, body) {\n    this.node = node; // QuadTree node\n    this.body = body; // physical body which needs to be inserted to node\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.quadtreebh/insertStack.js?");

/***/ }),

/***/ "./node_modules/ngraph.quadtreebh/isSamePosition.js":
/*!**********************************************************!*\
  !*** ./node_modules/ngraph.quadtreebh/isSamePosition.js ***!
  \**********************************************************/
/***/ (function(module) {

eval("module.exports = function isSamePosition(point1, point2) {\n    var dx = Math.abs(point1.x - point2.x);\n    var dy = Math.abs(point1.y - point2.y);\n\n    return (dx < 1e-8 && dy < 1e-8);\n};\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.quadtreebh/isSamePosition.js?");

/***/ }),

/***/ "./node_modules/ngraph.quadtreebh/node.js":
/*!************************************************!*\
  !*** ./node_modules/ngraph.quadtreebh/node.js ***!
  \************************************************/
/***/ (function(module) {

eval("/**\n * Internal data structure to represent 2D QuadTree node\n */\nmodule.exports = function Node() {\n  // body stored inside this node. In quad tree only leaf nodes (by construction)\n  // contain boides:\n  this.body = null;\n\n  // Child nodes are stored in quads. Each quad is presented by number:\n  // 0 | 1\n  // -----\n  // 2 | 3\n  this.quad0 = null;\n  this.quad1 = null;\n  this.quad2 = null;\n  this.quad3 = null;\n\n  // Total mass of current node\n  this.mass = 0;\n\n  // Center of mass coordinates\n  this.massX = 0;\n  this.massY = 0;\n\n  // bounding box coordinates\n  this.left = 0;\n  this.top = 0;\n  this.bottom = 0;\n  this.right = 0;\n};\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.quadtreebh/node.js?");

/***/ }),

/***/ "./node_modules/ngraph.random/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ngraph.random/index.js ***!
  \*********************************************/
/***/ (function(module) {

eval("module.exports = {\n  random: random,\n  randomIterator: randomIterator\n};\n\n/**\n * Creates seeded PRNG with two methods:\n *   next() and nextDouble()\n */\nfunction random(inputSeed) {\n  var seed = typeof inputSeed === 'number' ? inputSeed : (+ new Date());\n  var randomFunc = function() {\n      // Robert Jenkins' 32 bit integer hash function.\n      seed = ((seed + 0x7ed55d16) + (seed << 12))  & 0xffffffff;\n      seed = ((seed ^ 0xc761c23c) ^ (seed >>> 19)) & 0xffffffff;\n      seed = ((seed + 0x165667b1) + (seed << 5))   & 0xffffffff;\n      seed = ((seed + 0xd3a2646c) ^ (seed << 9))   & 0xffffffff;\n      seed = ((seed + 0xfd7046c5) + (seed << 3))   & 0xffffffff;\n      seed = ((seed ^ 0xb55a4f09) ^ (seed >>> 16)) & 0xffffffff;\n      return (seed & 0xfffffff) / 0x10000000;\n  };\n\n  return {\n      /**\n       * Generates random integer number in the range from 0 (inclusive) to maxValue (exclusive)\n       *\n       * @param maxValue Number REQUIRED. Ommitting this number will result in NaN values from PRNG.\n       */\n      next : function (maxValue) {\n          return Math.floor(randomFunc() * maxValue);\n      },\n\n      /**\n       * Generates random double number in the range from 0 (inclusive) to 1 (exclusive)\n       * This function is the same as Math.random() (except that it could be seeded)\n       */\n      nextDouble : function () {\n          return randomFunc();\n      }\n  };\n}\n\n/*\n * Creates iterator over array, which returns items of array in random order\n * Time complexity is guaranteed to be O(n);\n */\nfunction randomIterator(array, customRandom) {\n    var localRandom = customRandom || random();\n    if (typeof localRandom.next !== 'function') {\n      throw new Error('customRandom does not match expected API: next() function is missing');\n    }\n\n    return {\n        forEach : function (callback) {\n            var i, j, t;\n            for (i = array.length - 1; i > 0; --i) {\n                j = localRandom.next(i + 1); // i inclusive\n                t = array[j];\n                array[j] = array[i];\n                array[i] = t;\n\n                callback(t);\n            }\n\n            if (array.length) {\n                callback(array[0]);\n            }\n        },\n\n        /**\n         * Shuffles array randomly, in place.\n         */\n        shuffle : function () {\n            var i, j, t;\n            for (i = array.length - 1; i > 0; --i) {\n                j = localRandom.next(i + 1); // i inclusive\n                t = array[j];\n                array[j] = array[i];\n                array[i] = t;\n            }\n\n            return array;\n        }\n    };\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.random/index.js?");

/***/ }),

/***/ "./node_modules/ngraph.tojson/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ngraph.tojson/index.js ***!
  \*********************************************/
/***/ (function(module) {

eval("module.exports = save;\n\nfunction save(graph, customNodeTransform, customLinkTransform) {\n  // Object contains `nodes` and `links` arrays.\n  var result = {\n    nodes: [],\n    links: []\n  };\n\n  var nodeTransform = customNodeTransform || defaultTransformForNode;\n  var linkTransform = customLinkTransform || defaultTransformForLink;\n\n  graph.forEachNode(saveNode);\n  graph.forEachLink(saveLink);\n\n  return JSON.stringify(result);\n\n  function saveNode(node) {\n    // Each node of the graph is processed to take only required fields\n    // `id` and `data`\n    result.nodes.push(nodeTransform(node));\n  }\n\n  function saveLink(link) {\n    // Each link of the graph is also processed to take `fromId`, `toId` and\n    // `data`\n    result.links.push(linkTransform(link));\n  }\n\n  function defaultTransformForNode(node) {\n    var result = {\n      id: node.id\n    };\n    // We don't want to store undefined fields when it's not necessary:\n    if (node.data !== undefined) {\n      result.data = node.data;\n    }\n\n    return result;\n  }\n\n  function defaultTransformForLink(link) {\n    var result = {\n      fromId: link.fromId,\n      toId: link.toId,\n    };\n\n    if (link.data !== undefined) {\n      result.data = link.data;\n    }\n\n    return result;\n  }\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/ngraph.tojson/index.js?");

/***/ }),

/***/ "./node_modules/simplesvg/index.js":
/*!*****************************************!*\
  !*** ./node_modules/simplesvg/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = svg;\n\nsvg.compile = __webpack_require__(/*! ./lib/compile */ \"./node_modules/simplesvg/lib/compile.js\");\n\nvar compileTemplate = svg.compileTemplate = __webpack_require__(/*! ./lib/compile_template */ \"./node_modules/simplesvg/lib/compile_template.js\");\n\nvar domEvents = __webpack_require__(/*! add-event-listener */ \"./node_modules/add-event-listener/index.js\");\n\nvar svgns = \"http://www.w3.org/2000/svg\";\nvar xlinkns = \"http://www.w3.org/1999/xlink\";\n\nfunction svg(element, attrBag) {\n  var svgElement = augment(element);\n  if (attrBag === undefined) {\n    return svgElement;\n  }\n\n  var attributes = Object.keys(attrBag);\n  for (var i = 0; i < attributes.length; ++i) {\n    var attributeName = attributes[i];\n    var value = attrBag[attributeName];\n    if (attributeName === 'link') {\n      svgElement.link(value);\n    } else {\n      svgElement.attr(attributeName, value);\n    }\n  }\n\n  return svgElement;\n}\n\nfunction augment(element) {\n  var svgElement = element;\n\n  if (typeof element === \"string\") {\n    svgElement = window.document.createElementNS(svgns, element);\n  } else if (element.simplesvg) {\n    return element;\n  }\n\n  var compiledTempalte;\n\n  svgElement.simplesvg = true; // this is not good, since we are monkey patching svg\n  svgElement.attr = attr;\n  svgElement.append = append;\n  svgElement.link = link;\n  svgElement.text = text;\n\n  // add easy eventing\n  svgElement.on = on;\n  svgElement.off = off;\n\n  // data binding:\n  svgElement.dataSource = dataSource;\n\n  return svgElement;\n\n  function dataSource(model) {\n    if (!compiledTempalte) compiledTempalte = compileTemplate(svgElement);\n    compiledTempalte.link(model);\n    return svgElement;\n  }\n\n  function on(name, cb, useCapture) {\n    domEvents.addEventListener(svgElement, name, cb, useCapture);\n    return svgElement;\n  }\n\n  function off(name, cb, useCapture) {\n    domEvents.removeEventListener(svgElement, name, cb, useCapture);\n    return svgElement;\n  }\n\n  function append(content) {\n    var child = svg(content);\n    svgElement.appendChild(child);\n\n    return child;\n  }\n\n  function attr(name, value) {\n    if (arguments.length === 2) {\n      if (value !== null) {\n        svgElement.setAttributeNS(null, name, value);\n      } else {\n        svgElement.removeAttributeNS(null, name);\n      }\n\n      return svgElement;\n    }\n\n    return svgElement.getAttributeNS(null, name);\n  }\n\n  function link(target) {\n    if (arguments.length) {\n      svgElement.setAttributeNS(xlinkns, \"xlink:href\", target);\n      return svgElement;\n    }\n\n    return svgElement.getAttributeNS(xlinkns, \"xlink:href\");\n  }\n\n  function text(textContent) {\n    if (textContent !== undefined) {\n        svgElement.textContent = textContent;\n        return svgElement;\n    }\n    return svgElement.textContent;\n  }\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/simplesvg/index.js?");

/***/ }),

/***/ "./node_modules/simplesvg/lib/compile.js":
/*!***********************************************!*\
  !*** ./node_modules/simplesvg/lib/compile.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var parser = __webpack_require__(/*! ./domparser.js */ \"./node_modules/simplesvg/lib/domparser.js\");\nvar svg = __webpack_require__(/*! ../ */ \"./node_modules/simplesvg/index.js\");\n\nmodule.exports = compile;\n\nfunction compile(svgText) {\n  try {\n    svgText = addNamespaces(svgText);\n    return svg(parser.parseFromString(svgText, \"text/xml\").documentElement);\n  } catch (e) {\n    throw e;\n  }\n}\n\nfunction addNamespaces(text) {\n  if (!text) return;\n\n  var namespaces = 'xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\"';\n  var match = text.match(/^<\\w+/);\n  if (match) {\n    var tagLength = match[0].length;\n    return text.substr(0, tagLength) + ' ' + namespaces + ' ' + text.substr(tagLength);\n  } else {\n    throw new Error('Cannot parse input text: invalid xml?');\n  }\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/simplesvg/lib/compile.js?");

/***/ }),

/***/ "./node_modules/simplesvg/lib/compile_template.js":
/*!********************************************************!*\
  !*** ./node_modules/simplesvg/lib/compile_template.js ***!
  \********************************************************/
/***/ (function(module) {

eval("module.exports = template;\n\nvar BINDING_EXPR = /{{(.+?)}}/;\n\nfunction template(domNode) {\n  var allBindings = Object.create(null);\n  extractAllBindings(domNode, allBindings);\n\n  return {\n    link: function(model) {\n      Object.keys(allBindings).forEach(function(key) {\n        var setter = allBindings[key];\n        setter.forEach(changeModel);\n      });\n\n      function changeModel(setter) {\n        setter(model);\n      }\n    }\n  };\n}\n\nfunction extractAllBindings(domNode, allBindings) {\n  var nodeType = domNode.nodeType;\n  var typeSupported = (nodeType === 1) || (nodeType === 3);\n  if (!typeSupported) return;\n  var i;\n  if (domNode.hasChildNodes()) {\n    var domChildren = domNode.childNodes;\n    for (i = 0; i < domChildren.length; ++i) {\n      extractAllBindings(domChildren[i], allBindings);\n    }\n  }\n\n  if (nodeType === 3) { // text:\n    bindTextContent(domNode, allBindings);\n  }\n\n  if (!domNode.attributes) return; // this might be a text. Need to figure out what to do in that case\n\n  var attrs = domNode.attributes;\n  for (i = 0; i < attrs.length; ++i) {\n    bindDomAttribute(attrs[i], domNode, allBindings);\n  }\n}\n\nfunction bindDomAttribute(domAttribute, element, allBindings) {\n  var value = domAttribute.value;\n  if (!value) return; // unary attribute?\n\n  var modelNameMatch = value.match(BINDING_EXPR);\n  if (!modelNameMatch) return; // does not look like a binding\n\n  var attrName = domAttribute.localName;\n  var modelPropertyName = modelNameMatch[1];\n  var isSimpleValue = modelPropertyName.indexOf('.') < 0;\n\n  if (!isSimpleValue) throw new Error('simplesvg currently does not support nested bindings');\n\n  var propertyBindings = allBindings[modelPropertyName];\n  if (!propertyBindings) {\n    propertyBindings = allBindings[modelPropertyName] = [attributeSetter];\n  } else {\n    propertyBindings.push(attributeSetter);\n  }\n\n  function attributeSetter(model) {\n    element.setAttributeNS(null, attrName, model[modelPropertyName]);\n  }\n}\nfunction bindTextContent(element, allBindings) {\n  // todo reduce duplication\n  var value = element.nodeValue;\n  if (!value) return; // unary attribute?\n\n  var modelNameMatch = value.match(BINDING_EXPR);\n  if (!modelNameMatch) return; // does not look like a binding\n\n  var modelPropertyName = modelNameMatch[1];\n  var isSimpleValue = modelPropertyName.indexOf('.') < 0;\n\n  var propertyBindings = allBindings[modelPropertyName];\n  if (!propertyBindings) {\n    propertyBindings = allBindings[modelPropertyName] = [textSetter];\n  } else {\n    propertyBindings.push(textSetter);\n  }\n\n  function textSetter(model) {\n    element.nodeValue = model[modelPropertyName];\n  }\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/simplesvg/lib/compile_template.js?");

/***/ }),

/***/ "./node_modules/simplesvg/lib/domparser.js":
/*!*************************************************!*\
  !*** ./node_modules/simplesvg/lib/domparser.js ***!
  \*************************************************/
/***/ (function(module) {

eval("module.exports = createDomparser();\n\nfunction createDomparser() {\n  if (typeof DOMParser === 'undefined') {\n    return {\n      parseFromString: fail\n    };\n  }\n  return new DOMParser();\n}\n\nfunction fail() {\n  throw new Error('DOMParser is not supported by this platform. Please open issue here https://github.com/anvaka/simplesvg');\n}\n\n\n//# sourceURL=webpack://vivagraphjs/./node_modules/simplesvg/lib/domparser.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;